{
  "files": [
    {
      "name": "main.go",
      "path": "main.go",
      "content": "// Package main CLI应用程序主入口\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"strings\"\r\n\r\n\t\"code-context-generator/internal/autocomplete\"\r\n\t\"code-context-generator/internal/config\"\r\n\t\"code-context-generator/internal/env\"\r\n\t\"code-context-generator/internal/filesystem\"\r\n\t\"code-context-generator/internal/formatter\"\r\n\t\"code-context-generator/internal/selector\"\r\n\t\"code-context-generator/internal/utils\"\r\n\t\"code-context-generator/pkg/types\"\r\n\r\n\t\"github.com/spf13/cobra\"\r\n)\r\n\r\nvar (\r\n\t// 全局变量\r\n\tcfg        *types.Config\r\n\tconfigPath string\r\n\tverbose    bool\r\n\tversion    = \"1.0.0\"\r\n)\r\n\r\n// rootCmd 根命令\r\nvar rootCmd = \u0026cobra.Command{\r\n\tUse:   \"code-context-generator\",\r\n\tShort: \"代码上下文生成器\",\r\n\tLong: `代码上下文生成器 - 智能生成代码项目结构文档\r\n\r\n支持多种输出格式（JSON、XML、TOML、Markdown），提供交互式文件选择，\r\n自动补全功能，以及丰富的配置选项。`,\r\n\tVersion: version,\r\n\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\r\n\t\t// 首先加载.env文件（如果存在）\r\n\t\tif err := env.LoadEnv(\"\"); err != nil {\r\n\t\t\tfmt.Printf(\"警告: 加载.env文件失败: %v\\n\", err)\r\n\t\t}\r\n\r\n\t\t// 加载配置\r\n\t\tconfigManager := config.NewManager()\r\n\r\n\t\t// 如果有指定配置文件路径，使用它\r\n\t\tif configPath != \"\" {\r\n\t\t\tif err := configManager.Load(configPath); err != nil {\r\n\t\t\t\treturn fmt.Errorf(\"加载配置文件失败: %w\", err)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// 尝试加载默认配置文件\r\n\t\t\tdefaultConfigPath := \"config.yaml\"\r\n\t\t\tif err := configManager.Load(defaultConfigPath); err != nil {\r\n\t\t\t\t// 如果默认配置文件不存在，使用默认配置\r\n\t\t\t\tfmt.Println(\"使用默认配置\")\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcfg = configManager.Get()\r\n\t\treturn nil\r\n\t},\r\n}\r\n\r\n// generateCmd 生成命令\r\nvar generateCmd = \u0026cobra.Command{\r\n\tUse:   \"generate [路径]\",\r\n\tShort: \"生成代码上下文\",\r\n\tLong:  \"扫描指定路径并生成代码项目结构文档\",\r\n\tArgs:  cobra.MaximumNArgs(1),\r\n\tRunE:  runGenerate,\r\n}\r\n\r\n// selectCmd 选择命令\r\nvar selectCmd = \u0026cobra.Command{\r\n\tUse:   \"select [路径]\",\r\n\tShort: \"交互式选择文件\",\r\n\tLong:  \"使用交互式界面选择要包含的文件和文件夹\",\r\n\tArgs:  cobra.MaximumNArgs(1),\r\n\tRunE:  runSelect,\r\n}\r\n\r\n// configCmd 配置命令\r\nvar configCmd = \u0026cobra.Command{\r\n\tUse:   \"config\",\r\n\tShort: \"配置管理\",\r\n\tLong:  \"管理应用程序配置\",\r\n}\r\n\r\n// configShowCmd 显示配置\r\nvar configShowCmd = \u0026cobra.Command{\r\n\tUse:   \"show\",\r\n\tShort: \"显示当前配置\",\r\n\tLong:  \"显示当前配置设置\",\r\n\tRunE:  runConfigShow,\r\n}\r\n\r\n// configInitCmd 初始化配置\r\nvar configInitCmd = \u0026cobra.Command{\r\n\tUse:   \"init\",\r\n\tShort: \"初始化配置文件\",\r\n\tLong:  \"创建默认配置文件\",\r\n\tRunE:  runConfigInit,\r\n}\r\n\r\n// autocompleteCmd 自动补全命令\r\nvar autocompleteCmd = \u0026cobra.Command{\r\n\tUse:   \"autocomplete [路径]\",\r\n\tShort: \"文件路径自动补全\",\r\n\tLong:  \"提供文件路径自动补全建议\",\r\n\tArgs:  cobra.MaximumNArgs(1),\r\n\tRunE:  runAutocomplete,\r\n}\r\n\r\n// init 初始化函数\r\nfunc init() {\r\n\t// 添加子命令\r\n\trootCmd.AddCommand(generateCmd)\r\n\trootCmd.AddCommand(selectCmd)\r\n\trootCmd.AddCommand(configCmd)\r\n\trootCmd.AddCommand(autocompleteCmd)\r\n\r\n\t// 配置命令子命令\r\n\tconfigCmd.AddCommand(configShowCmd)\r\n\tconfigCmd.AddCommand(configInitCmd)\r\n\r\n\t// 全局标志\r\n\trootCmd.PersistentFlags().StringVarP(\u0026configPath, \"config\", \"c\", \"\", \"配置文件路径\")\r\n\trootCmd.PersistentFlags().BoolVarP(\u0026verbose, \"verbose\", \"v\", false, \"详细输出\")\r\n\r\n\t// generate命令标志\r\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \"\", \"输出文件路径\")\r\n\tgenerateCmd.Flags().StringP(\"format\", \"f\", \"json\", \"输出格式 (json, xml, toml, markdown)\")\r\n\tgenerateCmd.Flags().StringSliceP(\"exclude\", \"e\", []string{}, \"排除的文件/目录模式\")\r\n\tgenerateCmd.Flags().StringSliceP(\"include\", \"i\", []string{}, \"包含的文件/目录模式\")\r\n\tgenerateCmd.Flags().BoolP(\"recursive\", \"r\", true, \"递归扫描\")\r\n\tgenerateCmd.Flags().Bool(\"hidden\", false, \"包含隐藏文件\")\r\n\tgenerateCmd.Flags().IntP(\"max-depth\", \"d\", 0, \"最大扫描深度 (0表示无限制)\")\r\n\tgenerateCmd.Flags().IntP(\"max-size\", \"s\", 0, \"最大文件大小 (字节, 0表示无限制)\")\r\n\tgenerateCmd.Flags().BoolP(\"content\", \"C\", true, \"包含文件内容\")\r\n\tgenerateCmd.Flags().BoolP(\"hash\", \"H\", false, \"包含文件哈希\")\r\n\tgenerateCmd.Flags().Bool(\"exclude-binary\", true, \"排除二进制文件\")\r\n\r\n\t// select命令标志\r\n\tselectCmd.Flags().StringP(\"output\", \"o\", \"\", \"输出文件路径\")\r\n\tselectCmd.Flags().StringP(\"format\", \"f\", \"json\", \"输出格式\")\r\n\tselectCmd.Flags().BoolP(\"multi\", \"m\", true, \"允许多选\")\r\n\tselectCmd.Flags().StringP(\"filter\", \"F\", \"\", \"文件过滤器\")\r\n\r\n\t// autocomplete命令标志\r\n\tautocompleteCmd.Flags().IntP(\"limit\", \"l\", 10, \"最大建议数量\")\r\n\tautocompleteCmd.Flags().StringP(\"type\", \"t\", \"file\", \"补全类型 (file, dir, ext, pattern)\")\r\n}\r\n\r\n// main 主函数\r\nfunc main() {\r\n\tif err := rootCmd.Execute(); err != nil {\r\n\t\tfmt.Fprintln(os.Stderr, utils.ErrorColor(\"错误:\"), err)\r\n\t\tos.Exit(1)\r\n\t}\r\n}\r\n\r\n// runGenerate 运行生成命令\r\nfunc runGenerate(cmd *cobra.Command, args []string) error {\r\n\t// 获取路径\r\n\tpath := \".\"\r\n\tif len(args) \u003e 0 {\r\n\t\tpath = args[0]\r\n\t}\r\n\r\n\t// 解析标志\r\n\toutput, _ := cmd.Flags().GetString(\"output\")\r\n\tformat, _ := cmd.Flags().GetString(\"format\")\r\n\texclude, _ := cmd.Flags().GetStringSlice(\"exclude\")\r\n\tinclude, _ := cmd.Flags().GetStringSlice(\"include\")\r\n\trecursive, _ := cmd.Flags().GetBool(\"recursive\")\r\n\thidden, _ := cmd.Flags().GetBool(\"hidden\")\r\n\tmaxDepth, _ := cmd.Flags().GetInt(\"max-depth\")\r\n\tmaxSize, _ := cmd.Flags().GetInt(\"max-size\")\r\n\tcontent, _ := cmd.Flags().GetBool(\"content\")\r\n\thash, _ := cmd.Flags().GetBool(\"hash\")\r\n\texcludeBinary, _ := cmd.Flags().GetBool(\"exclude-binary\")\r\n\r\n\t// 验证格式\r\n\tif !isValidFormat(format) {\r\n\t\treturn fmt.Errorf(\"无效的输出格式: %s\", format)\r\n\t}\r\n\r\n\t// 创建文件系统遍历器\r\n\twalker := filesystem.NewFileSystemWalker(types.WalkOptions{})\r\n\r\n\t// 如果递归选项被禁用，设置最大深度为1\r\n\tif !recursive \u0026\u0026 maxDepth == 0 {\r\n\t\tmaxDepth = 1\r\n\t}\r\n\r\n\t// 执行遍历\r\n\tif verbose {\r\n\t\tfmt.Printf(\"正在扫描路径: %s (递归: %v)\\n\", path, recursive)\r\n\t}\r\n\r\n\t// 创建遍历选项\r\n\twalkOptions := \u0026types.WalkOptions{\r\n\t\tMaxDepth:        maxDepth,\r\n\t\tMaxFileSize:     int64(maxSize),\r\n\t\tExcludePatterns: exclude,\r\n\t\tIncludePatterns: include,\r\n\t\tFollowSymlinks:  false,\r\n\t\tShowHidden:      hidden,\r\n\t\tExcludeBinary:   excludeBinary,\r\n\t}\r\n\r\n\tresult, err := walker.Walk(path, walkOptions)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"扫描失败: %w\", err)\r\n\t}\r\n\r\n\tif verbose {\r\n\t\tfmt.Printf(\"扫描完成: %d 个文件, %d 个目录\\n\", result.FileCount, result.FolderCount)\r\n\t}\r\n\r\n\t// 创建格式化器\r\n\tformatter, err := formatter.NewFormatter(format)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"创建格式化器失败: %w\", err)\r\n\t}\r\n\r\n\t// ContextData 已经包含了所有需要的信息\r\n\t// 初始化metadata map并添加根路径\r\n\tif result.Metadata == nil {\r\n\t\tresult.Metadata = make(map[string]interface{})\r\n\t}\r\n\tresult.Metadata[\"root_path\"] = path\r\n\tcontextData := *result\r\n\r\n\t// 格式化输出\r\n\toutputData, err := formatter.Format(contextData)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"格式化输出失败: %w\", err)\r\n\t}\r\n\r\n\t// 添加额外信息\r\n\tif content || hash {\r\n\t\t// 创建 WalkResult 用于 addFileContent\r\n\t\twalkResult := \u0026types.WalkResult{\r\n\t\t\tFiles:       result.Files,\r\n\t\t\tFolders:     result.Folders,\r\n\t\t\tFileCount:   result.FileCount,\r\n\t\t\tFolderCount: result.FolderCount,\r\n\t\t\tTotalSize:   result.TotalSize,\r\n\t\t\tRootPath:    path,\r\n\t\t}\r\n\t\toutputData = addFileContent(outputData, walkResult, content, hash)\r\n\t}\r\n\r\n\t// 输出结果\r\n\tif output != \"\" {\r\n\t\tif err := os.WriteFile(output, []byte(outputData), 0644); err != nil {\r\n\t\t\treturn fmt.Errorf(\"写入输出文件失败: %w\", err)\r\n\t\t}\r\n\t\tif verbose {\r\n\t\t\tfmt.Println(utils.SuccessColor(\"输出已写入:\"), output)\r\n\t\t}\r\n\t} else {\r\n\t\tfmt.Println(outputData)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n// runSelect 运行选择命令\r\nfunc runSelect(cmd *cobra.Command, args []string) error {\r\n\t// 获取路径\r\n\tpath := \".\"\r\n\tif len(args) \u003e 0 {\r\n\t\tpath = args[0]\r\n\t}\r\n\r\n\t// 解析标志\r\n\toutput, _ := cmd.Flags().GetString(\"output\")\r\n\tformat, _ := cmd.Flags().GetString(\"format\")\r\n\tmulti, _ := cmd.Flags().GetBool(\"multi\")\r\n\tfilter, _ := cmd.Flags().GetString(\"filter\")\r\n\tincludeContent, _ := cmd.Flags().GetBool(\"content\")\r\n\r\n\t// 创建选择器配置\r\n\tconfig := \u0026types.Config{\r\n\t\tFileProcessing: types.FileProcessingConfig{\r\n\t\t\tIncludeHidden: false,\r\n\t\t\tIncludeContent: includeContent,\r\n\t\t},\r\n\t}\r\n\tfileSelector := selector.NewFileSelector(config)\r\n\r\n\t// 执行选择\r\n\tif verbose {\r\n\t\tfmt.Printf(\"启动交互式选择器... (多选: %v, 过滤器: %s)\\n\", multi, filter)\r\n\t}\r\n\r\n\t// 选择文件和目录\r\n\tselectOptions := \u0026types.SelectOptions{\r\n\t\tRecursive:       true,\r\n\t\tShowHidden:      false,\r\n\t\tMaxDepth:        0,\r\n\t\tIncludePatterns: []string{},\r\n\t\tExcludePatterns: []string{},\r\n\t}\r\n\r\n\tfiles, err := fileSelector.SelectFiles(path, selectOptions)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"选择文件失败: %w\", err)\r\n\t}\r\n\r\n\tfolders, err := fileSelector.SelectFolders(path, selectOptions)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"选择目录失败: %w\", err)\r\n\t}\r\n\r\n\t// 合并选择结果\r\n\tallItems := append(files, folders...)\r\n\r\n\t// 交互式选择\r\n\tselected, err := fileSelector.InteractiveSelect(allItems, \"选择文件和目录:\")\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"选择失败: %w\", err)\r\n\t}\r\n\r\n\tif len(selected) == 0 {\r\n\t\tfmt.Println(\"未选择任何文件\")\r\n\t\treturn nil\r\n\t}\r\n\r\n\tif verbose {\r\n\t\tfmt.Printf(\"已选择 %d 个项目\\n\", len(selected))\r\n\t}\r\n\r\n\t// 创建结果\r\n\tresult := \u0026types.WalkResult{\r\n\t\tFiles:    []types.FileInfo{},\r\n\t\tFolders:  []types.FolderInfo{},\r\n\t\tRootPath: path,\r\n\t}\r\n\r\n\t// 添加选择的文件和目录\r\n\tfor _, item := range selected {\r\n\t\tinfo, err := os.Stat(item)\r\n\t\tif err != nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif info.IsDir() {\r\n\t\t\tresult.Folders = append(result.Folders, types.FolderInfo{\r\n\t\t\t\tPath:  item,\r\n\t\t\t\tName:  info.Name(),\r\n\t\t\t\tSize:  0,\r\n\t\t\t\tCount: 0,\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tresult.Files = append(result.Files, types.FileInfo{\r\n\t\t\t\tPath:     item,\r\n\t\t\t\tName:     info.Name(),\r\n\t\t\t\tSize:     info.Size(),\r\n\t\t\t\tModTime:  info.ModTime(),\r\n\t\t\t\tIsBinary: utils.IsBinaryFile(item),\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t// 更新统计信息\r\n\tresult.FileCount = len(result.Files)\r\n\tresult.FolderCount = len(result.Folders)\r\n\r\n\t// 创建格式化器\r\n\tformatter, err := formatter.NewFormatter(format)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"创建格式化器失败: %w\", err)\r\n\t}\r\n\r\n\t// 将 WalkResult 转换为 ContextData\r\n\tcontextData := types.ContextData{\r\n\t\tFiles:       result.Files,\r\n\t\tFolders:     result.Folders,\r\n\t\tFileCount:   result.FileCount,\r\n\t\tFolderCount: result.FolderCount,\r\n\t\tTotalSize:   result.TotalSize,\r\n\t\tMetadata:    make(map[string]interface{}),\r\n\t}\r\n\r\n\t// 如果需要包含文件内容，读取文件内容\r\n\tif includeContent {\r\n\t\tfor i := range contextData.Files {\r\n\t\t\tif !contextData.Files[i].IsBinary {\r\n\t\t\t\tcontent, _, err := utils.ReadFileContentWithEncoding(contextData.Files[i].Path, 0)\r\n\t\t\t\tif err == nil {\r\n\t\t\t\t\tcontextData.Files[i].Content = content\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcontextData.Files[i].Content = \"[二进制文件]\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 格式化输出\r\n\toutputData, err := formatter.Format(contextData)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"格式化输出失败: %w\", err)\r\n\t}\r\n\r\n\t// 输出结果\r\n\tif output != \"\" {\r\n\t\tif err := os.WriteFile(output, []byte(outputData), 0644); err != nil {\r\n\t\t\treturn fmt.Errorf(\"写入输出文件失败: %w\", err)\r\n\t\t}\r\n\t\tif verbose {\r\n\t\t\tfmt.Println(utils.SuccessColor(\"输出已写入:\"), output)\r\n\t\t}\r\n\t} else {\r\n\t\tfmt.Println(outputData)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n// runConfigShow 运行配置显示命令\r\nfunc runConfigShow(cmd *cobra.Command, args []string) error {\r\n\t// 生成配置输出\r\n\tconfigOutput := generateConfigOutput(cfg)\r\n\tfmt.Println(configOutput)\r\n\treturn nil\r\n}\r\n\r\n// runConfigInit 运行配置初始化命令\r\nfunc runConfigInit(cmd *cobra.Command, args []string) error {\r\n\t// 初始化配置\r\n\tconfigManager := config.NewManager()\r\n\tcfg = configManager.Get()\r\n\r\n\t// 保存配置到文件\r\n\tif err := configManager.Save(\"config.yaml\", \"yaml\"); err != nil {\r\n\t\treturn fmt.Errorf(\"保存配置文件失败: %w\", err)\r\n\t}\r\n\r\n\tfmt.Println(utils.SuccessColor(\"配置文件已创建: config.yaml\"))\r\n\treturn nil\r\n}\r\n\r\n// runAutocomplete 运行自动补全命令\r\nfunc runAutocomplete(cmd *cobra.Command, args []string) error {\r\n\t// 获取路径\r\n\tpath := \"\"\r\n\tif len(args) \u003e 0 {\r\n\t\tpath = args[0]\r\n\t}\r\n\r\n\t// 解析标志\r\n\tlimit, _ := cmd.Flags().GetInt(\"limit\")\r\n\tcompleteType, _ := cmd.Flags().GetString(\"type\")\r\n\r\n\t// 创建自动补全器\r\n\tautocompleter := autocomplete.NewAutocompleter(\u0026types.AutocompleteConfig{\r\n\t\tEnabled:        true,\r\n\t\tMinChars:       1,\r\n\t\tMaxSuggestions: limit,\r\n\t})\r\n\r\n\t// 获取建议\r\n\tcompleteTypeEnum := types.CompleteFilePath\r\n\tswitch completeType {\r\n\tcase \"dir\":\r\n\t\tcompleteTypeEnum = types.CompleteDirectory\r\n\tcase \"ext\":\r\n\t\tcompleteTypeEnum = types.CompleteExtension\r\n\tcase \"pattern\":\r\n\t\tcompleteTypeEnum = types.CompletePattern\r\n\tcase \"generic\":\r\n\t\tcompleteTypeEnum = types.CompleteGeneric\r\n\t}\r\n\r\n\tcontext := \u0026types.CompleteContext{\r\n\t\tType: completeTypeEnum,\r\n\t\tData: make(map[string]interface{}),\r\n\t}\r\n\tsuggestions, err := autocompleter.Complete(path, context)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"自动补全失败: %w\", err)\r\n\t}\r\n\r\n\t// 输出建议\r\n\tfor _, suggestion := range suggestions {\r\n\t\tfmt.Println(suggestion)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n// isValidFormat 检查格式是否有效\r\nfunc isValidFormat(format string) bool {\r\n\tvalidFormats := []string{\"json\", \"xml\", \"toml\", \"markdown\", \"md\"}\r\n\tfor _, valid := range validFormats {\r\n\t\tif format == valid {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r\n\r\n// addFileContent 添加文件内容\r\nfunc addFileContent(outputData string, _ *types.WalkResult, includeContent, includeHash bool) string {\r\n\t// 如果不需要包含内容和哈希，直接返回原始数据\r\n\tif !includeContent \u0026\u0026 !includeHash {\r\n\t\treturn outputData\r\n\t}\r\n\r\n\t// 这里可以根据需要添加文件内容和哈希处理逻辑\r\n\t// 目前保持简化实现，后续可以根据具体需求扩展\r\n\tif verbose {\r\n\t\tfmt.Println(utils.InfoColor(\"注意: 文件内容和哈希功能暂未完全实现\"))\r\n\t}\r\n\r\n\treturn outputData\r\n}\r\n\r\n// generateConfigOutput 生成配置输出\r\nfunc generateConfigOutput(cfg *types.Config) string {\r\n\tvar output strings.Builder\r\n\r\n\toutput.WriteString(\"当前配置:\\n\")\r\n\toutput.WriteString(\"==================\\n\\n\")\r\n\r\n\toutput.WriteString(fmt.Sprintf(\"默认格式: %s\\n\", cfg.Output.DefaultFormat))\r\n\toutput.WriteString(fmt.Sprintf(\"输出目录: %s\\n\", cfg.Output.OutputDir))\r\n\toutput.WriteString(fmt.Sprintf(\"文件名模板: %s\\n\", cfg.Output.FilenameTemplate))\r\n\r\n\toutput.WriteString(\"\\n文件处理:\\n\")\r\n\toutput.WriteString(fmt.Sprintf(\"  最大文件大小: %s\\n\", cfg.Filters.MaxFileSize))\r\n\toutput.WriteString(fmt.Sprintf(\"  最大深度: %d\\n\", cfg.Filters.MaxDepth))\r\n\toutput.WriteString(fmt.Sprintf(\"  跟随符号链接: %v\\n\", cfg.Filters.FollowSymlinks))\r\n\toutput.WriteString(fmt.Sprintf(\"  排除二进制文件: %v\\n\", cfg.Filters.ExcludeBinary))\r\n\r\n\tif len(cfg.Filters.ExcludePatterns) \u003e 0 {\r\n\t\toutput.WriteString(\"  排除模式:\\n\")\r\n\t\tfor _, pattern := range cfg.Filters.ExcludePatterns {\r\n\t\t\toutput.WriteString(fmt.Sprintf(\"    - %s\\n\", pattern))\r\n\t\t}\r\n\t}\r\n\r\n\tif len(cfg.Filters.IncludePatterns) \u003e 0 {\r\n\t\toutput.WriteString(\"  包含模式:\\n\")\r\n\t\tfor _, pattern := range cfg.Filters.IncludePatterns {\r\n\t\t\toutput.WriteString(fmt.Sprintf(\"    - %s\\n\", pattern))\r\n\t\t}\r\n\t}\r\n\r\n\treturn output.String()\r\n}\r\n",
      "size": 15887,
      "mod_time": "2025-10-01T21:25:36.500602+08:00",
      "is_dir": false,
      "is_hidden": false,
      "is_binary": false
    },
    {
      "name": "config.yaml",
      "path": "config.yaml",
      "content": "formats:\n  xml:\n    enabled: true\n    root_tag: context\n    file_tag: file\n    folder_tag: folder\n    files_tag: files\n    fields:\n      content: content\n      filename: filename\n      path: path\n    template: \"\"\n    formatting:\n      indent: \"  \"\n      declaration: true\n      encoding: UTF-8\n  json:\n    enabled: true\n    structure:\n      file: file\n      folder: folder\n    fields:\n      content: content\n      filename: filename\n      path: path\n    template: \"\"\n    formatting: {}\n  toml:\n    enabled: true\n    structure:\n      file_section: file\n      folder_section: folder\n    fields:\n      content: content\n      filename: filename\n      path: path\n    template: \"\"\n    formatting: {}\n  markdown:\n    enabled: true\n    structure:\n      code_block: \"```\"\n      file_header: \"##\"\n      folder_header: \"###\"\n    fields: {}\n    template: \"\"\n    formatting:\n      add_toc: false\n      code_language: true\n      separator: |+\n        \n\nfields:\n  custom_names:\n    filecontent: content\n    filename: name\n    filepath: path\n  filter:\n    include: []\n    exclude: []\n  processing:\n    max_length: 0\n    add_line_numbers: false\n    trim_whitespace: true\n    code_highlight: false\nfilters:\n  max_file_size: 10MB\n  exclude_patterns:\n  - \"*.tmp\"\n  - \"*.log\"\n  - \"*.swp\"\n  - .*\n  - node_modules/\n  - target/\n  - dist/\n  - build/\n  - .env\n  - .git/\n  - .vscode/\n  - .idea/\n  - __pycache__/\n  - \"*.pyc\"\n  - .venv\n  - \"*.class\"\n  include_patterns: []\n  max_depth: 0\n  follow_symlinks: false\n  exclude_binary: false\noutput:\n  format: \"\"\n  file_path: \"\"\n  encoding: \"\"\n  default_format: xml\n  output_dir: \"\"\n  filename_template: context_{{.timestamp}}.{{.extension}}\n  timestamp_format: \"20060102_150405\"\nui:\n  theme: \"\"\n  show_progress: false\n  show_size: false\n  show_date: false\n  show_preview: false\n  selector:\n    show_hidden: false\n    show_size: true\n    show_modified: false\n  autocomplete:\n    enabled: true\n    min_chars: 1\n    max_suggestions: 10\nfile_processing:\n  includehidden: false\n  maxfilesize: 0\n  maxdepth: 0\n  excludepatterns: []\n  includepatterns: []\n  includecontent: true\n  includehash: false\nperformance:\n  maxworkers: 0\n  buffersize: 0\n  cacheenabled: false\n  cachesize: 0\nlogging:\n  level: \"\"\n  filepath: \"\"\n  maxsize: 0\n  maxbackups: 0\n  maxage: 0\n",
      "size": 2268,
      "mod_time": "2025-10-01T21:26:51.5210375+08:00",
      "is_dir": false,
      "is_hidden": false,
      "is_binary": false
    }
  ],
  "folders": [],
  "file_count": 2,
  "folder_count": 0,
  "total_size": 18155,
  "metadata": {
    "root_path": "."
  }
}