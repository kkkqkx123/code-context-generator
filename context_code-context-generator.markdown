# 代码上下文

生成时间: 2025-10-02T17:39:20+08:00

## 文件

### .env.example

- **路径**: `D:\ide\tool\code-context-generator\.env.example`
- **大小**: 349 字节
- **修改时间**: 2025-10-02T17:24:54+08:00

**[二进制文件 - 内容未显示]**

### .env

- **路径**: `D:\ide\tool\code-context-generator\.env`
- **大小**: 724 字节
- **修改时间**: 2025-10-02T17:24:38+08:00

**[二进制文件 - 内容未显示]**

### COMMIT_EDITMSG

- **路径**: `D:\ide\tool\code-context-generator\.git\COMMIT_EDITMSG`
- **大小**: 7 字节
- **修改时间**: 2025-10-02T16:59:04+08:00

```
update

```

### FETCH_HEAD

- **路径**: `D:\ide\tool\code-context-generator\.git\FETCH_HEAD`
- **大小**: 111 字节
- **修改时间**: 2025-10-01T13:12:17+08:00

```
a08d2e4317c89cc95c17f3f0221ab5bc64d4a887		branch 'main' of https://github.com/kkkqkx123/code-context-generator

```

### HEAD

- **路径**: `D:\ide\tool\code-context-generator\.git\HEAD`
- **大小**: 21 字节
- **修改时间**: 2025-09-30T21:06:51+08:00

```
ref: refs/heads/main

```

### applypatch-msg.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\applypatch-msg.sample`
- **大小**: 478 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### commit-msg.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\commit-msg.sample`
- **大小**: 896 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### config

- **路径**: `D:\ide\tool\code-context-generator\.git\config`
- **大小**: 296 字节
- **修改时间**: 2025-09-30T21:06:55+08:00

```
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	ignorecase = true
[remote "origin"]
	url = https://github.com/kkkqkx123/code-context-generator.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

```

### description

- **路径**: `D:\ide\tool\code-context-generator\.git\description`
- **大小**: 73 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

```
Unnamed repository; edit this file 'description' to name the repository.

```

### post-update.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\post-update.sample`
- **大小**: 189 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### pre-applypatch.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\pre-applypatch.sample`
- **大小**: 424 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### pre-commit.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\pre-commit.sample`
- **大小**: 1649 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### pre-push.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\pre-push.sample`
- **大小**: 1374 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### fsmonitor-watchman.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\fsmonitor-watchman.sample`
- **大小**: 4726 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### pre-merge-commit.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\pre-merge-commit.sample`
- **大小**: 416 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### pre-rebase.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\pre-rebase.sample`
- **大小**: 4898 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### pre-receive.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\pre-receive.sample`
- **大小**: 544 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### ORIG_HEAD

- **路径**: `D:\ide\tool\code-context-generator\.git\ORIG_HEAD`
- **大小**: 41 字节
- **修改时间**: 2025-10-01T19:22:49+08:00

```
d066146c191ffe5bdd1b67650198263ce3367a97

```

### push-to-checkout.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\push-to-checkout.sample`
- **大小**: 2783 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### prepare-commit-msg.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\prepare-commit-msg.sample`
- **大小**: 1492 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### sendemail-validate.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\sendemail-validate.sample`
- **大小**: 2308 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### update.sample

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks\update.sample`
- **大小**: 3650 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

**[二进制文件 - 内容未显示]**

### index

- **路径**: `D:\ide\tool\code-context-generator\.git\index`
- **大小**: 7178 字节
- **修改时间**: 2025-10-02T17:39:17+08:00

**[二进制文件 - 内容未显示]**

### exclude

- **路径**: `D:\ide\tool\code-context-generator\.git\info\exclude`
- **大小**: 240 字节
- **修改时间**: 2025-09-30T21:05:07+08:00

```
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

```

### HEAD

- **路径**: `D:\ide\tool\code-context-generator\.git\logs\HEAD`
- **大小**: 5824 字节
- **修改时间**: 2025-10-02T16:59:04+08:00

```
0000000000000000000000000000000000000000 6d54d02ba91ee3fdf9831b9ed992bcbffed7dd28 Admin <3353074868@qq.com> 1759237519 +0800	commit (initial): init
6d54d02ba91ee3fdf9831b9ed992bcbffed7dd28 0000000000000000000000000000000000000000 Admin <3353074868@qq.com> 1759237611 +0800	Branch: renamed refs/heads/main to refs/heads/main
6d54d02ba91ee3fdf9831b9ed992bcbffed7dd28 6d54d02ba91ee3fdf9831b9ed992bcbffed7dd28 Admin <3353074868@qq.com> 1759237611 +0800	Branch: renamed refs/heads/main to refs/heads/main
6d54d02ba91ee3fdf9831b9ed992bcbffed7dd28 651801236b06db6af1814298278b02084d2d58cb Admin <3353074868@qq.com> 1759238695 +0800	commit: add depi
651801236b06db6af1814298278b02084d2d58cb 54633f7765c458910bfc49803627ef8184d3b49e Admin <3353074868@qq.com> 1759238868 +0800	commit: fix complie errors
54633f7765c458910bfc49803627ef8184d3b49e d353b3c0706215b1e7b4f2c478d45e97663806bc Admin <3353074868@qq.com> 1759241421 +0800	commit: add docs
d353b3c0706215b1e7b4f2c478d45e97663806bc 0383d03a2dbd6c0373a3ae2b7b02aaae26a647ff Admin <3353074868@qq.com> 1759246848 +0800	commit: add go files
0383d03a2dbd6c0373a3ae2b7b02aaae26a647ff 35fa46e5ce659db5952511887bf0c5f02667dd0c Admin <3353074868@qq.com> 1759248894 +0800	commit: update
35fa46e5ce659db5952511887bf0c5f02667dd0c d41e05ab8e1448470df7b150c52b585372e812f3 Admin <3353074868@qq.com> 1759287923 +0800	commit: add test for filesystem
d41e05ab8e1448470df7b150c52b585372e812f3 ce4a01ce6d7419705d16c153a234fc95844c00ea Admin <3353074868@qq.com> 1759289156 +0800	commit: add formatter test
ce4a01ce6d7419705d16c153a234fc95844c00ea 42866dfb081f9cb6e4e4d378b78ed1f918392703 Admin <3353074868@qq.com> 1759291574 +0800	commit: add all unit tests
42866dfb081f9cb6e4e4d378b78ed1f918392703 a08d2e4317c89cc95c17f3f0221ab5bc64d4a887 Admin <3353074868@qq.com> 1759293406 +0800	commit: add more icon styles
a08d2e4317c89cc95c17f3f0221ab5bc64d4a887 89ffafa304a9121058f5d581e7c5f5ebb69698d9 Admin <3353074868@qq.com> 1759295535 +0800	commit: splitting models
89ffafa304a9121058f5d581e7c5f5ebb69698d9 4d4c486f871dd55759abaf94866e9f23a419ec8d Admin <3353074868@qq.com> 1759297958 +0800	commit: update file_selector
4d4c486f871dd55759abaf94866e9f23a419ec8d fb8602c320119a52f6f36c4870953fc9228c7d40 Admin <3353074868@qq.com> 1759298270 +0800	commit: update git rule
fb8602c320119a52f6f36c4870953fc9228c7d40 5db27e63068759b2df4afb1272fa5313791d38c2 Admin <3353074868@qq.com> 1759299325 +0800	commit: fix cursor issue in file_selector
5db27e63068759b2df4afb1272fa5313791d38c2 35666e923071dc9ccf5a628a794bc7b8dfbba346 Admin <3353074868@qq.com> 1759307060 +0800	commit: complete binary check logic
35666e923071dc9ccf5a628a794bc7b8dfbba346 f715c05d21ca41476869645f609a397ec29ae46f Admin <3353074868@qq.com> 1759307867 +0800	commit: update
f715c05d21ca41476869645f609a397ec29ae46f 052df305d8491e1be02205cd6de2ebd0057e3603 Admin <3353074868@qq.com> 1759310250 +0800	commit: update
052df305d8491e1be02205cd6de2ebd0057e3603 173764aff64038eccc388b0f8c0f9f7b41e4bd9f Admin <3353074868@qq.com> 1759310869 +0800	commit: add env config
173764aff64038eccc388b0f8c0f9f7b41e4bd9f d066146c191ffe5bdd1b67650198263ce3367a97 Admin <3353074868@qq.com> 1759315086 +0800	commit: temp
d066146c191ffe5bdd1b67650198263ce3367a97 173764aff64038eccc388b0f8c0f9f7b41e4bd9f Admin <3353074868@qq.com> 1759317769 +0800	reset: moving to 173764aff64038eccc388b0f8c0f9f7b41e4bd9f
173764aff64038eccc388b0f8c0f9f7b41e4bd9f 8f6dea02e5140f4c14d374d3b880b89d877ac455 Admin <3353074868@qq.com> 1759318890 +0800	commit: complete .env+config
8f6dea02e5140f4c14d374d3b880b89d877ac455 49d7e015af0cd1ee1184d82d0e86b1f64e1c4407 Admin <3353074868@qq.com> 1759322507 +0800	commit: temp
49d7e015af0cd1ee1184d82d0e86b1f64e1c4407 9cf74cd69cd2910cdffc87642aa47ba2be68ab40 Admin <3353074868@qq.com> 1759323343 +0800	commit: split utils
9cf74cd69cd2910cdffc87642aa47ba2be68ab40 5e275a1b6a3d6acc17e5a0f88e91ad5138b169bb Admin <3353074868@qq.com> 1759324233 +0800	commit: split selector
5e275a1b6a3d6acc17e5a0f88e91ad5138b169bb 8bcf772220543815327f3893284ca5d6c8bc31d7 Admin <3353074868@qq.com> 1759326457 +0800	commit: complete basic function
8bcf772220543815327f3893284ca5d6c8bc31d7 6419014d3333baa0a0c56d82ea045c2373cff86e Admin <3353074868@qq.com> 1759328193 +0800	commit: update docs and config logic
6419014d3333baa0a0c56d82ea045c2373cff86e 9fc3919de2d376e694d9d1088e4352ac92cf934a Admin <3353074868@qq.com> 1759331052 +0800	commit: add docs for TUI workflow
9fc3919de2d376e694d9d1088e4352ac92cf934a 225d2864a6d12632887de284075336619eb8f90d Admin <3353074868@qq.com> 1759360557 +0800	commit: update filesystem
225d2864a6d12632887de284075336619eb8f90d 66e3041169a4bd6daea7d7f26b26aa7ee47b1b93 Admin <3353074868@qq.com> 1759362271 +0800	commit: update autocompletion
66e3041169a4bd6daea7d7f26b26aa7ee47b1b93 44ff0e81c10a5e0de239035bc98ef24e63a1ea9b Admin <3353074868@qq.com> 1759363486 +0800	commit: add autocompletion model, and update docs
44ff0e81c10a5e0de239035bc98ef24e63a1ea9b 1d141e97b61ae26954ed7c1aadf6db8b2bc52087 Admin <3353074868@qq.com> 1759367729 +0800	commit: add test for TUI
1d141e97b61ae26954ed7c1aadf6db8b2bc52087 554c618d83d91d875cb0fd73e4804fb9791f9c6b Admin <3353074868@qq.com> 1759367907 +0800	commit: pass test for TUI
554c618d83d91d875cb0fd73e4804fb9791f9c6b 3d2231c40d2fa5ef9dda73f963ad2bcbcc54a070 Admin <3353074868@qq.com> 1759370344 +0800	commit: add plan for cli and main
3d2231c40d2fa5ef9dda73f963ad2bcbcc54a070 41d8d6830fc286c6f208b9222b86bdad250aadf1 Admin <3353074868@qq.com> 1759372117 +0800	commit: resolve walker issue(ignore rule issue)
41d8d6830fc286c6f208b9222b86bdad250aadf1 e05fbe23e25fe8cf5dcfb4737e45492bb9120591 Admin <3353074868@qq.com> 1759381357 +0800	commit: update
e05fbe23e25fe8cf5dcfb4737e45492bb9120591 b8289b92537ec41271e13b7dd78e17452e45ec25 Admin <3353074868@qq.com> 1759395544 +0800	commit: update

```

### .gitignore

- **路径**: `D:\ide\tool\code-context-generator\.gitignore`
- **大小**: 27 字节
- **修改时间**: 2025-10-01T17:27:22+08:00

**[二进制文件 - 内容未显示]**

### AGENTS.md.bak

- **路径**: `D:\ide\tool\code-context-generator\AGENTS.md.bak`
- **大小**: 3238 字节
- **修改时间**: 2025-09-30T20:59:48+08:00

**[二进制文件 - 内容未显示]**

### README.md

- **路径**: `D:\ide\tool\code-context-generator\README.md`
- **大小**: 8806 字节
- **修改时间**: 2025-10-02T17:32:59+08:00

```md
# 代码上下文生成器 (Code Context Generator)

一个智能的代码项目结构文档生成工具，支持CLI交互方式，能够扫描代码项目并生成结构化的文档输出。

## 功能特性

### 🎯 核心功能
- **多格式输出**: 支持 JSON、XML、TOML、Markdown 格式
- **智能文件扫描**: 自动扫描项目文件和目录结构
- **配置管理**: 灵活的配置系统，支持环境变量覆盖
- **二进制文件处理**: 智能检测并处理二进制文件，避免内容错误
### 🚀 高级特性
- **并发处理**: 基于 goroutine 池的高性能文件扫描
- **大文件处理**: 流式读取，支持大文件处理
- **模式匹配**: 支持 glob 模式和正则表达式过滤
- **缓存机制**: 智能缓存提升重复扫描性能
- **跨平台**: 支持 Windows、Linux、macOS

### 🎨 用户界面
- **CLI 模式**: 功能丰富的命令行界面（基于 Cobra）

- **进度显示**: 实时进度条和状态信息
- **主题支持**: 可定制的界面主题

## 安装

### 前置要求
- Go 1.24 或更高版本
- Git（可选，用于版本控制集成）

### 从源码安装
```bash
git clone https://github.com/yourusername/code-context-generator.git
cd code-context-generator
go build -o code-context-generator cmd/cli/main.go
```



## 快速开始

### CLI 使用

#### 基本用法
```bash
# 自动扫描当前目录并生成文档
go run main.go

# 扫描指定目录
go run main.go /path/to/project
```

#### 高级用法
```bash
# 排除特定文件/目录
./code-context-generator generate -e "*.log" -e "node_modules" -e ".git"

# 包含隐藏文件，限制扫描深度
./code-context-generator generate -h -d 3

# 包含文件内容和哈希值
./code-context-generator generate -C -H

# 限制文件大小
./code-context-generator generate -s 1048576  # 1MB

# 排除二进制文件（默认行为）
./code-context-generator generate --exclude-binary

# 包含二进制文件（不推荐）
./code-context-generator generate --exclude-binary=false
```

#### 自动文件扫描
```bash
# 启动交互式文件选择器
./code-context-generator select

# 选择后输出为指定格式
./code-context-generator select -f xml -o selected-files.xml
```

#### 配置管理
```bash
# 初始化配置文件
./code-context-generator config init

# 显示当前配置
./code-context-generator config show
```

#



## 📚 文档

我们提供了完整的文档体系，帮助你快速上手和深入了解本工具：

### 📚 文档

我们提供了完整的文档体系，帮助你快速上手和深入了解本工具：

### 🎯 新用户
- [**快速入门指南**](docs/quickstart.md) - 5分钟快速上手 🚀
- [**使用文档**](docs/usage.md) - 完整的使用指南 📖
- [**配置详解**](docs/usage.md#配置文件详解) - 配置项详细说明 ⚙️
- [**二进制文件处理**](docs/binary-file-handling.md) - 二进制文件检测和处理机制 📁

### 🚀 部署和运维
- [**部署文档**](docs/deployment.md) - 多种部署方式指南 📦
- [**系统服务**](docs/deployment.md#系统服务部署) - 配置为系统服务 🔧
- [**容器化部署**](docs/deployment.md#容器化部署) - Docker/Kubernetes部署 🐳

### 💻 开发贡献
- [**开发环境文档**](docs/development.md) - 开发环境搭建指南 🛠️
- [**开发流程**](docs/development.md#开发流程) - 贡献代码流程 📋
- [**API文档**](docs/development.md#api文档) - 代码API文档 📊

### 📖 文档导航
- [**文档中心**](docs/README.md) - 所有文档的索引和导航 📑
- [**常见问题**](docs/usage.md#常见问题) - 常见问题解答 ❓
- [**故障排除**](docs/usage.md#故障排除) - 问题排查指南 🔍

## 配置

配置文件支持 TOML、YAML、JSON 格式，默认配置文件示例：

```toml
[output]
format = "json"
encoding = "utf-8"
file_path = ""
pretty = true

[file_processing]
include_hidden = false
max_file_size = 10485760  # 10MB
max_depth = 0  # 无限制
exclude_patterns = [
    "*.exe", "*.dll", "*.so", "*.dylib",
    "*.pyc", "*.pyo", "*.pyd",
    "node_modules", ".git", ".svn", ".hg",
    "__pycache__", "*.egg-info", "dist", "build"
]
include_patterns = []
include_content = false
include_hash = false
exclude_binary = true  # 排除二进制文件

[ui]
theme = "default"
show_progress = true
show_size = true
show_date = true
show_preview = true

[performance]
max_workers = 4
buffer_size = 8192
cache_enabled = true
cache_size = 100

[logging]
level = "info"
file_path = ""
max_size = 10
max_backups = 3
max_age = 7

[formats.json]
enabled = true
indent = "  "
sort_keys = true

[formats.xml]
enabled = true
indent = "  "
use_cdata = false

[formats.toml]
enabled = true
indent = "  "

[formats.markdown]
enabled = true
template = "default"
include_toc = true

## 架构设计

### 模块结构
```
code-context-generator/
├── cli/          # CLI应用程序入口

├── internal/
│   ├── config/       # 配置管理
│   ├── filesystem/   # 文件系统操作
│   ├── formatter/    # 格式转换
│   ├── formatter/      # 输出格式化器

│   └── utils/        # 工具函数
├── pkg/
│   ├── types/        # 类型定义
│   └── constants/    # 常量定义
├── configs/          # 配置文件
├── docs/            # 文档
└── tests/           # 测试文件
```

### 核心组件

#### 1. 配置管理器 (Config Manager)
- 支持多格式配置文件（TOML、YAML、JSON）
- 环境变量覆盖
- 配置验证和默认值
- 热重载支持

#### 2. 文件系统遍历器 (File System Walker)
- 并发文件扫描
- 灵活的过滤机制
- 大文件流式处理
- 进度报告

#### 3. 格式化器 (Formatter)
- 多格式输出支持
- 自定义字段映射
- 模板系统
- 代码高亮

#### 4. 文件系统 (Filesystem)
- 自动文件扫描
- 智能文件过滤
- 高效的文件遍历

#### 5. 配置管理 (Config Management)
- 灵活的配置系统
- 环境变量支持
- 配置文件管理

### 技术栈

#### 核心依赖
- **CLI框架**: [Cobra](https://github.com/spf13/cobra) - 现代化的CLI应用框架
- **TUI框架**: [Bubble Tea](https://github.com/charmbracelet/bubbletea) + [Lipgloss](https://github.com/charmbracelet/lipgloss) - 优雅的终端用户界面与样式库

#### 配置和序列化
- **配置解析**: [TOML](https://github.com/BurntSushi/toml), [YAML](https://github.com/goccy/go-yaml)
- **JSON处理**: 标准库 `encoding/json`
- **XML处理**: 标准库 `encoding/xml`

#### 文件处理
- **文件监控**: [fsnotify](https://github.com/fsnotify/fsnotify) - 文件系统事件监控
- **路径处理**: 标准库 `path/filepath`
- **并发控制**: 标准库 `sync`, `context`

#### 日志和错误处理
- **日志库**: [logrus](https://github.com/sirupsen/logrus) - 结构化日志
- **错误处理**: 自定义错误类型和包装

## 性能优化

### 并发处理
- 使用 goroutine 池控制并发数量
- 工作队列模式处理文件扫描
- 上下文取消支持

### 内存管理
- 对象池复用减少GC压力
- 流式处理避免大内存占用
- 智能缓存策略

### I/O优化
- 批量文件操作
- 异步I/O模式
- 预读取和延迟写入

## 错误处理

### 错误类型
- **文件系统错误**: 权限、不存在、磁盘空间
- **配置错误**: 格式、验证、不兼容
- **网络错误**: 远程文件访问
- **内存错误**: 大文件处理

### 错误处理策略
- 优雅降级
- 重试机制
- 详细错误信息
- 恢复建议

## 测试

### 单元测试
```bash
go test ./internal/... -v
```

### 集成测试
```bash
go test ./tests/... -v
```

### 性能测试
```bash
go test -bench=. ./internal/filesystem
```

## 贡献

### 开发环境设置
```bash
git clone https://github.com/yourusername/code-context-generator.git
cd code-context-generator
go mod download
```

### 代码规范
- 遵循 Go 官方代码规范
- 使用 `gofmt` 格式化代码
- 添加充分的注释和文档
- 编写单元测试

### 提交规范
- 使用清晰的提交信息
- 关联相关Issue
- 添加适当的标签

## 路线图

### 近期计划 (v1.1)
- [ ] 远程文件系统支持（FTP、SFTP）
- [ ] 插件系统
- [ ] 主题自定义
- [ ] 多语言支持

### 中期计划 (v1.2)
- [ ] Web界面
- [ ] API服务
- [ ] 数据库集成
- [ ] 云存储支持

### 长期计划 (v2.0)
- [ ] AI智能分析
- [ ] 代码质量检测
- [ ] 依赖关系图
- [ ] 实时同步

## 许可证

MIT License - 详见 [LICENSE](LICENSE) 文件

## 致谢

- [Cobra](https://github.com/spf13/cobra) - CLI框架

- [Lipgloss](https://github.com/charmbracelet/lipgloss) - 样式库
- 所有贡献者和支持者

---

⭐ 如果这个项目对你有帮助，请给我们一个星标！
```

### AGENTS.md

- **路径**: `D:\ide\tool\code-context-generator\AGENTS.md`
- **大小**: 5701 字节
- **修改时间**: 2025-10-02T17:12:35+08:00

```md
# AGENTS.md

该项目需要构建一个简单的cli工具。该项目的目的是使用go语言实现一个高性能能方便地生成代码上下文的工具。

## 环境
windows11
需要兼容powershell和git bash

### 编程语言
go 1.24.5

## 项目目的
本项目的目的是使用go语言实现一个能方便的通过终端选择文件/文件夹，
并将选中的文件的相对路径与内容打包为结构化的文件（如xml/json/md等），快速整合文件内容，跨文件构建上下文，方便用户将多个文件的内容快速转为提示词。

## 项目功能
1. 能方便地通过终端选择文件/文件夹。
2. 能将选中的文件的相对路径与内容打包为单个xml/json/md文件，并输出到指定目录。如果不指定就输出到当前目录。

## 额外要求
1. 支持在cli界面中临时选择使用哪种导出格式
2. 支持CLI命令方式使用。配置项也应当支持在执行cli命令时通过参数的形式指定
**CLI参数支持**：
```bash
# 基本使用
code-context-generator --format xml --output output.xml

# 使用配置文件
code-context-generator --config config.yaml --format json

# 覆盖配置选项
code-context-generator --format markdown --max-depth 3 --exclude "*.log,*.tmp"

# 指定输出目录和文件名模板
code-context-generator --output-dir ./outputs --filename-template "project_{{.timestamp}}.md"

# 显示配置验证信息
code-context-generator --validate-config --config config.yaml
```

3. 必须能够处理中文路径、文件名
4. 必须拥有高性能
5. 必须支持windows、linux的文件系统。生成文件中的路径统一使用正斜杠（/）作为路径分隔符
6. 必须正确忽略选中的文件夹中的隐藏文件（如.git, .vscode, node_modules等），且在遍历路径前读取.gitignore的规则，忽略这些文件与目录
7. 必须支持递归遍历子文件夹，且在遍历子文件夹时必须正确处理符号链接（symbolic link）
8. 是否遍历所有子目录(默认只遍历1层)、符号链接功能需要支持在.env文件中配置。使用默认值均为false。
11. 采用统一配置文件方案，支持YAML、JSON、TOML三种配置文件格式，使用Go标准库进行解析和生成：

**配置文件格式（config.yaml）**：
```yaml
# 统一配置文件 - 支持多种输出格式
formats:
  xml:
    enabled: true
    structure:
      root: "context"
      file: "file"
      folder: "folder"
      files: "files"
    fields:
      path: "path"
      content: "content"
      filename: "filename"

  json:
    enabled: true
    structure:
      file: "file"
      folder: "folder"
      files: "files"
    fields:
      path: "path"
      content: "content"
      filename: "filename"
    formatting:
      indent: "  "
      sort_keys: false

  toml:
    enabled: true
    structure:
      file_section: "file"
      folder_section: "folder"
    fields:
      path: "path"
      content: "content"
      filename: "filename"

  markdown:
    enabled: true
    structure:
      file_header: "##"
      folder_header: "###"
      code_block: "```"
    formatting:
      separator: "\n\n"
      add_toc: false
      code_language: true

# 通用字段配置
fields:
  custom_names:
    filepath: "path"
    filecontent: "content"
    filename: "name"
  
  filter:
    include: []  # 只包含这些字段，空数组表示包含所有
    exclude: []  # 排除这些字段
  
  processing:
    max_length: 0  # 0表示不限制
    add_line_numbers: false
    trim_whitespace: true
    code_highlight: false

# 文件过滤配置
filters:
  max_file_size: "10MB"
  exclude_patterns:
    - "*.tmp"
    - "*.log"
    - "*.swp"
    - ".*"  # 隐藏文件
  include_patterns: []
  max_depth: 0  # 0表示无限制
  follow_symlinks: false

# 输出配置
output:
  default_format: "xml"
  output_dir: ""  # 空表示当前目录
  filename_template: "context_{{.timestamp}}.{{.extension}}"
  timestamp_format: "20060102_150405"


```

**配置说明**：
- 支持YAML、JSON、TOML三种配置文件格式，使用Go标准库进行解析
- 统一配置结构，支持多种输出格式的灵活配置
- 字段名称可自定义，支持字段过滤和内容预处理
- 配置文件可通过命令行参数指定，支持运行时切换格式
- 保持与原有rule.xml/rule.json的兼容性，支持平滑迁移

**Go标准库对齐**：
- YAML格式：使用`github.com/goccy/go-yaml`（兼容encoding/json接口）
- JSON格式：使用标准库`encoding/json`
- TOML格式：使用`github.com/BurntSushi/toml`（兼容encoding/json接口）
- XML格式：使用标准库`encoding/xml`

支持在.env中选择默认导出格式，也支持CLI参数临时指定格式

12. 支持在cli界面中临时选择使用哪种导出格式

**配置管理**：
- 提供统一的配置管理器（config_manager.go），支持配置文件的加载、解析和格式转换
- 支持配置验证和默认值处理
- 提供配置热重载功能（可选）
- 支持环境变量覆盖配置文件中的设置

**配置方案**：
- 统一使用新的YAML/JSON/TOML配置文件格式
- 不再支持原有的rule.xml/rule.json格式
- 提供一次性迁移工具，帮助用户从旧格式迁移到新格式

## 实现准则

1. 使用Go语言开发，利用其跨平台特性和丰富的标准库
2. 采用模块化设计，将文件处理、格式转换、配置管理等功能分离
3. 考虑使用并发处理来提高性能
4. 实现完善的错误处理和日志记录机制


```

### DESIGN.md

- **路径**: `D:\ide\tool\code-context-generator\DESIGN.md`
- **大小**: 8789 字节
- **修改时间**: 2025-10-02T17:19:17+08:00

```md
# 代码上下文生成器 - 详细设计文档

## 项目概述

代码上下文生成器是一个高性能的CLI工具，用于通过终端选择文件/文件夹，并将选中的内容打包为结构化的XML/JSON/TOML/Markdown文件，方便用户快速构建代码上下文和提示词。

## 架构设计

### 总体架构

```
code-context-generator/
├── cmd/                    # 命令入口
│   ├── cli/               # CLI命令实现

├── internal/              # 内部核心模块
│   ├── config/           # 配置管理
│   ├── filesystem/       # 文件系统操作
│   ├── formatter/        # 格式转换
│   ├── selector/         # 文件选择器

│   └── utils/            # 工具函数
├── pkg/                   # 可复用包
│   ├── types/            # 公共类型定义
│   └── constants/        # 常量定义
├── configs/               # 配置模板
├── docs/                  # 文档
└── tests/                 # 测试文件
```

### 核心模块设计

#### 1. 配置管理模块 (internal/config/)

**职责：**
- 多格式配置文件解析（YAML/JSON/TOML）
- 环境变量覆盖
- 配置验证和默认值处理
- 配置热重载

**接口定义：**
```go
type ConfigManager interface {
    Load(configPath string) error
    Get() *Config
    Validate() error
    Reload() error
    Save(configPath string, format string) error
    GetEnvOverrides() map[string]string
}
```

**现有组件重构：**
- 将现有`config_manager.go`重构为模块化设计
- 保持向后兼容性
- 增强错误处理和验证

#### 2. 文件系统模块 (internal/filesystem/)

**职责：**
- 安全的递归目录遍历
- .gitignore规则解析和应用
- 文件过滤和大小检查
- 符号链接处理
- 中文路径支持
- 并发文件读取

**接口定义：**
```go
type FileSystem interface {
    Walk(root string, options WalkOptions) (<-chan FileInfo, error)
    ReadFile(path string) (string, error)
    GetFileInfo(path string) (FileInfo, error)
    ParseGitignore(path string) ([]string, error)
    IsHidden(path string) bool
    IsSymlink(path string) bool
}

type WalkOptions struct {
    MaxDepth        int
    FollowSymlinks  bool
    ExcludePatterns []string
    IncludePatterns []string
    MaxFileSize     int64
}
```

**关键特性：**
- 使用goroutine池进行并发遍历
- 流式处理避免内存溢出
- 完善的错误处理机制
- 跨平台路径处理

#### 3. 格式转换模块 (internal/formatter/)

**职责：**
- XML/JSON/TOML/Markdown格式生成
- 模板引擎支持
- 并发格式转换
- 内存优化

**接口定义：**
```go
type Formatter interface {
    Format(data ContextData, format string) (string, error)
    GetSupportedFormats() []string
    ValidateFormat(format string) error
    SetTemplate(format string, template string) error
}

type ContextData struct {
    Files   []FileInfo
    Folders []FolderInfo
    Metadata map[string]interface{}
}
```

**格式支持：**
- XML: 结构化层次，支持自定义标签
- JSON: 标准JSON格式，支持缩进和排序
- TOML: 易读配置格式
- Markdown: 带代码高亮的文档格式

#### 4. 文件选择器模块 (internal/selector/)

**职责：**
- 交互式文件选择
- 多选支持
- 键盘导航
- 实时搜索过滤

**特性：**
- 支持方向键导航
- 空格键选择/取消选择
- 回车键进入目录
- 退格键返回上级目录
- /键进入搜索模式



#### 6. CLI模块 (cmd/cli/)

**命令结构：**
```bash
code-context-generator [command] [flags]

Commands:
  generate    生成代码上下文文件
  config      管理配置文件
  validate    验证配置文件
  version     显示版本信息

Flags:
  --format string        输出格式 (xml|json|toml|markdown)
  --output string        输出文件路径
  --config string        配置文件路径
  --exclude strings      排除模式
  --include strings      包含模式
  --max-depth int        最大遍历深度
  --follow-symlinks      跟随符号链接
  --output-dir string    输出目录
  --filename-template    文件名模板
```


│ │ > src/           │ │ │ 格式: XML                        │ │
│ │   main.go        │ │ │ 输出目录: ./output              │ │
│ │   utils.go       │ │ │ 排除: *.tmp, *.log             │ │
│ │   config/        │ │ │ 最大深度: 3                     │ │
│ │   tests/         │ │ │ 符号链接: 否                    │ │
│ │                  │ │ │                                 │ │
│ │ 空格:选择 回车:进入 │ │ │                                 │ │
│ │ /:搜索 q:退出    │ │ │                                 │ │
│ └──────────────────┘ │ └─────────────────────────────────┘ │
├──────────────────────┴────────────────────────────────────┤
│ 已选择: 3个文件, 1个目录  状态: 就绪                    │
└─────────────────────────────────────────────────────────────┘
```

## 技术选型

### 核心依赖
- **TUI框架:** bubbletea + lipgloss
- **CLI框架:** cobra
- **配置解析:** 
  - YAML: github.com/goccy/go-yaml
  - JSON: encoding/json
  - TOML: github.com/BurntSushi/toml
- **文件监控:** fsnotify (用于热重载)
- **日志:** logrus

### 开发工具
- **构建:** go build
- **测试:** go test + testify
- **代码质量:** golangci-lint
- **文档:** godoc

## 性能优化策略

### 1. 并发处理
```go
type WorkerPool struct {
    workers    int
    jobQueue   chan Job
    resultQueue chan Result
    wg         sync.WaitGroup
}
```

### 2. 内存优化
- 对象池复用
- 流式文件读取
- 及时内存清理
- 大文件分块处理

### 3. 缓存机制
- 文件信息缓存
- 配置缓存
- 模板编译缓存

## 错误处理设计

### 错误分类
```go
type ErrorType int

const (
    ErrConfig ErrorType = iota
    ErrFileSystem
    ErrFormat
    ErrValidation
    ErrPermission
)

type AppError struct {
    Type    ErrorType
    Message string
    Cause   error
    Context map[string]interface{}
}
```

### 错误处理策略
- 用户友好的错误消息
- 详细的错误上下文
- 恢复机制
- 日志记录

## 测试策略

### 单元测试
- 每个模块独立测试
- 边界条件测试
- 错误场景测试
- 性能基准测试

### 集成测试
- 端到端功能测试
- 跨平台兼容性测试
- 大文件处理测试
- 并发安全性测试

### 测试覆盖率目标
- 核心模块: >90%
- 业务逻辑: >80%
- 整体: >75%

## 部署和发布

### 构建配置
```makefile
# Makefile
BINARY_NAME=code-context-generator
VERSION=$(shell git describe --tags --always)
BUILD_TIME=$(shell date -u '+%Y-%m-%d_%H:%M:%S')

build:
    go build -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME)" -o $(BINARY_NAME) main.go

build-all:
    GOOS=windows GOARCH=amd64 go build -o $(BINARY_NAME)-windows-amd64.exe
    GOOS=linux GOARCH=amd64 go build -o $(BINARY_NAME)-linux-amd64
    GOOS=darwin GOARCH=amd64 go build -o $(BINARY_NAME)-darwin-amd64
```

### 发布策略
- GitHub Releases
- 多平台二进制文件
- 安装脚本
- Docker镜像（可选）

## 监控和运维

### 指标收集
- 处理文件数量
- 处理时间
- 内存使用
- 错误率

### 日志设计
```go
type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    Fatal(msg string, fields ...Field)
}
```

## 安全考虑

### 输入验证
- 路径遍历防护
- 文件大小限制
- 符号链接验证
- 编码安全检查

### 权限管理
- 文件读取权限检查
- 输出目录权限验证
- 安全配置验证

## 扩展性设计

### 插件架构（未来）
```go
type Plugin interface {
    Name() string
    Version() string
    Init(config map[string]interface{}) error
    Process(data ContextData) (ContextData, error)
}
```

### 新格式支持
- 格式化器接口设计
- 模板系统扩展
- 配置架构兼容

## 兼容性保证

### 向后兼容
- 配置文件格式兼容
- API接口稳定
- 命令行参数兼容

### 平台兼容
- Windows 10+/Linux/macOS
- PowerShell/Bash/Zsh
- UTF-8编码支持

这个设计文档为项目提供了全面的架构指导，确保项目的高性能、可维护性和扩展性。
```

### EXECUTION_PLAN.md

- **路径**: `D:\ide\tool\code-context-generator\EXECUTION_PLAN.md`
- **大小**: 9026 字节
- **修改时间**: 2025-10-02T17:18:48+08:00

```md
# 代码上下文生成器 - 执行计划

## 项目总览

**项目周期:** 15个工作日  
**团队规模:** 1人  
**技术栈:** Go 1.24, Bubbletea, Cobra  
**目标:** 高性能CLI工具，支持多种输出格式  

## 执行阶段总览

| 阶段 | 时间 | 主要任务 | 交付物 |
|------|------|----------|---------|
| 第1阶段 | 3天 | 基础设施和核心模块 | 模块化代码框架，配置文件管理 |
| 第2阶段 | 2天 | CLI命令行功能 | 完整CLI命令支持 |

| 第4阶段 | 3天 | 高级功能和优化 | 性能优化，错误处理 |
| 第5阶段 | 2天 | 测试和文档 | 完整测试覆盖，用户文档 |
| 第6阶段 | 1天 | 发布准备 | 构建脚本，发布包 |

## 详细执行计划

### 第1阶段：基础设施和核心模块 (第1-3天)

#### 第1天：项目结构重构
**上午 (4小时)**
- [ ] 创建模块化目录结构
- [ ] 重构config_manager.go到internal/config包
- [ ] 添加必要的依赖包到go.mod
- [ ] 定义核心接口

**下午 (4小时)**
- [ ] 实现配置管理模块的基础功能
- [ ] 添加配置验证逻辑
- [ ] 实现环境变量覆盖功能
- [ ] 编写配置模块单元测试

**交付物:**
- 模块化项目结构
- 重构后的配置管理器
- 配置验证功能
- 单元测试覆盖率>90%

#### 第2天：文件系统模块
**上午 (4小时)**
- [ ] 设计文件系统接口
- [ ] 实现安全的文件遍历算法
- [ ] 添加符号链接处理
- [ ] 实现.gitignore解析器

**下午 (4小时)**
- [ ] 实现文件过滤功能
- [ ] 添加中文路径支持
- [ ] 实现并发文件读取
- [ ] 编写文件系统模块测试

**交付物:**
- 文件系统遍历功能
- .gitignore支持
- 并发文件读取
- 中文路径处理

#### 第3天：格式转换模块
**上午 (4小时)**
- [ ] 重构现有格式生成逻辑
- [ ] 实现XML格式生成器
- [ ] 实现JSON格式生成器
- [ ] 添加模板引擎支持

**下午 (4小时)**
- [ ] 实现TOML格式生成器
- [ ] 实现Markdown格式生成器
- [ ] 添加并发转换支持
- [ ] 优化内存使用

**交付物:**
- 四种格式生成器
- 模板引擎集成
- 并发转换功能
- 内存优化

---

### 第2阶段：CLI命令行功能 (第4-5天)

#### 第4天：CLI框架和命令解析
**上午 (4小时)**
- [ ] 集成cobra CLI框架
- [ ] 设计命令结构
- [ ] 实现generate命令
- [ ] 添加参数验证

**下午 (4小时)**
- [ ] 实现config命令
- [ ] 实现validate命令
- [ ] 添加version命令
- [ ] 实现帮助文档生成

**交付物:**
- 完整CLI命令结构
- 参数解析和验证
- 帮助文档系统

#### 第5天：CLI业务逻辑集成
**上午 (4小时)**
- [ ] 集成文件选择逻辑
- [ ] 集成格式转换功能
- [ ] 实现输出文件管理
- [ ] 添加进度显示

**下午 (4小时)**
- [ ] 完善错误处理
- [ ] 添加用户反馈机制
- [ ] 实现配置文件加载
- [ ] 编写CLI集成测试

**交付物:**
- 功能完整的CLI
- 错误处理机制
- 集成测试

---

### 第3阶段：TUI界面实现 (第6-9天)

#### 第6天：TUI基础框架
**上午 (4小时)**
- [ ] 研究Bubble Tea框架
- [ ] 设计TUI架构
- [ ] 实现基础模型结构
- [ ] 创建消息系统

**下午 (4小时)**
- [ ] 实现状态管理
- [ ] 添加键盘快捷键
- [ ] 设计主界面布局
- [ ] 实现基础导航功能

**交付物:**
- TUI基础框架
- 主界面布局
- 事件处理系统

#### 第7天：文件选择器TUI
**上午 (4小时)**
- [ ] 实现文件树展示
- [ ] 添加键盘导航
- [ ] 实现多选功能
- [ ] 添加文件图标显示

**下午 (4小时)**
- [ ] 实现搜索模式
- [ ] 添加实时过滤
- [ ] 实现选择状态管理
- [ ] 优化列表滚动性能

**交付物:**
- 文件选择器组件
- 多选和搜索功能
- 性能优化

#### 第8天：配置编辑器和进度显示
**上午 (4小时)**
- [ ] 实现配置编辑界面
- [ ] 添加实时预览
- [ ] 实现进度条组件
- [ ] 添加状态显示

**下午 (4小时)**
- [ ] 添加配置验证显示
- [ ] 实现配置实时更新
- [ ] 添加配置保存功能
- [ ] 优化界面响应性

**交付物:**
- 配置预览面板
- 配置编辑功能
- 实时更新机制

#### 第9天：TUI集成和完善
**上午 (4小时)**
- [ ] 集成所有TUI组件
- [ ] 实现界面状态同步
- [ ] 添加主题支持
- [ ] 实现帮助界面

**下午 (4小时)**
- [ ] 优化用户交互体验
- [ ] 添加错误提示显示
- [ ] 实现状态保持


**交付物:**



---

### 第4阶段：高级功能和优化 (第10-12天)

#### 第10天：性能优化
**上午 (4小时)**
- [ ] 实现并发文件处理池
- [ ] 优化内存分配策略
- [ ] 添加对象池复用
- [ ] 实现大文件分块读取

**下午 (4小时)**
- [ ] 添加处理进度显示
- [ ] 实现取消操作支持
- [ ] 优化CPU使用
- [ ] 性能基准测试

**交付物:**
- 性能优化版本
- 并发处理池
- 性能测试报告

#### 第11天：错误处理和恢复
**上午 (4小时)**
- [ ] 完善错误分类系统
- [ ] 实现用户友好错误提示
- [ ] 添加错误恢复机制
- [ ] 实现详细错误日志

**下午 (4小时)**
- [ ] 添加配置备份功能
- [ ] 实现状态恢复
- [ ] 添加诊断信息收集
- [ ] 错误处理测试

**交付物:**
- 完善的错误处理
- 恢复机制
- 诊断工具

#### 第12天：跨平台兼容性
**上午 (4小时)**
- [ ] Windows路径处理优化
- [ ] Linux兼容性测试
- [ ] macOS支持验证
- [ ] 终端兼容性测试

**下午 (4小时)**
- [ ] 编码问题处理
- [ ] 权限管理优化
- [ ] 添加平台特定功能
- [ ] 跨平台构建测试

**交付物:**
- 跨平台兼容版本
- 平台特定优化
- 构建脚本

---

### 第5阶段：测试和文档 (第13-14天)

#### 第13天：全面测试
**上午 (4小时)**
- [ ] 核心模块单元测试
- [ ] 集成测试用例
- [ ] 边界条件测试
- [ ] 错误场景测试

**下午 (4小时)**
- [ ] 性能测试和压力测试
- [ ] 并发安全性测试
- [ ] 内存泄漏检测
- [ ] 测试覆盖率报告

**交付物:**
- 完整测试套件
- 测试覆盖率>80%
- 性能测试报告

#### 第14天：文档编写
**上午 (4小时)**
- [ ] API文档生成
- [ ] 用户手册编写
- [ ] 配置示例整理
- [ ] 快速开始指南

**下午 (4小时)**
- [ ] 故障排除指南
- [ ] 性能调优指南
- [ ] 开发者文档
- [ ] 更新README.md

**交付物:**
- 完整用户文档
- API文档
- 开发者指南

---

### 第6阶段：发布准备 (第15天)

#### 第15天：构建和发布
**上午 (4小时)**
- [ ] 创建Makefile构建脚本
- [ ] 实现多平台构建
- [ ] 创建安装脚本
- [ ] 版本管理和标签

**下午 (4小时)**
- [ ] GitHub Releases配置
- [ ] Docker镜像构建（可选）
- [ ] 发布包验证
- [ ] 最终测试和验收

**交付物:**
- 多平台构建版本
- 安装脚本
- GitHub发布包
- 项目验收

## 风险管理

### 技术风险

| 风险 | 概率 | 影响 | 缓解策略 |
|------|------|------|----------|

| 并发性能问题 | 低 | 高 | 使用成熟的并发模式，充分测试 |
| 跨平台兼容性 | 中 | 中 | 分阶段测试，早期发现问题 |
| 大文件处理内存问题 | 中 | 中 | 实现流式处理，内存监控 |

### 时间风险

| 风险 | 概率 | 影响 | 缓解策略 |
|------|------|------|----------|
| 需求变更 | 低 | 高 | 明确需求边界，阶段性验收 |
| 第三方库问题 | 低 | 中 | 选择成熟稳定的库，准备替代方案 |
| 测试时间不足 | 中 | 中 | 并行开发测试，优先级管理 |

## 质量控制

### 代码质量标准
- 遵循Go编码规范
- 代码审查清单
- 静态代码分析
- 安全漏洞扫描

### 测试策略
- 单元测试覆盖率>90%（核心模块）
- 集成测试覆盖率>80%
- 性能基准测试
- 并发安全性测试

### 文档标准
- 所有公共函数必须有文档
- 复杂算法需要详细注释
- 用户文档必须完整
- API文档自动生成

## 交付标准

### 功能完整性
- [ ] CLI命令完整实现

- [ ] 四种输出格式支持
- [ ] 配置文件管理
- [ ] 跨平台兼容性

### 性能要求
- [ ] 单文件处理<100ms（小文件）
- [ ] 内存使用<100MB（1000个文件）
- [ ] 并发处理支持>10个goroutine
- [ ] 大文件支持>100MB

### 质量要求
- [ ] 测试覆盖率>80%
- [ ] 无严重安全漏洞
- [ ] 用户文档完整
- [ ] 代码质量评分>A

### 用户体验
- [ ] 响应时间<200ms
- [ ] 错误提示友好
- [ ] 中文路径支持
- [ ] 帮助文档完整

## 后续规划

### 短期优化（1个月内）
- 性能监控和调优
- 用户反馈收集和处理
- Bug修复和小功能改进

### 中期扩展（3个月内）
- 插件架构支持
- 更多输出格式
- 云端同步功能
- 团队协作功能

### 长期发展（6个月内）
- GUI界面开发
- IDE插件开发
- AI集成和智能建议
- 企业级功能

这个执行计划提供了详细的时间安排、任务分解、风险管理和质量控制，确保项目按时高质量交付。
```

### config.yaml

- **路径**: `D:\ide\tool\code-context-generator\cli\config.yaml`
- **大小**: 2520 字节
- **修改时间**: 2025-10-02T17:24:29+08:00

```yaml
formats:
  xml:
    enabled: true
    root_tag: context
    file_tag: file
    folder_tag: folder
    files_tag: files
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting:
      indent: "  "
      declaration: true
      encoding: UTF-8
  json:
    enabled: true
    structure:
      file: file
      folder: folder
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  toml:
    enabled: true
    structure:
      file_section: file
      folder_section: folder
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  markdown:
    enabled: true
    structure:
      code_block: "```"
      file_header: "##"
      folder_header: "###"
    fields: {}
    template: ""
    formatting:
      add_toc: false
      code_language: true
      separator: |+
        

fields:
  custom_names:
    filecontent: content
    filename: name
    filepath: path
  filter:
    include: []
    exclude: []
  processing:
    max_length: 0
    add_line_numbers: false
    trim_whitespace: true
    code_highlight: false
filters:
  max_file_size: 10MB
  exclude_patterns:
  - "*.tmp"
  - "*.log"
  - "*.swp"
  - ".*"
  - .git
  - node_modules
  - "*.exe"
  - "*.dll"
  - "*.so"
  - "*.dylib"
  - "*.class"
  - "*.pyc"
  - __pycache__
  - .DS_Store
  - Thumbs.db
  - target/
  - dist/
  - build/
  - .env
  - .vscode/
  - .idea/
  - .venv
  include_patterns: []
  max_depth: 0
  follow_symlinks: false
  exclude_binary: true
output:
  format: markdown
  file_path: ""
  encoding: utf-8
  default_format: xml
  output_dir: ""
  filename_template: context_{{.timestamp}}.{{.extension}}
  timestamp_format: "20060102_150405"
  include_metadata: true
  include_statistics: true
  template_path: ""
ui:
  theme: ""
  show_progress: false
  show_size: false
  show_date: false
  show_preview: false
  selector:
    show_hidden: false
    show_size: true
    show_modified: false
  autocomplete:
    enabled: true
    min_chars: 1
    max_suggestions: 10
file_processing:
  includehidden: false
  maxfilesize: "1MB"
  maxdepth: 0
  excludepatterns: []
  includepatterns: []
  includecontent: true
  includehash: false
  binary_detection: true
  encoding_detection: true
performance:
  maxworkers: 0
  buffersize: 4096
  cacheenabled: false
  cachesize: 1000
logging:
  level: info
  filepath: ""
  maxsize: 0
  maxbackups: 0
  maxage: 0
  format: text
  output: stdout

```

### select-output.json

- **路径**: `D:\ide\tool\code-context-generator\cli\select-output.json`
- **大小**: 1120 字节
- **修改时间**: 2025-10-01T21:27:06+08:00

```json
{
  "files": [
    {
      "name": "code-context-generator-cli.exe",
      "path": "code-context-generator-cli.exe",
      "content": "",
      "size": 8822784,
      "mod_time": "2025-10-01T21:26:31.4345668+08:00",
      "is_dir": false,
      "is_hidden": false,
      "is_binary": true
    },
    {
      "name": "config.yaml",
      "path": "config.yaml",
      "content": "",
      "size": 2268,
      "mod_time": "2025-10-01T21:26:51.5210375+08:00",
      "is_dir": false,
      "is_hidden": false,
      "is_binary": false
    },
    {
      "name": "main.go",
      "path": "main.go",
      "content": "",
      "size": 15887,
      "mod_time": "2025-10-01T21:25:36.500602+08:00",
      "is_dir": false,
      "is_hidden": false,
      "is_binary": false
    },
    {
      "name": "test-output.json",
      "path": "test-output.json",
      "content": "",
      "size": 21178,
      "mod_time": "2025-10-01T21:26:51.5220982+08:00",
      "is_dir": false,
      "is_hidden": false,
      "is_binary": false
    }
  ],
  "folders": [],
  "file_count": 4,
  "folder_count": 0,
  "total_size": 0,
  "metadata": {}
}
```

### main.go

- **路径**: `D:\ide\tool\code-context-generator\cli\main.go`
- **大小**: 11019 字节
- **修改时间**: 2025-10-02T17:37:39+08:00

```go
// Package main CLI应用程序主入口
package main

import (
	"fmt"
	"os"
	"strings"

	"code-context-generator/internal/config"
	"code-context-generator/internal/env"
	"code-context-generator/internal/filesystem"
	"code-context-generator/internal/formatter"
	"code-context-generator/internal/utils"
	"code-context-generator/pkg/types"

	"github.com/spf13/cobra"
)

var (
	// 全局变量
	cfg        *types.Config
	configPath string
	verbose    bool
	version    = "1.0.0"
)

// rootCmd 根命令
var rootCmd = &cobra.Command{
	Use:   "code-context-generator",
	Short: "代码上下文生成器",
	Long: `代码上下文生成器 - 智能生成代码项目结构文档

支持多种输出格式（JSON、XML、TOML、Markdown），提供自动文件扫描，
自动补全功能，以及丰富的配置选项。`,
	Version: version,
	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
		// 首先加载.env文件（如果存在）
		if err := env.LoadEnv(""); err != nil {
			fmt.Printf("警告: 加载.env文件失败: %v\n", err)
		}

		// 加载配置
		configManager := config.NewManager()

		// 如果有指定配置文件路径，使用它
		if configPath != "" {
			if err := configManager.Load(configPath); err != nil {
				return fmt.Errorf("加载配置文件失败: %w", err)
			}
		} else {
			// 尝试加载默认配置文件，如果不存在则使用默认配置，不再自动创建
			defaultConfigPath := "config.yaml"
			configManager.Load(defaultConfigPath) // 忽略错误，使用默认配置
		}

		cfg = configManager.Get()
		return nil
	},
}

// generateCmd 生成命令
var generateCmd = &cobra.Command{
	Use:   "generate [路径]",
	Short: "生成代码上下文",
	Long:  "扫描指定路径并生成代码项目结构文档",
	Args:  cobra.MaximumNArgs(1),
	RunE:  runGenerate,
}

// configCmd 配置命令
var configCmd = &cobra.Command{
	Use:   "config",
	Short: "配置管理",
	Long:  "管理应用程序配置",
}

// configShowCmd 显示配置
var configShowCmd = &cobra.Command{
	Use:   "show",
	Short: "显示当前配置",
	Long:  "显示当前配置设置",
	RunE:  runConfigShow,
}

// configInitCmd 初始化配置 (已移除 - 不再自动创建配置文件)
// var configInitCmd = &cobra.Command{
// 	Use:   "init",
// 	Short: "初始化配置文件",
// 	Long:  "创建默认配置文件",
// 	RunE:  runConfigInit,
// }

// init 初始化函数
func init() {
	// 添加子命令
	rootCmd.AddCommand(generateCmd)
	rootCmd.AddCommand(configCmd)

	// 配置命令子命令
	configCmd.AddCommand(configShowCmd)
	// configCmd.AddCommand(configInitCmd) // 已移除 - 不再提供配置文件初始化功能

	// 全局标志
	rootCmd.PersistentFlags().StringVarP(&configPath, "config", "c", "", "配置文件路径")
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "详细输出")

	// generate命令标志
	generateCmd.Flags().StringP("output", "o", "", "输出文件路径")
	generateCmd.Flags().StringP("format", "f", "json", "输出格式 (json, xml, toml, markdown)")
	generateCmd.Flags().StringSliceP("exclude", "e", []string{}, "排除的文件/目录模式")
	generateCmd.Flags().StringSliceP("include", "i", []string{}, "包含的文件/目录模式")
	generateCmd.Flags().BoolP("recursive", "r", true, "递归扫描")
	generateCmd.Flags().Bool("hidden", false, "包含隐藏文件")
	generateCmd.Flags().IntP("max-depth", "d", 0, "最大扫描深度 (0表示无限制)")
	generateCmd.Flags().IntP("max-size", "s", 0, "最大文件大小 (字节, 0表示无限制)")
	generateCmd.Flags().BoolP("content", "C", true, "包含文件内容")
	generateCmd.Flags().BoolP("hash", "H", false, "包含文件哈希")
	generateCmd.Flags().Bool("exclude-binary", true, "排除二进制文件")
}

// main 主函数
func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, utils.ErrorColor("错误:"), err)
		os.Exit(1)
	}
}

// runGenerate 运行生成命令
func runGenerate(cmd *cobra.Command, args []string) error {
	// 获取路径
	path := "."
	if len(args) > 0 {
		path = args[0]
	}

	// 解析标志
	output, _ := cmd.Flags().GetString("output")
	format, _ := cmd.Flags().GetString("format")
	exclude, _ := cmd.Flags().GetStringSlice("exclude")
	include, _ := cmd.Flags().GetStringSlice("include")
	recursive, _ := cmd.Flags().GetBool("recursive")
	hidden, _ := cmd.Flags().GetBool("hidden")
	maxDepth, _ := cmd.Flags().GetInt("max-depth")
	maxSize, _ := cmd.Flags().GetInt("max-size")
	content, _ := cmd.Flags().GetBool("content")
	hash, _ := cmd.Flags().GetBool("hash")
	excludeBinary, _ := cmd.Flags().GetBool("exclude-binary")

	// 合并配置文件设置（命令行参数优先）
	if len(exclude) == 0 && len(cfg.Filters.ExcludePatterns) > 0 {
		exclude = cfg.Filters.ExcludePatterns
	}
	if len(include) == 0 && len(cfg.Filters.IncludePatterns) > 0 {
		include = cfg.Filters.IncludePatterns
	}
	if maxDepth == 0 && cfg.Filters.MaxDepth > 0 {
		maxDepth = cfg.Filters.MaxDepth
	}
	if maxSize == 0 && cfg.Filters.MaxFileSize != "" {
		// 解析配置文件中的文件大小字符串
		parsedSize := env.ParseFileSize(cfg.Filters.MaxFileSize)
		if parsedSize > 0 {
			maxSize = int(parsedSize)
		}
	}
	if !hidden && cfg.FileProcessing.IncludeHidden {
		hidden = cfg.FileProcessing.IncludeHidden
	}
	if !excludeBinary && cfg.Filters.ExcludeBinary {
		excludeBinary = cfg.Filters.ExcludeBinary
	}

	// 验证格式
	if !isValidFormat(format) {
		return fmt.Errorf("无效的输出格式: %s", format)
	}

	// 创建文件系统遍历器
	walker := filesystem.NewFileSystemWalker(types.WalkOptions{})

	// 如果递归选项被禁用，设置最大深度为1
	if !recursive && maxDepth == 0 {
		maxDepth = 1
	}

	// 执行遍历
	if verbose {
		fmt.Printf("正在扫描路径: %s (递归: %v)\n", path, recursive)
		fmt.Printf("排除模式: %v\n", exclude)
		fmt.Printf("最大深度: %d, 最大文件大小: %d\n", maxDepth, maxSize)
	}

	// 创建遍历选项
	walkOptions := &types.WalkOptions{
		MaxDepth:        maxDepth,
		MaxFileSize:     int64(maxSize),
		ExcludePatterns: exclude,
		IncludePatterns: include,
		FollowSymlinks:  false,
		ShowHidden:      hidden,
		ExcludeBinary:   excludeBinary,
	}

	result, err := walker.Walk(path, walkOptions)
	if err != nil {
		return fmt.Errorf("扫描失败: %w", err)
	}

	if verbose {
		fmt.Printf("扫描完成: %d 个文件, %d 个目录\n", result.FileCount, result.FolderCount)
	}

	// 创建格式化器
	formatter, err := formatter.NewFormatter(format, cfg)
	if err != nil {
		return fmt.Errorf("创建格式化器失败: %w", err)
	}

	// ContextData 已经包含了所有需要的信息
	// 初始化metadata map并添加根路径
	if result.Metadata == nil {
		result.Metadata = make(map[string]interface{})
	}
	result.Metadata["root_path"] = path
	contextData := *result

	// 格式化输出
	outputData, err := formatter.Format(contextData)
	if err != nil {
		return fmt.Errorf("格式化输出失败: %w", err)
	}

	// 添加额外信息
	if content || hash {
		// 创建 WalkResult 用于 addFileContent
		walkResult := &types.WalkResult{
			Files:       result.Files,
			Folders:     result.Folders,
			FileCount:   result.FileCount,
			FolderCount: result.FolderCount,
			TotalSize:   result.TotalSize,
			RootPath:    path,
		}
		outputData = addFileContent(outputData, walkResult, content, hash)
	}

	// 输出结果
	if output != "" {
		// 标准化换行符为当前操作系统格式
		normalizedData := utils.NormalizeLineEndings(outputData)
		if err := os.WriteFile(output, []byte(normalizedData), 0644); err != nil {
			return fmt.Errorf("写入输出文件失败: %w", err)
		}
		if verbose {
			fmt.Println(utils.SuccessColor("输出已写入:"), output)
		}
	} else {
		// 控制台输出也标准化换行符
		fmt.Println(utils.NormalizeLineEndings(outputData))
	}

	return nil
}

// runConfigShow 运行配置显示命令
func runConfigShow(cmd *cobra.Command, args []string) error {
	// 生成配置输出
	configOutput := generateConfigOutput(cfg)
	fmt.Println(configOutput)
	return nil
}

// runConfigInit 运行配置初始化命令 (已移除 - 不再自动创建配置文件)
// func runConfigInit(cmd *cobra.Command, args []string) error {
// 	// 初始化配置
// 	configManager := config.NewManager()
// 	cfg = configManager.Get()

// 	// 保存配置到文件
// 	if err := configManager.Save("config.yaml", "yaml"); err != nil {
// 		return fmt.Errorf("保存配置文件失败: %w", err)
// 	}

// 	fmt.Println(utils.SuccessColor("配置文件已创建: config.yaml"))
// 	return nil
// }

// isValidFormat 检查格式是否有效
func isValidFormat(format string) bool {
	validFormats := []string{"json", "xml", "toml", "markdown", "md"}
	for _, valid := range validFormats {
		if format == valid {
			return true
		}
	}
	return false
}

// addFileContent 添加文件内容
func addFileContent(outputData string, _ *types.WalkResult, includeContent, includeHash bool) string {
	// 如果不需要包含内容和哈希，直接返回原始数据
	if !includeContent && !includeHash {
		return outputData
	}

	// 这里可以根据需要添加文件内容和哈希处理逻辑
	// 目前保持简化实现，后续可以根据具体需求扩展
	if verbose {
		fmt.Println(utils.InfoColor("注意: 文件内容和哈希功能暂未完全实现"))
	}

	return outputData
}

// generateConfigOutput 生成配置输出
func generateConfigOutput(cfg *types.Config) string {
	var output strings.Builder

	output.WriteString("当前配置:\n")
	output.WriteString("==================\n\n")

	output.WriteString(fmt.Sprintf("默认格式: %s\n", cfg.Output.DefaultFormat))
	output.WriteString(fmt.Sprintf("输出目录: %s\n", cfg.Output.OutputDir))
	output.WriteString(fmt.Sprintf("文件名模板: %s\n", cfg.Output.FilenameTemplate))

	output.WriteString("\n文件处理:\n")
	output.WriteString(fmt.Sprintf("  最大文件大小: %s\n", cfg.Filters.MaxFileSize))
	output.WriteString(fmt.Sprintf("  最大深度: %d\n", cfg.Filters.MaxDepth))
	output.WriteString(fmt.Sprintf("  跟随符号链接: %v\n", cfg.Filters.FollowSymlinks))
	output.WriteString(fmt.Sprintf("  排除二进制文件: %v\n", cfg.Filters.ExcludeBinary))

	if len(cfg.Filters.ExcludePatterns) > 0 {
		output.WriteString("  排除模式:\n")
		for _, pattern := range cfg.Filters.ExcludePatterns {
			output.WriteString(fmt.Sprintf("    - %s\n", pattern))
		}
	}

	if len(cfg.Filters.IncludePatterns) > 0 {
		output.WriteString("  包含模式:\n")
		for _, pattern := range cfg.Filters.IncludePatterns {
			output.WriteString(fmt.Sprintf("    - %s\n", pattern))
		}
	}

	return output.String()
}

```

### config_xml_example.yaml

- **路径**: `D:\ide\tool\code-context-generator\config_xml_example.yaml`
- **大小**: 928 字节
- **修改时间**: 2025-10-02T10:49:44+08:00

```yaml
# XML格式配置示例
format: xml
output: context.xml
xml:
  enabled: true
  root_tag: "Context"
  file_tag: "File"
  folder_tag: "Folder"
  files_tag: "Files"
  formatting:
    indent: "  "
    declaration: true
    encoding: "UTF-8"
    content_handling: "cdata"  # 可选值: escaped (默认), cdata, raw
  fields:
    name: "Name"
    path: "Path"
    size: "Size"
    modified: "Modified"
    content: "Content"
    is_binary: "IsBinary"
    language: "Language"

# 文件过滤配置
filters:
  max_file_size: "10MB"
  exclude_patterns:
    - "*.exe"
    - "*.dll"
    - "*.so"
    - "node_modules/*"
    - ".git/*"
    - "*.log"
  include_patterns: []
  max_depth: 10
  follow_symlinks: false
  exclude_binary: true

# 文件处理配置
fields:
  custom_names: {}
  filter:
    include: []
    exclude: []
  processing:
    max_length: 0
    add_line_numbers: false
    trim_whitespace: false
    code_highlight: false
```

### config-json.yaml

- **路径**: `D:\ide\tool\code-context-generator\config-json.yaml`
- **大小**: 736 字节
- **修改时间**: 2025-10-01T21:59:59+08:00

```yaml
formats:
  xml:
    enabled: false
  json:
    enabled: true
    structure:
      file: source_file
      folder: directory
      files: all_files
    fields:
      path: relative_path
      content: file_content
      filename: file_name
  toml:
    enabled: false
  markdown:
    enabled: false

output:
  default_format: json
  output_dir: json_output
  filename_template: "context_{{.timestamp}}.{{.extension}}"

filters:
  max_file_size: "2MB"
  exclude_patterns:
    - "*.tmp"
    - "*.log"
    - "*.swp"
    - ".*"
    - "node_modules/"
    - "target/"
    - "dist/"
    - "build/"
    - ".env"
    - ".git/"
    - ".vscode/"
    - ".idea/"
    - "__pycache__/"
    - "*.pyc"
    - ".venv"
    - "*.class"
  exclude_binary: false
```

### CICD-ref.md

- **路径**: `D:\ide\tool\code-context-generator\docs\CICD-ref.md`
- **大小**: 3829 字节
- **修改时间**: 2025-10-02T17:14:37+08:00

```md

## 持续集成

### 1. GitHub Actions配置

#### .github/workflows/ci.yml
```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [1.24, 1.23]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ matrix.go-version }}
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out ./...
    
    - name: Generate coverage report
      run: go tool cover -html=coverage.out -o coverage.html
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
    
    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
    
    - name: Run gosec security scanner
      uses: securecodewarrior/github-action-gosec@master
      with:
        args: '-no-fail -fmt sarif -out results.sarif ./...'
    
    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: results.sarif

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.24
    
    - name: Build CLI
      run: go build -v -o code-context-generator cmd/cli/main.go
    
    - name: Test build artifacts
      run: |
        ./code-context-generator --help
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: binaries
        path: |
          code-context-generator

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.24
    
    - name: Run GoReleaser
      uses: goreleaser/goreleaser-action@v4
      with:
        version: latest
        args: release --rm-dist
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### 2. 代码质量检查

#### golangci-lint配置
```yaml
# .golangci.yml
run:
  timeout: 5m
  issues-exit-code: 1
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  
  govet:
    check-shadowing: true
    enable-all: true
  
  gocyclo:
    min-complexity: 15
  
  maligned:
    suggest-new: true
  
  dupl:
    threshold: 100
  
  goconst:
    min-len: 3
    min-occurrences: 3

linters:
  enable:
    - bodyclose
    - deadcode
    - depguard
    - dogsled
    - dupl
    - errcheck
    - gochecknoinits
    - goconst
    - gocritic
    - gocyclo
    - gofmt
    - goimports
    - golint
    - gomnd
    - goprintffuncname
    - gosec
    - gosimple
    - govet
    - ineffassign
    - interfacer
    - lll
    - misspell
    - nakedret
    - rowserrcheck
    - scopelint
    - staticcheck
    - structcheck
    - stylecheck
    - typecheck
    - unconvert
    - unparam
    - unused
    - varcheck
    - whitespace
  
  disable:
    - maligned  # 已被govet取代

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - gocyclo
        - errcheck
        - dupl
        - gosec
        - lll
```

```

### README.md

- **路径**: `D:\ide\tool\code-context-generator\docs\README.md`
- **大小**: 7884 字节
- **修改时间**: 2025-10-02T17:15:57+08:00

```md
# 代码上下文生成器 - 文档中心

欢迎使用代码上下文生成器文档中心！这里包含了使用、部署和开发该工具所需的全部文档。

## 📚 文档目录

### 📖 使用文档
- [**使用文档**](usage.md) - 完整的使用指南，包含CLI的所有功能说明
- [**快速开始**](../README.md) - 项目README，快速了解项目功能
- [**二进制文件处理**](binary-file-handling.md) - 二进制文件检测和处理机制

### 🚀 部署文档
- [**部署文档**](deployment.md) - 详细的部署指南，支持多种部署方式
- [**配置说明**](#配置文档) - 配置文件详解和示例

### 💻 开发文档
- [**开发环境文档**](development.md) - 完整的开发环境搭建和开发流程指南
- [**API文档**](#api文档) - 代码API文档（自动生成）

## 🎯 快速导航

### 新用户
1. 首先查看[快速开始](../README.md)了解项目
2. 阅读[使用文档](usage.md)学习如何使用
3. 查看[配置说明](#配置文档)进行个性化配置

### 部署人员
1. 阅读[部署文档](deployment.md)选择合适的部署方案
2. 查看[系统要求](deployment.md#系统要求)确认环境
3. 参考[监控和日志](deployment.md#监控和日志)进行运维

### 开发人员
1. 详细阅读[开发环境文档](development.md)搭建开发环境
2. 查看[代码结构](development.md#项目结构)了解项目架构
3. 遵循[开发流程](development.md#开发流程)进行开发
4. 运行[测试指南](development.md#测试指南)确保代码质量

## 📋 功能特性

### 🎯 核心功能
- **多格式输出**: 支持 JSON、XML、TOML、Markdown 格式
- **智能格式识别**: 基于配置文件名自动应用对应格式配置（如 config-json.yaml 自动使用 JSON 格式）
- **智能文件选择**: 交互式文件/目录选择界面
- **自动补全**: 文件路径智能补全功能
- **配置管理**: 灵活的配置系统，支持环境变量覆盖和格式覆盖
- **二进制文件处理**: 智能检测并处理二进制文件，避免内容错误

### 🚀 高级特性
- **并发处理**: 基于 goroutine 池的高性能文件扫描
- **大文件处理**: 流式读取，支持大文件处理
- **模式匹配**: 支持 glob 模式和正则表达式过滤
- **缓存机制**: 智能缓存提升重复扫描性能
- **跨平台**: 支持 Windows、Linux、macOS

### 🎨 用户界面
- **CLI 模式**: 功能丰富的命令行界面（基于 Cobra）
- **进度显示**: 实时进度条和状态信息

## 🔧 配置文档

### 配置文件格式
支持三种格式：TOML、YAML、JSON，默认使用 TOML 格式。

#### 基础配置示例
```toml
[output]
format = "json"
encoding = "utf-8"

[file_processing]
include_hidden = false
max_file_size = 10485760  # 10MB
max_depth = 0  # 无限制
exclude_patterns = [
    "*.exe", "*.dll", "*.so", "*.dylib",
    "*.pyc", "*.pyo", "*.pyd",
    "node_modules", ".git", ".svn", ".hg",
    "__pycache__", "*.egg-info", "dist", "build"
]
exclude_binary = true  # 排除二进制文件

[ui]
theme = "default"
show_progress = true
```

#### 智能格式覆盖配置
工具支持基于配置文件名的智能格式识别：
- `config-json.yaml` - 自动应用 JSON 格式配置
- `config-xml.yaml` - 自动应用 XML 格式配置  
- `config-toml.yaml` - 自动应用 TOML 格式配置
- `config-markdown.yaml` - 自动应用 Markdown 格式配置

例如，使用 `config-json.yaml` 时，工具会自动设置 `output.format = "json"` 并应用 JSON 相关的配置选项。

#### 完整配置示例
详见[使用文档](usage.md#配置文件详解)中的配置详解部分。

### 环境变量配置
```bash
# 输出格式
export CODE_CONTEXT_FORMAT=json

# 最大文件大小
export CODE_CONTEXT_MAX_SIZE=10485760

# 扫描深度
export CODE_CONTEXT_MAX_DEPTH=3

# 日志级别
export CODE_CONTEXT_LOG_LEVEL=info
```

## 🚀 快速开始示例

### CLI使用示例
```bash
# 扫描当前目录并输出JSON格式
./code-context-generator generate

# 扫描指定目录并输出Markdown格式
./code-context-generator generate /path/to/project -f markdown -o project.md

# 排除特定文件/目录
./code-context-generator generate -e "*.log" -e "node_modules" -e ".git"

# 包含文件内容和哈希值
./code-context-generator generate -C -H -f xml -o context.xml

# 排除二进制文件（默认行为）
./code-context-generator generate --exclude-binary

# 包含二进制文件（不推荐）
./code-context-generator generate --exclude-binary=false
```



## 📊 性能指标

### 基准测试结果
- **扫描速度**: 1000个文件/秒（平均）
- **内存使用**: 低于100MB（标准项目）
- **CPU使用**: 支持多核并发处理
- **大文件支持**: 支持GB级别文件处理

### 优化建议
1. 合理设置 `max_workers` 参数
2. 启用缓存机制
3. 使用适当的缓冲区大小
4. 排除不必要的目录
5. 限制扫描深度和文件大小

## 🔍 故障排除

### 常见问题

#### Q: 如何处理大文件？
**A**: 使用 `-s` 参数限制文件大小，例如 `-s 10485760` 限制为10MB。

#### Q: 如何排除特定目录？
**A**: 使用 `-e` 参数指定排除模式：`-e "node_modules" -e ".git" -e "*.log"`

#### Q: 如何包含隐藏文件？
**A**: 使用 `-h` 或 `--hidden` 参数包含隐藏文件。

#### Q: 如何处理二进制文件？
**A**: 默认情况下工具会自动检测并排除二进制文件。使用 `--exclude-binary` 控制此行为（默认true）。二进制文件在输出中会显示为"[二进制文件 - 内容未显示]"。

#### Q: 如何自定义输出格式？
**A**: 通过配置文件中的模板系统自定义输出格式。

#### Q: 性能优化建议？
1. 合理设置并发参数
2. 启用缓存机制
3. 使用适当的缓冲区大小
4. 限制扫描深度和文件大小
5. 排除不必要的目录

### 错误处理
- **权限错误**: 检查文件和目录的读取权限
- **内存不足**: 减小缓冲区大小和并发数
- **配置文件错误**: 验证配置文件语法

## 📈 更新日志

### v1.0.0 (2024-01-01)
- ✅ 初始版本发布
- ✅ 支持CLI界面
- ✅ 支持JSON、XML、TOML、Markdown格式
- ✅ 基础文件过滤功能
- ✅ 配置管理系统
- ✅ 二进制文件智能检测和处理

### 开发计划
- 🔄 添加更多输出格式
- 🔄 Web界面支持
- 🔄 插件系统
- 🔄 云存储集成
- 🔄 团队协作功能

## 🤝 贡献指南

### 如何贡献
1. Fork 项目仓库
2. 创建功能分支 (`git checkout -b feature/amazing-feature`)
3. 提交修改 (`git commit -m 'Add some amazing feature'`)
4. 推送到分支 (`git push origin feature/amazing-feature`)
5. 创建 Pull Request

### 开发规范
- 遵循 [Go代码规范](development.md#代码风格)
- 编写完整的测试用例
- 更新相关文档
- 通过所有质量检查

详细开发指南请查看[开发环境文档](development.md)。

## 📞 获取帮助

### 文档资源
- 📖 [使用文档](usage.md) - 使用方法和示例
- 🚀 [部署文档](deployment.md) - 部署和配置指南
- 💻 [开发文档](development.md) - 开发环境搭建

### 社区支持
- 🐛 [问题报告](https://github.com/yourusername/code-context-generator/issues)
- 💬 [讨论区](https://github.com/yourusername/code-context-generator/discussions)
- 📧 [邮件支持](mailto:support@example.com)

### 更新和支持
- ⭐ 给项目点个Star支持开发
- 🔔 关注项目获取更新通知
- 📝 提交Issue报告问题
- 🔄 提交Pull Request贡献代码

---

## 📄 许可证

本项目采用 MIT 许可证 - 查看 [LICENSE](../LICENSE) 文件了解详情。

## 🙏 致谢

感谢所有贡献者和使用者的支持！特别感谢以下贡献者：
- 项目贡献者列表
- 社区支持成员
- 文档编写参与者

---

*最后更新：2024年1月1日*  
*文档版本：v1.0.0*
```

### DOCUMENTATION_SUMMARY.md

- **路径**: `D:\ide\tool\code-context-generator\docs\DOCUMENTATION_SUMMARY.md`
- **大小**: 6030 字节
- **修改时间**: 2025-10-02T17:16:12+08:00

```md
# 📚 项目文档总结

本项目提供了完整而详细的文档体系，涵盖了使用、部署和开发的各个方面。

## 🎯 文档概览

### 📖 核心文档
| 文档 | 描述 | 目标读者 |
|------|------|----------|
| [README.md](README.md) | 项目主页和快速开始 | 所有用户 |
| [快速入门指南](quickstart.md) | 5分钟上手教程 | 新用户 |
| [使用文档](usage.md) | 完整功能使用说明 | 终端用户 |
| [配置文档](configuration.md) | 详细配置说明和格式覆盖功能 | 所有用户 |
| [部署文档](deployment.md) | 多种部署方式指南 | 运维人员 |
| [开发环境文档](development.md) | 开发环境搭建和开发流程 | 开发人员 |
| [文档中心](README.md) | 所有文档的导航中心 | 所有用户 |

### ⚙️ 配置示例
| 配置文件 | 用途 | 场景 |
|----------|------|------|
| [basic-config.toml](../examples/basic-config.toml) | 基础通用配置 | 日常使用 |
| [project-documentation.toml](../examples/project-documentation.toml) | 项目文档生成 | 完整文档 |
| [performance-optimized.toml](../examples/performance-optimized.toml) | 性能优化配置 | 大型项目 |

### 📝 使用示例
| 脚本 | 平台 | 功能 |
|------|------|------|
| [usage-examples.sh](../examples/usage-examples.sh) | Linux/macOS | 完整使用示例 |
| [usage-examples.bat](../examples/usage-examples.bat) | Windows | Windows使用示例 |

## 🚀 快速导航

### 🆕 新用户路径
1. ⭐ 阅读[项目README](../README.md)了解功能
2. 🚀 跟随[快速入门指南](quickstart.md)上手
3. 📖 查看[使用文档](usage.md)深入学习
4. ⚙️ 使用[基础配置示例](../examples/basic-config.toml)

### 🔧 部署人员路径
1. 📋 查看[部署文档](deployment.md)了解选项
2. 🐳 选择适合的部署方式（二进制/容器/K8s）
3. ⚙️ 配置系统服务和监控
4. 🔍 设置日志和备份策略

### 💻 开发人员路径
1. 🛠️ 阅读[开发环境文档](development.md)搭建环境
2. 📊 了解项目架构和代码结构
3. 🧪 学习测试流程和质量标准
4. 🤝 遵循贡献指南参与开发

## 📊 文档统计

### 内容覆盖
- ✅ **功能特性**: 100% 覆盖所有功能
- ✅ **使用场景**: 20+ 使用示例
- ✅ **配置选项**: 50+ 配置参数详解
- ✅ **部署方式**: 6种部署方案
- ✅ **开发流程**: 完整开发生命周期
- ✅ **故障排除**: 30+ 常见问题解答

### 文档规模
- 📄 总文档页数: 50+ 页
- 📝 总字数: 20,000+ 字
- 💡 代码示例: 100+ 个
- 🔧 配置示例: 10+ 个
- 📋 使用场景: 15+ 个

## 🎯 特色内容

### 📖 使用文档亮点
- 🎨 **CLI界面**: 详细的界面操作指南
- 🔧 **配置系统**: 完整的配置参数说明
- 🎯 **智能格式覆盖**: 基于配置文件名自动识别格式
- 📊 **格式支持**: JSON、XML、TOML、Markdown四种格式
- 🚀 **高级功能**: 并发处理、大文件优化、智能过滤
- ❓ **故障排除**: 30+ 常见问题和解决方案

### 🚀 部署文档亮点
- 📦 **多种部署方式**: 源码、二进制、容器、系统服务、K8s
- 🔒 **安全考虑**: 权限管理、网络安全、数据保护
- 📊 **监控和日志**: 完整的监控方案
- 🔄 **备份和恢复**: 自动化备份策略
- ⚡ **性能优化**: 系统调优建议

### 💻 开发文档亮点
- 🛠️ **环境搭建**: 详细的开发环境配置
- 📊 **项目架构**: 完整的架构设计说明
- 🧪 **测试体系**: 单元测试、集成测试、性能测试
- 🔍 **调试指南**: 调试工具和技巧
- 📋 **代码质量**: 静态检查、代码审查、CI/CD

## 🔗 相关链接

### 📚 外部资源
- [Go官方文档](https://golang.org/doc/)
- [Cobra CLI框架](https://github.com/spf13/cobra)

- [TOML配置格式](https://toml.io/)

### 🏠 项目资源
- 🐙 **GitHub仓库**: [项目地址](https://github.com/yourusername/code-context-generator)
- 📝 **Issue跟踪**: [问题反馈](https://github.com/yourusername/code-context-generator/issues)
- 💬 **讨论区**: [社区讨论](https://github.com/yourusername/code-context-generator/discussions)
- ⭐ **Star支持**: 给项目点Star支持开发

## 📈 更新计划

### 🔄 文档持续改进
- 📖 定期更新使用示例
- 🔧 添加新的配置场景
- 🚀 补充部署最佳实践
- 💡 收集用户反馈和建议

### 🆕 新文档计划
- 📊 **API文档**: 自动生成API参考
- 🎨 **主题定制**: UI主题开发指南
- 🔌 **插件开发**: 插件系统文档
- 🌍 **国际化**: 多语言支持文档

## 🤝 贡献指南

### 📖 文档贡献
- 🔍 发现文档错误？提交Issue
- 💡 有好的示例？提交Pull Request
- 🌍 想翻译文档？联系我们
- 📊 有使用经验？分享案例研究

### 📝 贡献方式
1. 🍴 Fork项目仓库
2. 📝 修改或添加文档
3. ✅ 确保内容准确完整
4. 🚀 提交Pull Request

## 📞 获取帮助

### 💬 社区支持
- 🐙 **GitHub Issues**: 技术问题和支持
- 📧 **邮件联系**: your.email@example.com
- 💭 **Discussions**: 功能讨论和建议

### 📚 自助资源
- 🔍 **搜索文档**: 使用文档内搜索功能
- ❓ **常见问题**: 查看FAQ部分
- 📖 **示例代码**: 参考配置和使用示例
- 🚀 **快速开始**: 跟随入门指南

---

## 🎉 总结

这套文档体系为代码上下文生成器提供了全方位的支持：

- **🎯 新用户**可以通过快速入门指南快速上手
- **🔧 高级用户**可以在使用文档中找到所有功能细节
- **🚀 运维人员**可以参考部署文档进行生产部署
- **💻 开发人员**可以通过开发文档参与项目贡献

无论你是想**快速使用**、**深入了解**、**生产部署**还是**参与开发**，这套文档都能为你提供所需的全部信息。

---

*📅 最后更新: 2024年1月1日*  
*📝 文档版本: v1.0.0*  
*👥 维护团队: 代码上下文生成器开发团队*
```

### configuration.md

- **路径**: `D:\ide\tool\code-context-generator\docs\configuration.md`
- **大小**: 5248 字节
- **修改时间**: 2025-10-02T17:12:48+08:00

```md
# 配置文档

## 概述

代码上下文生成器支持通过配置文件进行灵活的格式和输出设置。配置文件支持YAML、JSON和TOML格式。

## 配置文件格式覆盖功能

### 智能格式识别

系统会根据配置文件名自动识别并应用相应的格式配置：

- **配置文件名包含"xml"** → 自动应用XML格式配置，默认输出格式设为XML
- **配置文件名包含"json"** → 自动应用JSON格式配置，默认输出格式设为JSON  
- **配置文件名包含"toml"** → 自动应用TOML格式配置，默认输出格式设为TOML
- **配置文件名包含"markdown"或"md"** → 自动应用Markdown格式配置，默认输出格式设为Markdown

### 使用示例

```bash
# 使用XML配置（自动应用XML格式）
./test-build.exe -c config-xml.yaml generate

# 使用JSON配置（自动应用JSON格式）
./test-build.exe -c config-json.yaml generate

# 使用TOML配置（自动应用TOML格式）
./test-build.exe -c config-toml.yaml generate
```

## 配置结构

### 格式配置（Formats）

#### XML格式
```yaml
formats:
  xml:
    enabled: true
    root_tag: "context"
    file_tag: "file"
    files_tag: "files"
    folder_tag: "folder"
    fields:
      path: "path"
      content: "content"
      filename: "filename"
    formatting:
      indent: "  "
      declaration: true
      encoding: "UTF-8"
```

#### JSON格式
```yaml
formats:
  json:
    enabled: true
    structure:
      file: "source_file"
      folder: "directory"
      files: "all_files"
    fields:
      path: "relative_path"
      content: "file_content"
      filename: "file_name"
```

#### TOML格式
```yaml
formats:
  toml:
    enabled: true
    structure:
      file_section: "file"
      folder_section: "folder"
    fields:
      path: "path"
      content: "content"
      filename: "filename"
```

#### Markdown格式
```yaml
formats:
  markdown:
    enabled: true
    structure:
      file_header: "##"
      folder_header: "###"
      code_block: "```"
    formatting:
      separator: "\n\n"
      add_toc: false
      code_language: true
```

### 输出配置（Output）

```yaml
output:
  default_format: "xml"  # 会被配置文件名自动覆盖
  output_dir: "output"
  filename_template: "context_{{.timestamp}}.{{.extension}}"
  timestamp_format: "20060102_150405"
```
时间戳为参考时间，用于生成唯一的文件名。

### 文件处理配置（FileProcessing）

```yaml
file_processing:
  include_hidden: false
  include_content: true
  include_hash: false
```

### 字段配置（Fields）

```yaml
fields:
  custom_names:
    filepath: "path"
    filecontent: "content"
    filename: "name"
  filter:
    include: []
    exclude: []
  processing:
    max_length: 0
    add_line_numbers: false
    trim_whitespace: true
    code_highlight: false
```

### 过滤配置（Filters）

```yaml
filters:
  max_file_size: "10MB"
  exclude_patterns:
    - "*.tmp"
    - "*.log"
    - "node_modules"
  include_patterns: []
  max_depth: 0
  follow_symlinks: false
  exclude_binary: true
```



## 环境变量配置

系统支持通过环境变量覆盖配置：

- `CONTEXT_DEFAULT_FORMAT`: 默认输出格式
- `CONTEXT_OUTPUT_DIR`: 输出目录
- `CONTEXT_FILENAME_TEMPLATE`: 文件名模板
- `CONTEXT_TIMESTAMP_FORMAT`: 时间戳格式
- `CONTEXT_MAX_FILE_SIZE`: 最大文件大小
- `CONTEXT_MAX_DEPTH`: 最大深度
- `CONTEXT_RECURSIVE`: 是否递归
- `CONTEXT_INCLUDE_HIDDEN`: 是否包含隐藏文件
- `CONTEXT_FOLLOW_SYMLINKS`: 是否跟随符号链接
- `CONTEXT_EXCLUDE_BINARY`: 是否排除二进制文件
- `CONTEXT_EXCLUDE_PATTERNS`: 排除模式（逗号分隔）


## 完整配置示例

### XML配置文件（config-xml.yaml）
```yaml
formats:
  xml:
    enabled: true
  json:
    enabled: false
  toml:
    enabled: false
  markdown:
    enabled: false

output:
  output_dir: xml_output
  filename_template: "project_{{.timestamp}}.xml"

filters:
  max_file_size: "10MB"
  exclude_patterns:
    - "*.tmp"
    - "*.log"
    - "node_modules"
```

### JSON配置文件（config-json.yaml）
```yaml
formats:
  xml:
    enabled: false
  json:
    enabled: true
    structure:
      file: source_file
      folder: directory
      files: all_files
    fields:
      path: relative_path
      content: file_content
      filename: file_name
  toml:
    enabled: false
  markdown:
    enabled: false

output:
  output_dir: json_output
  filename_template: "context_{{.timestamp}}.json"

filters:
  max_file_size: "2MB"
  exclude_patterns:
    - "*.tmp"
    - "*.log"
    - "*.swp"
    - ".*"
    - "node_modules/"
    - "target/"
    - "dist/"
    - "build/"
```

## 配置文件加载规则

1. 系统首先加载配置文件内容
2. 应用环境变量覆盖
3. 根据配置文件名应用格式特定的配置覆盖
4. 最终配置 = 基础配置 + 环境变量覆盖 + 格式特定覆盖

## 注意事项

1. 由于go语言的XML解析不支持复杂结构，XML配置文件格式暂不支持，请使用YAML、JSON或TOML格式
2. 格式自动识别基于配置文件名，不依赖于文件扩展名
3. 如果对应格式在配置中未启用，格式覆盖将不会生效
4. 环境变量配置的优先级高于配置文件但低于命令行参数
```

### deployment.md

- **路径**: `D:\ide\tool\code-context-generator\docs\deployment.md`
- **大小**: 8738 字节
- **修改时间**: 2025-10-02T17:16:05+08:00

```md
# 代码上下文生成器 - 部署文档

## 部署方式

### 1. 源码部署

#### 环境准备
```bash
# 安装Go 1.24+
go version
```

#### 构建应用
```bash
# 下载依赖
go mod download

# 构建CLI版本
go build -o code-context-generator cmd/cli/main.go


```

#### 安装到系统路径
```bash
# Linux/macOS
sudo cp code-context-generator /usr/local/bin/
sudo chmod +x /usr/local/bin/code-context-generator*

# Windows
copy code-context-generator.exe C:\Windows\System32\
```

### 2. 二进制部署

#### 下载预编译二进制文件
```bash
# Linux
wget https://github.com/yourusername/code-context-generator/releases/download/v1.0.0/code-context-generator-linux-amd64.tar.gz
tar -xzf code-context-generator-linux-amd64.tar.gz

# Windows: 下载zip并解压
# macOS: 下载tar.gz并解压
```

### 3. Docker部署

#### 构建镜像
```bash
docker build -t code-context-generator:latest .
```

#### 运行容器
```bash
# 基本运行
docker run -it --rm code-context-generator:latest --help

# 挂载目录扫描
docker run -it --rm -v $(pwd):/workspace -w /workspace code-context-generator:latest generate .
```

## 验证部署

```bash
# 检查版本
./code-context-generator --version

# 测试基本功能
./code-context-generator generate --help
```

### Docker Compose 部署

#### 启动服务
```bash
docker-compose up -d

# 查看日志
docker-compose logs -f code-context-generator

# 停止服务
docker-compose down
```

## 环境配置

### 开发环境

#### 环境变量配置
```bash
# Linux/macOS: ~/.bashrc 或 ~/.zshrc
export CODE_CONTEXT_ENV=development
export CODE_CONTEXT_LOG_LEVEL=debug
export CODE_CONTEXT_CONFIG_PATH=~/projects/code-context-generator/config.toml

# Windows: 系统环境变量
setx CODE_CONTEXT_ENV development
setx CODE_CONTEXT_LOG_LEVEL debug
setx CODE_CONTEXT_CONFIG_PATH "C:\projects\code-context-generator\config.toml"
```

#### 开发配置文件
```toml
# config.development.toml
[output]
format = "json"
encoding = "utf-8"

[file_processing]
include_hidden = true
max_file_size = 52428800  # 50MB
max_depth = 10
exclude_patterns = [".git", "node_modules", "*.tmp"]
include_content = true
include_hash = true



#### 智能格式覆盖配置
工具支持基于配置文件名的智能格式识别功能：
- `config-json.yaml` - 自动应用 JSON 格式配置
- `config-xml.yaml` - 自动应用 XML 格式配置
- `config-toml.yaml` - 自动应用 TOML 格式配置
- `config-markdown.yaml` - 自动应用 Markdown 格式配置

例如，创建 `config-json.yaml` 文件时，工具会自动设置 `output.format = "json"` 并应用 JSON 相关的配置选项。

[performance]
max_workers = 8
buffer_size = 4096
cache_enabled = true

[logging]
level = "debug"
file_path = "logs/development.log"
```

### 测试环境

#### 测试配置
```toml
# config.test.toml
[output]
format = "xml"
encoding = "utf-8"

[file_processing]
include_hidden = false
max_file_size = 10485760  # 10MB
max_depth = 5
exclude_patterns = [".git", "node_modules", "test_*"]
include_content = false

[performance]
max_workers = 2
buffer_size = 1024

[logging]
level = "info"
file_path = "logs/test.log"
```

### 生产环境

#### 生产配置
```toml
# config.production.toml
[output]
format = "json"
encoding = "utf-8"

[file_processing]
include_hidden = false
max_file_size = 5242880  # 5MB
max_depth = 3
exclude_patterns = [
    ".git", "node_modules", "*.tmp", "*.log",
    "vendor", "cache", "temp"
]
include_content = false
include_hash = false

[performance]
max_workers = 4
buffer_size = 2048
cache_enabled = true
cache_size = 200

[logging]
level = "warn"
file_path = "/var/log/code-context-generator/production.log"
max_size = 100
max_backups = 10
max_age = 30
```

## 监控和日志

### 日志配置

#### 日志轮转配置
```bash
# Linux: /etc/logrotate.d/code-context-generator
/var/log/code-context-generator/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 644 code-context code-context
    postrotate
        systemctl reload code-context-generator
    endscript
}
```

#### 日志格式
```json
{
  "timestamp": "2024-01-01T12:00:00Z",
  "level": "info",
  "component": "scanner",
  "message": "Scan started",
  "context": {
    "path": "/workspace",
    "format": "json",
    "options": {
      "max_depth": 3,
      "include_hidden": false
    }
  }
}
```

### 监控指标

#### Prometheus指标
```yaml
# metrics.yml
code_context_scanner_files_scanned_total 1250
code_context_scanner_folders_scanned_total 45
code_context_scanner_errors_total 2
code_context_scanner_duration_seconds 15.3
code_context_scanner_file_size_bytes 5242880
code_context_memory_usage_bytes 67108864
code_context_cpu_usage_percent 25.5
```

#### 健康检查端点
```bash
# HTTP健康检查（如果启用Web服务）
curl -f http://localhost:8080/health || exit 1

# 进程健康检查
ps aux | grep code-context-generator | grep -v grep

# 文件健康检查
[ -f /var/run/code-context-generator.pid ] && kill -0 $(cat /var/run/code-context-generator.pid)
```

## 备份和恢复

### 配置备份
```bash
# 备份配置文件
cp /etc/code-context-generator/config.toml /backup/code-context-generator-config-$(date +%Y%m%d).toml

# 备份日志文件
tar -czf /backup/code-context-generator-logs-$(date +%Y%m%d).tar.gz /var/log/code-context-generator/
```

### 数据备份
```bash
# 备份输出文件
cp /var/code-context-generator/output/*.json /backup/output/

# 备份缓存
cp -r /var/cache/code-context-generator /backup/cache/
```

## 安全考虑

### 文件权限
```bash
# 设置适当的文件权限
chmod 755 /usr/local/bin/code-context-generator
chmod 644 /etc/code-context-generator/config.toml
chmod 750 /var/log/code-context-generator/
chown -R code-context:code-context /opt/code-context-generator/
```

### 网络安全
- 限制网络访问（如果需要网络功能）
- 使用防火墙规则
- 定期更新依赖包
- 扫描安全漏洞

### 数据安全
- 加密敏感配置文件
- 限制日志文件访问
- 定期清理临时文件
- 备份重要数据

## 性能优化

### 系统调优
```bash
# Linux系统调优
# /etc/sysctl.conf
fs.file-max = 65536
vm.swappiness = 10
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216

# 应用配置
sysctl -p
```

### 应用调优
```toml
# 性能优化配置
[performance]
max_workers = 8  # 根据CPU核心数调整
buffer_size = 8192  # 增大缓冲区
batch_size = 100  # 批处理大小
cache_size = 500  # 增大缓存
```

### 配置迁移
```bash
# 检查配置兼容性
./code-context-generator config validate --config /etc/code-context-generator/config.toml

# 更新配置格式（如果需要）
./code-context-generator config migrate --from /etc/code-context-generator/config.toml.bak --to /etc/code-context-generator/config.toml
```

## 支持信息

### 获取帮助
- 项目文档: [项目文档链接]
- 问题报告: [GitHub Issues](https://github.com/yourusername/code-context-generator/issues)
- 技术支持: support@example.com

### 系统信息收集
```bash
# 收集系统信息用于支持
./scripts/collect-system-info.sh > system-info.txt

# 收集应用日志
tar -czf app-logs.tar.gz /var/log/code-context-generator/
```

## 附录

### A. 系统要求检查脚本
```bash
#!/bin/bash
# check-requirements.sh

echo "检查系统要求..."

# 检查Go版本
if command -v go &> /dev/null; then
    GO_VERSION=$(go version | awk '{print $3}')
    echo "✓ Go版本: $GO_VERSION"
else
    echo "✗ Go未安装"
fi

# 检查内存
MEMORY=$(free -m | awk 'NR==2{print $2}')
if [ $MEMORY -ge 512 ]; then
    echo "✓ 内存: ${MEMORY}MB"
else
    echo "✗ 内存不足: ${MEMORY}MB (需要至少512MB)"
fi

# 检查磁盘空间
DISK=$(df -m . | awk 'NR==2{print $4}')
if [ $DISK -ge 100 ]; then
    echo "✓ 磁盘空间: ${DISK}MB"
else
    echo "✗ 磁盘空间不足: ${DISK}MB (需要至少100MB)"
fi

echo "系统要求检查完成"
```

### B. 快速部署脚本
```bash
#!/bin/bash
# quick-deploy.sh

set -e

echo "开始快速部署..."

# 检查系统要求
./scripts/check-requirements.sh

# 下载最新版本
LATEST_VERSION=$(curl -s https://api.github.com/repos/yourusername/code-context-generator/releases/latest | grep tag_name | cut -d '"' -f 4)
wget "https://github.com/yourusername/code-context-generator/releases/download/${LATEST_VERSION}/code-context-generator-linux-amd64.tar.gz"

# 解压和安装
tar -xzf code-context-generator-linux-amd64.tar.gz
sudo cp code-context-generator /usr/local/bin/


# 创建配置目录
mkdir -p ~/.config/code-context-generator

# 初始化配置
code-context-generator config init

echo "快速部署完成！"
echo "运行 'code-context-generator --help' 开始使用"
```
```

### binary-file-handling.md

- **路径**: `D:\ide\tool\code-context-generator\docs\binary-file-handling.md`
- **大小**: 9025 字节
- **修改时间**: 2025-10-01T16:25:02+08:00

```md
# 二进制文件处理文档

## 概述

本项目实现了智能的二进制文件检测和处理机制，确保在构建代码上下文时能够正确处理文本文件和二进制文件，避免二进制文件内容导致的处理问题。

## 二进制文件检测原理

### 检测方法

项目使用智能的二进制文件检测方法，结合文件扩展名和内容分析，通过`internal/utils/utils.go`中的工具函数实现：

```go
// IsTextFile 检查是否为文本文件
func IsTextFile(path string) bool {
    // 首先检查文件扩展名
    ext := strings.ToLower(filepath.Ext(path))
    textExtensions := []string{
        ".txt", ".md", ".json", ".xml", ".yaml", ".yml", ".toml",
        ".go", ".py", ".js", ".ts", ".java", ".cpp", ".c", ".h",
        ".html", ".css", ".scss", ".sass", ".sql", ".sh", ".bat",
        ".ps1", ".rb", ".php", ".rs", ".swift", ".kt", ".scala",
    }

    for _, textExt := range textExtensions {
        if ext == textExt {
            return true
        }
    }

    // 如果没有扩展名，尝试读取文件内容来判断
    if ext == "" {
        file, err := os.Open(path)
        if err != nil {
            return false // 无法打开文件，假设为二进制文件
        }
        defer file.Close()

        // 读取前512字节来判断是否为文本文件
        buffer := make([]byte, 512)
        n, err := file.Read(buffer)
        if err != nil && err != io.EOF {
            return false // 读取错误，假设为二进制文件
        }

        // 检查是否包含null字节（二进制文件的标志）
        for i := 0; i < n; i++ {
            if buffer[i] == 0 {
                return false // 包含null字节，是二进制文件
            }
        }

        // 检查是否包含可打印字符
        printableCount := 0
        for i := 0; i < n; i++ {
            b := buffer[i]
            if b >= 32 && b <= 126 { // 可打印ASCII字符
                printableCount++
            } else if b == 9 || b == 10 || b == 13 { // tab, newline, carriage return
                printableCount++
            }
        }

        // 如果大部分字符都是可打印的，认为是文本文件
        if n > 0 && float64(printableCount)/float64(n) > 0.8 {
            return true
        }
    }

    return false
}

// IsBinaryFile 检查是否为二进制文件
func IsBinaryFile(path string) bool {
    return !IsTextFile(path)
}
```

### 支持的文本文件类型

系统支持多种常见的文本文件扩展名，包括：

- **编程语言**: `.go`, `.py`, `.js`, `.ts`, `.java`, `.cpp`, `.c`, `.rb`, `.php`, `.rs`, `.swift`, `.kt`, `.scala`
- **标记语言**: `.html`, `.xml`, `.json`, `.yaml`, `.yml`, `.toml`, `.md`
- **样式文件**: `.css`, `.scss`, `.sass`
- **脚本文件**: `.sh`, `.bat`, `.ps1`, `.sql`

### 无扩展名文件处理

对于没有扩展名的文件，系统采用智能内容分析算法：

1. **内容采样**: 读取文件前512字节进行内容分析
2. **二进制检测**: 检查是否包含null字节（二进制文件的标志）
3. **字符分析**: 统计可打印字符比例（ASCII 32-126）和常见控制字符（tab、换行、回车）
4. **智能判断**: 如果超过80%的字符为可打印字符，则判定为文本文件

这种智能检测机制确保无扩展名的文本文件（如README、LICENSE、Makefile等）能够被正确识别和处理。

## 文件处理流程

### 1. 文件系统遍历阶段

在`internal/filesystem/filesystem.go`中，文件系统遍历器会在以下阶段进行二进制文件检查：

```go
func (w *FileSystemWalker) shouldIncludeFile(path string, options *types.WalkOptions) bool {
    // 检查文件大小
    if !w.FilterBySize(path, options.MaxFileSize) {
        return false
    }
    
    // 检查是否为二进制文件（如果启用了二进制文件排除）
    if options.ExcludeBinary && utils.IsBinaryFile(path) {
        return false
    }
    
    // 其他过滤逻辑...
    return true
}
```

### 2. 文件内容读取阶段

在`GetFileInfo`方法中，系统会根据文件类型决定是否读取内容：

```go
func (w *FileSystemWalker) GetFileInfo(path string) (*types.FileInfo, error) {
    // 检查是否为二进制文件
    isBinary := !utils.IsTextFile(path)
    
    var content string
    if !isBinary {
        // 只读取文本文件的内容
        fileContent, err := os.ReadFile(path)
        if err != nil {
            return nil, fmt.Errorf("读取文件内容失败: %w", err)
        }
        content = string(fileContent)
    }
    
    return &types.FileInfo{
        Path:     path,
        Name:     info.Name(),
        Size:     info.Size(),
        ModTime:  info.ModTime(),
        IsDir:    info.IsDir(),
        Content:  content,
        IsBinary: isBinary,
    }, nil
}
```

### 3. 格式化输出阶段

各种格式化器会根据`IsBinary`字段处理文件内容：

#### JSON格式化器
```go
func (f *JSONFormatter) FormatFile(file types.FileInfo) (string, error) {
    // 如果是二进制文件，不显示内容
    if file.IsBinary {
        file.Content = "[二进制文件 - 内容未显示]"
    }
    
    // 格式化逻辑...
}
```

#### Markdown格式化器
```go
func (f *MarkdownFormatter) FormatFile(file types.FileInfo) (string, error) {
    // 添加代码块（只针对文本文件）
    if !file.IsBinary {
        sb.WriteString("```")
        // 添加代码高亮等...
        sb.WriteString(file.Content)
        sb.WriteString("\n```\n")
    } else {
        sb.WriteString("**[二进制文件 - 内容未显示]**\n")
    }
    // ...
}
```

## 配置选项

### 命令行选项

在CLI工具中，可以通过以下选项控制二进制文件处理：

```bash
# 排除二进制文件（默认行为）
code-context-generator generate --exclude-binary path/to/directory

# 包含二进制文件（不推荐）
code-context-generator generate --exclude-binary=false path/to/directory
```

### 配置文件选项

在配置文件中，可以通过以下设置控制二进制文件处理：

```toml
[filters]
max_file_size = "10MB"
exclude_patterns = ["*.log", "*.tmp"]
exclude_binary = true  # 排除二进制文件
max_depth = 5
```

## 类型定义

### FileInfo结构体

在`pkg/types/types.go`中，文件信息结构体包含二进制文件标识：

```go
type FileInfo struct {
    Name     string    `yaml:"name" json:"name" toml:"name"`
    Path     string    `yaml:"path" json:"path" toml:"path"`
    Content  string    `yaml:"content" json:"content" toml:"content"`
    Size     int64     `yaml:"size" json:"size" toml:"size"`
    ModTime  time.Time `yaml:"mod_time" json:"mod_time" toml:"mod_time"`
    IsDir    bool      `yaml:"is_dir" json:"is_dir" toml:"is_dir"`
    IsHidden bool      `yaml:"is_hidden" json:"is_hidden" toml:"is_hidden"`
    IsBinary bool      `yaml:"is_binary" json:"is_binary" toml:"is_binary"`
}
```

### WalkOptions结构体

文件遍历选项包含二进制文件过滤设置：

```go
type WalkOptions struct {
    MaxDepth        int
    MaxFileSize     int64
    ExcludePatterns []string
    IncludePatterns []string
    FollowSymlinks  bool
    ShowHidden      bool
    ExcludeBinary   bool  // 是否排除二进制文件
}
```

### FiltersConfig结构体

过滤器配置包含二进制文件排除选项：

```go
type FiltersConfig struct {
    MaxFileSize     string   `yaml:"max_file_size" json:"max_file_size" toml:"max_file_size"`
    ExcludePatterns []string `yaml:"exclude_patterns" json:"exclude_patterns" toml:"exclude_patterns"`
    IncludePatterns []string `yaml:"include_patterns" json:"include_patterns" toml:"include_patterns"`
    MaxDepth        int      `yaml:"max_depth" json:"max_depth" toml:"max_depth"`
    FollowSymlinks  bool     `yaml:"follow_symlinks" json:"follow_symlinks" toml:"follow_symlinks"`
    ExcludeBinary   bool     `yaml:"exclude_binary" json:"exclude_binary" toml:"exclude_binary"`
}
```

## 优势

1. **安全性**: 避免二进制文件内容导致的编码问题或程序崩溃
2. **性能**: 不读取二进制文件内容，提高处理速度
3. **清晰度**: 在输出中明确标识二进制文件
4. **灵活性**: 可通过配置控制是否排除二进制文件
5. **扩展性**: 易于添加新的文本文件类型支持

## 使用建议

1. **默认配置**: 建议保持`exclude_binary = true`的默认设置
2. **自定义类型**: 如需支持新的文件类型，可修改`IsTextFile`函数
3. **性能优化**: 对于大型项目，二进制文件排除可以显著提高扫描速度
4. **内容验证**: 对于重要文件，建议先验证文件类型再进行处理

## 相关文件

- `internal/utils/utils.go` - 二进制文件检测函数
- `internal/filesystem/filesystem.go` - 文件系统遍历和过滤
- `internal/formatter/formatter.go` - 格式化输出处理
- `pkg/types/types.go` - 类型定义
- `internal/config/config.go` - 配置文件处理
- `cmd/cli/main.go` - CLI命令行选项
```

### development.md

- **路径**: `D:\ide\tool\code-context-generator\docs\development.md`
- **大小**: 9152 字节
- **修改时间**: 2025-10-02T17:13:42+08:00

```md
# 代码上下文生成器 - 开发环境使用文档

## 开发环境要求

- **Go**: 1.24+
- **Git**: 2.30+
- **操作系统**: Windows 10+/Linux/macOS

## 环境搭建

### 1. Go环境安装

```bash
# 验证安装
go version
```

### 2. 获取项目源码

```bash
# 克隆仓库
git clone https://github.com/yourusername/code-context-generator.git
cd code-context-generator
```

### 3. 安装依赖

```bash
# 下载依赖
go mod download

# 整理依赖
go mod tidy
```

### 4. 开发工具安装

```bash
# 安装代码质量工具
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# 安装调试工具
go install github.com/go-delve/delve/cmd/dlv@latest
```

## 项目结构

```
code-context-generator/
├── cmd/                    # 应用程序入口
│   └── cli/               # CLI应用入口
│       ├── main.go
│       └── config.yaml
├── internal/              # 内部包
│   ├── config/           # 配置管理
│   │   ├── config.go
│   │   ├── config.yaml
│   │   └── config_test.go
│   ├── env/              # 环境变量处理
│   │   └── env.go
│   ├── filesystem/       # 文件系统操作
│   │   ├── filesystem.go
│   │   └── filesystem_test.go
│   ├── formatter/        # 格式转换
│   │   ├── formatter.go
│   │   └── formatter_test.go
│   ├── selector/         # 文件选择器
│   │   ├── file_selector.go
│   │   ├── file_utils.go
│   │   ├── pattern_matcher.go
│   │   ├── selector.go
│   │   └── selector_test.go
│   └── utils/            # 工具函数
│   │   ├── color.go
│   │   ├── encoding.go
│   │   ├── file.go
│   │   ├── path.go
│   │   ├── regex.go
│   │   ├── string.go
│   │   ├── time.go
│   │   ├── utils.go
│   │   ├── utils_test.go
│   │   └── validation.go
├── pkg/                   # 可复用的包
│   ├── constants/        # 常量定义
│   │   └── constants.go
│   └── types/            # 类型定义
│       └── types.go
├── configs/               # 配置文件模板
├── docs/                  # 文档
├── examples/              # 使用示例和配置示例
├── tests/                 # 测试文件
├── go.mod                # Go模块定义
├── go.sum                # 依赖校验
├── README.md             # 项目说明
├── LICENSE               # 许可证
└── .gitignore            # Git忽略规则
```

## 开发流程

### 1. 分支管理

```bash
# 查看分支
git branch -a

# 创建功能分支
git checkout -b feature/add-new-formatter

# 创建修复分支
git checkout -b fix/memory-leak

# 创建发布分支
git checkout -b release/v1.1.0
```

### 2. 开发规范

#### 代码风格
- 遵循官方Go代码规范
- 使用gofmt格式化代码
- 使用golint检查代码质量
- 遵循项目内部的命名约定

#### 提交规范
```
类型(范围): 简短描述

详细描述（可选）

Fixes #123
```

类型包括：
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

#### 示例提交
```bash
git commit -m "feat(formatter): add YAML format support

- Implement YAMLFormatter with custom field mapping
- Add YAML format configuration options
- Update documentation for YAML support

Fixes #45"
```

### 3. 开发步骤

#### 步骤1：创建功能分支
```bash
# 更新主分支
git checkout main
git pull upstream main

# 创建功能分支
git checkout -b feature/improve-performance
```

#### 步骤2：编写代码
```bash
# 创建新文件
touch internal/performance/optimizer.go
touch internal/performance/optimizer_test.go

# 编写代码（示例）
package performance

import (
    "runtime"
    "sync"
)

type Optimizer struct {
    workers int
    pool    *sync.Pool
}

func NewOptimizer(workers int) *Optimizer {
    return &Optimizer{
        workers: workers,
        pool: &sync.Pool{
            New: func() interface{} {
                return make([]byte, 4096)
            },
        },
    }
}
```

#### 步骤3：运行测试
```bash
# 运行所有测试
go test ./...

# 运行特定包的测试
go test ./internal/performance/

# 运行测试并显示覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
```

#### 步骤4：代码质量检查
```bash
# 格式化代码
go fmt ./...

# 运行golint
golint ./...

# 运行go vet
go vet ./...

# 运行golangci-lint
golangci-lint run

# 检查依赖安全性
go list -json -m all | nancy sleuth
```

#### 步骤5：构建应用
```bash
# 构建CLI版本
go build -o bin/code-context-generator cmd/cli/main.go

# 构建所有版本
make build

# 交叉编译
GOOS=windows GOARCH=amd64 go build -o bin/code-context-generator.exe cmd/cli/main.go
GOOS=linux GOARCH=amd64 go build -o bin/code-context-generator-linux cmd/cli/main.go
GOOS=darwin GOARCH=amd64 go build -o bin/code-context-generator-darwin cmd/cli/main.go
```

#### 步骤6：运行应用
```bash
# 运行CLI版本
./bin/code-context-generator --help

# 使用示例
./bin/code-context-generator generate . -f json -o output.json
```

#### 步骤7：提交代码
```bash
# 添加修改的文件
git add .

# 提交修改
git commit -m "feat(performance): add memory pool for better performance

- Implement sync.Pool for buffer reuse
- Add configurable worker pool size
- Improve memory allocation efficiency
- Add benchmarks for performance testing

Fixes #67"

# 推送到远程仓库
git push origin feature/improve-performance
```

## 测试指南

### 1. 单元测试

#### 创建测试文件
```go
// internal/formatter/formatter_test.go
package formatter

import (
    "testing"
    "code-context-generator/pkg/types"
)

func TestJSONFormatter_Format(t *testing.T) {
    formatter := NewJSONFormatter(nil)
    
    data := types.ContextData{
        Files: []types.FileInfo{
            {
                Path:     "test.go",
                Size:     1024,
                Modified: "2024-01-01T00:00:00Z",
            },
        },
        FileCount: 1,
        TotalSize: 1024,
    }
    
    result, err := formatter.Format(data)
    if err != nil {
        t.Fatalf("Format failed: %v", err)
    }
    
    if result == "" {
        t.Error("Expected non-empty result")
    }
    
    // 验证JSON格式
    if !strings.HasPrefix(result, "{") {
        t.Error("Expected JSON object")
    }
}
```

#### 运行单元测试
```bash
# 运行所有测试
go test ./...

# 运行特定测试
go test ./internal/formatter/

# 运行测试并显示详细信息
go test -v ./...

# 运行测试并生成覆盖率报告
go test -cover -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
```

### 2. 集成测试

#### 创建集成测试
```go
// tests/integration_test.go
package tests

import (
    "os"
    "path/filepath"
    "testing"
    "code-context-generator/internal/filesystem"
)

func TestIntegration_FileSystemWalker(t *testing.T) {
    // 创建测试目录结构
    testDir := t.TempDir()
    
    // 创建测试文件
    files := []string{
        "file1.go",
        "file2.txt",
        "subdir/file3.json",
    }
    
    for _, file := range files {
        path := filepath.Join(testDir, file)
        os.MkdirAll(filepath.Dir(path), 0755)
        os.WriteFile(path, []byte("test content"), 0644)
    }
    
    // 测试文件系统遍历器
    walker := filesystem.NewFileSystemWalker(types.WalkOptions{
        MaxDepth: 3,
        ShowHidden: false,
    })
    
    result, err := walker.Walk(testDir, nil)
    if err != nil {
        t.Fatalf("Walk failed: %v", err)
    }
    
    // 验证结果
    if len(result.Files) != len(files) {
        t.Errorf("Expected %d files, got %d", len(files), len(result.Files))
    }
}
```


## 故障排除

### 常见问题

#### 依赖问题
```bash
# 清理模块缓存
go clean -modcache

# 重新下载依赖
go mod download

# 更新依赖
go get -u ./...
go mod tidy
```

#### 构建问题
```bash
# 清理构建缓存
go clean -cache

# 强制重新构建
go build -a ./...

# 检查构建约束
//go:build linux && amd64
```

#### 测试问题
```bash
# 运行测试并显示详细输出
go test -v ./...

# 运行特定测试
go test -run TestJSONFormatter ./internal/formatter/

# 跳过某些测试
go test -short ./...
```

```

### README.md

- **路径**: `D:\ide\tool\code-context-generator\docs\plan\README.md`
- **大小**: 4801 字节
- **修改时间**: 2025-10-02T09:58:00+08:00

```md
# 代码上下文生成器 - 双入口点改进计划

## 📋 项目概述

本项目包含两个主要的程序入口点，分别服务于不同的使用场景。当前存在配置复用不足的问题，本计划旨在解决这些问题并提供清晰的使用指导。

## 📁 文档结构

```
docs/plan/
├── README.md                           # 本文件 - 项目总览
├── dual-entry-points-analysis.md       # 双入口点架构分析
├── improvement-implementation-plan.md    # 配置复用改进实施计划
├── usage-guidelines.md                 # 使用指南和最佳实践
└── [其他相关文档]
```

## 🔍 问题识别

### 主要问题
1. **配置复用不足**：根目录 `main.go` 未使用配置文件、环境变量和忽略规则
2. **工具复用缺失**：两个入口点使用不同的处理逻辑和工具链
3. **用户体验不一致**：参数格式、输出质量和错误处理存在差异

### 具体表现
- 根目录版本使用硬编码的排除规则（`.git`, `node_modules`等）
- 不支持 `config.yaml` 配置文件
- 不支持环境变量配置
- 输出格式可能与CLI版本不一致

## 🎯 改进目标

### 短期目标（配置复用）
- ✅ 使根目录 `main.go` 支持配置文件加载
- ✅ 统一使用环境变量和忽略规则
- ✅ 保持向后兼容性和简单易用特点

### 长期目标（体验统一）
- 🔄 标准化输出格式和处理逻辑
- 🔄 统一错误处理机制
- 🔄 提供一致的参数支持

## 🚀 实施计划

### 阶段一：配置复用改进（高优先级）

**修改文件**：`d:/ide/tool/code-context-generator/main.go`

**核心改动**：
1. 添加配置管理器初始化和配置加载
2. 使用配置文件中的忽略规则和处理参数
3. 保持现有交互体验和简单性

**预期效果**：
- 根目录版本将使用与CLI版本相同的配置体系
- 支持 `config.yaml` 和环境变量
- 保持零学习成本的特点

### 阶段二：工具链统一（中优先级）

**改进内容**：
1. 统一文件系统遍历器使用
2. 标准化输出格式处理
3. 错误处理机制统一

### 阶段三：功能增强（低优先级）

**可选改进**：
1. 支持更多CLI版本的参数选项
2. 增强交互式体验
3. 完善文档和测试覆盖

## 📊 入口点对比

| 特性 | 根目录 main.go | cmd/cli/main.go |
|------|---------------|-----------------|
| **目标用户** | 新手用户、快速体验 | 专业用户、自动化 |
| **学习成本** | 零成本 | 中等 |
| **功能完整度** | 基础功能 | 完整功能 |
| **配置支持** | ⚠️ 改进中 | ✅ 完整支持 |
| **自动化支持** | ⚠️ 基础支持 | ✅ 完整支持 |
| **交互体验** | 强制交互 | 可选交互 |

## 💡 使用建议

### 🟢 推荐使用根目录 main.go
- 个人项目文档生成
- 快速原型验证
- 教学和演示场景
- 不喜欢复杂命令的用户

### 🟢 推荐使用 cmd/cli/main.go
- 企业级项目和团队协作
- 自动化构建和部署
- 需要精细控制的场景
- 专业开发者和高级用户

## 🔧 快速开始

### 根目录版本（改进后）
```bash
# 快速体验（交互模式）
go run main.go

# 指定格式和输出
go run main.go -f markdown -o project-docs.md

# 使用配置文件
echo "filters:" > config.yaml
echo "  exclude_patterns:" >> config.yaml
echo "    - \"*.log\"" >> config.yaml
go run main.go -f markdown -o docs.md
```

### CLI版本
```bash
# 基本使用
go run cmd/cli/main.go generate -f markdown -o docs.md

# 高级过滤
go run cmd/cli/main.go generate \
  -f markdown \
  -o docs.md \
  --exclude-patterns "*_test.go,*.tmp" \
  --max-depth 3

# 配置管理
go run cmd/cli/main.go config show
```

## 📈 改进进展

### 当前状态
- ✅ 问题分析和方案设计完成
- ✅ 改进实施计划制定
- ✅ 使用指南编写
- 🔄 等待代码实施

### 下一步行动
1. **代码实施**：按照 `improvement-implementation-plan.md` 修改根目录 `main.go`
2. **测试验证**：确保改进后的功能正常工作
3. **文档更新**：根据实际实施结果更新文档
4. **用户反馈**：收集用户使用反馈，持续优化

## 🤝 贡献指南

欢迎贡献改进建议：

1. **问题反馈**：在使用中发现问题请提交issue
2. **功能建议**：有新的功能想法欢迎讨论
3. **文档改进**：发现文档问题可以提交修改
4. **代码贡献**：欢迎提交PR改进代码质量

## 📞 联系方式

如有问题或建议，请通过以下方式联系：
- 提交GitHub Issue
- 查看项目文档
- 参考使用指南

---

**注意**：本文档描述的是改进计划，具体实施可能需要根据实际情况调整。建议在实施前充分测试，确保不影响现有功能。
```

### improvement-implementation-plan.md

- **路径**: `D:\ide\tool\code-context-generator\docs\plan\improvement-implementation-plan.md`
- **大小**: 6755 字节
- **修改时间**: 2025-10-02T09:55:59+08:00

```md
# 配置复用改进实施计划

## 目标
解决根目录 `main.go` 未使用配置文件、忽略规则和环境变量的问题，使其与 `cmd/cli/main.go` 保持一致的行为和输出质量。

## 修改方案

### 1. 修改根目录 main.go - 配置加载

**修改前**（当前代码片段）：
```go
func main() {
    // 解析命令行参数
    var format, outputFile string
    var showHelp bool
    
    args := os.Args[1:]
    for i := 0; i < len(args); i++ {
        // ... 参数解析逻辑
    }
    
    if showHelp {
        // ... 帮助信息
    }
    
    // 硬编码的配置
    selectOptions := &types.SelectOptions{
        Recursive:       true,
        ShowHidden:      false,
        MaxDepth:        0,
        IncludePatterns: []string{},
        ExcludePatterns: []string{".git", "node_modules", "*.exe", "*.dll"}, // 硬编码排除规则
    }
    // ...
}
```

**修改后**（建议实现）：
```go
func main() {
    // 首先加载.env文件（如果存在）
    if err := env.LoadEnv(""); err != nil {
        log.Printf("警告: 加载.env文件失败: %v", err)
    }

    // 解析命令行参数
    var format, outputFile string
    var showHelp bool
    
    args := os.Args[1:]
    for i := 0; i < len(args); i++ {
        // ... 参数解析逻辑
    }
    
    if showHelp {
        // ... 帮助信息
    }
    
    // 创建配置管理器并加载配置
    configManager := config.NewManager()
    
    // 尝试加载配置文件
    defaultConfigPath := "config.yaml"
    if err := configManager.Load(defaultConfigPath); err != nil {
        log.Printf("警告: 加载配置文件失败，使用默认配置: %v", err)
    }
    
    cfg := configManager.Get()
    
    // 使用配置中的设置
    selectOptions := &types.SelectOptions{
        Recursive:       cfg.FileProcessing.Recursive,
        ShowHidden:      cfg.FileProcessing.IncludeHidden,
        MaxDepth:        cfg.Filters.MaxDepth,
        IncludePatterns: cfg.Filters.IncludePatterns,
        ExcludePatterns: cfg.Filters.ExcludePatterns, // 使用配置文件中的排除规则
    }
    // ...
}
```

### 2. 修改根目录 main.go - 文件系统遍历

**修改前**：
```go
// 使用简单的文件遍历
walker := filesystem.NewFileSystemWalker(types.WalkOptions{})
result, err := walker.Walk(currentDir, selectOptions)
```

**修改后**：
```go
// 使用与CLI版本一致的文件系统遍历器
walker := filesystem.NewFileSystemWalker(types.WalkOptions{})

walkOptions := &types.WalkOptions{
    MaxDepth:        cfg.Filters.MaxDepth,
    MaxFileSize:     cfg.Filters.MaxFileSize,
    ExcludePatterns: cfg.Filters.ExcludePatterns,
    IncludePatterns: cfg.Filters.IncludePatterns,
    FollowSymlinks:  cfg.Filters.FollowSymlinks,
    ShowHidden:      cfg.FileProcessing.IncludeHidden,
    ExcludeBinary:   cfg.Filters.ExcludeBinary,
}

result, err := walker.Walk(currentDir, walkOptions)
```

### 3. 修改根目录 main.go - 输出标准化

**修改前**：
```go
// 格式化并直接输出
outputData, err := formatter.Format(contextData)
if err != nil {
    log.Fatalf("格式化输出失败: %v", err)
}

// 保存到文件
if err := os.WriteFile(finalOutputFile, []byte(outputData), 0644); err != nil {
    log.Fatalf("写入输出文件失败: %v", err)
}
```

**修改后**：
```go
// 格式化输出后，使用标准化处理
outputData, err := formatter.Format(contextData)
if err != nil {
    log.Fatalf("格式化输出失败: %v", err)
}

// 标准化换行符为当前操作系统格式
normalizedData := utils.NormalizeLineEndings(outputData)

// 保存到文件
if err := os.WriteFile(finalOutputFile, []byte(normalizedData), 0644); err != nil {
    log.Fatalf("写入输出文件失败: %v", err)
}
```

### 4. 修改根目录 main.go - 错误处理增强

**修改前**：
```go
// 简单的错误处理
if err != nil {
    log.Fatalf("文件选择失败: %v", err)
}
```

**修改后**：
```go
// 增强的错误处理和日志记录
if err != nil {
    if verbose {
        log.Printf("详细错误信息: %+v", err)
    }
    log.Fatalf("文件选择失败: %v", err)
}
```

## 实施步骤

### 步骤 1: 添加必要的导入

在根目录 `main.go` 的导入部分添加：
```go
import (
    // ... 现有导入
    "github.com/yourusername/code-context-generator/internal/config"
    "github.com/yourusername/code-context-generator/internal/env"
    "github.com/yourusername/code-context-generator/internal/utils"
)
```

### 步骤 2: 修改主函数结构

1. 在 `main()` 函数开始处添加配置加载
2. 修改 `selectOptions` 的创建逻辑
3. 更新文件系统遍历调用
4. 添加输出标准化处理

### 步骤 3: 测试验证

1. **配置加载测试**：
   ```bash
   # 创建测试配置文件
   echo "filters:" > config.yaml
   echo "  exclude_patterns:" >> config.yaml
   echo "    - \"*.log\"" >> config.yaml
   echo "    - \"*.tmp\"" >> config.yaml
   
   # 测试配置是否生效
   go run main.go -f markdown -o test.md
   ```

2. **环境变量测试**：
   ```bash
   # 设置环境变量
   $env:CCG_MAX_DEPTH="2"
   
   # 测试环境变量是否生效
   go run main.go -f markdown -o test.md
   ```

3. **输出一致性测试**：
   ```bash
   # 使用相同参数测试两个入口点
   go run main.go -f markdown -o simple.md
   go run cmd/cli/main.go generate -f markdown -o cli.md
   
   # 比较输出文件
   fc simple.md cli.md
   ```

## 预期效果

### 改进前的问题
- ❌ 根目录版本忽略 `.git` 等目录，但使用硬编码规则
- ❌ 不支持配置文件中的自定义忽略规则
- ❌ 不支持环境变量配置
- ❌ 输出格式可能与CLI版本不一致

### 改进后的效果
- ✅ 正确加载和使用配置文件
- ✅ 支持环境变量配置
- ✅ 使用与CLI版本一致的忽略规则和处理逻辑
- ✅ 输出文件格式和质量保持一致
- ✅ 保持简单易用的特点

## 注意事项

1. **向后兼容性**：确保修改后不影响现有用户的使用习惯
2. **错误处理**：配置加载失败时应优雅降级，使用合理默认值
3. **性能考虑**：配置加载不应显著影响启动时间
4. **日志级别**：提供适当的日志输出，既不过于冗长也不过于简略

## 后续优化

1. **参数统一**：逐步支持更多CLI版本的参数选项
2. **功能增强**：在保持简洁的前提下添加实用功能
3. **文档完善**：更新相关文档，说明配置使用方法
4. **测试覆盖**：为配置加载和使用添加单元测试

通过实施这个改进计划，可以使根目录 `main.go` 在保持简单易用的同时，充分利用项目的配置体系和工具链，提供与专业CLI版本一致的高质量输出。
```

### usage-guidelines.md

- **路径**: `D:\ide\tool\code-context-generator\docs\plan\usage-guidelines.md`
- **大小**: 6699 字节
- **修改时间**: 2025-10-02T17:15:26+08:00

```md
# 双入口点使用指南

## 概述

代码上下文生成器项目提供两个不同的程序入口点，分别针对不同的使用场景和用户需求设计。本指南帮助用户选择最适合的入口点，并提供最佳实践建议。

## 入口点对比

| 特性 | 根目录 main.go | cmd/cli/main.go |
|------|---------------|-----------------|
| **设计理念** | 简单直观，零学习成本 | 功能完整，专业级工具 |
| **使用复杂度** | ⭐（简单） | ⭐⭐⭐（中等） |
| **功能丰富度** | ⭐⭐（基础） | ⭐⭐⭐⭐⭐（完整） |
| **配置支持** | ⚠️（需要改进） | ✅（完整支持） |
| **自动化支持** | ⚠️（基础支持） | ✅（完整支持） |
| **交互体验** | ✅（强制交互） | ✅（可选交互） |

## 使用场景指南

### 🎯 何时使用根目录 main.go

#### 适用场景
- **快速体验**：第一次使用，想快速了解功能
- **简单需求**：只需要基本的代码上下文生成
- **交互偏好**：喜欢通过交互式界面选择文件和格式
- **临时使用**：偶尔使用，不想记忆复杂命令
- **教学演示**：向他人展示基本功能

#### 推荐命令
```bash
# 快速生成（进入交互模式）
go run main.go

# 指定格式和输出文件（跳过交互）
go run main.go -f markdown -o project-docs.md

# 查看帮助
go run main.go -h
```

#### 优点
- ✅ 零学习成本
- ✅ 强制交互，避免遗漏重要选择
- ✅ 代码量少，启动快速
- ✅ 适合新用户上手

#### 局限性
- ⚠️ 配置复用有限（需要改进）
- ⚠️ 高级功能缺失
- ⚠️ 自动化脚本支持有限

### 🎯 何时使用 cmd/cli/main.go

#### 适用场景
- **专业使用**：需要完整的功能集和配置管理
- **自动化集成**：CI/CD 流程、构建脚本
- **批量处理**：需要处理多个项目或复杂过滤规则
- **团队协作**：需要标准化配置和一致输出
- **高级需求**：需要递归控制、文件过滤、内容包含等高级功能

#### 推荐命令
```bash
# 基本生成（使用配置文件）
go run cmd/cli/main.go generate -f markdown -o docs.md

# 高级过滤（排除测试文件，限制深度）
go run cmd/cli/main.go generate \
  -f markdown \
  -o docs.md \
  --exclude-patterns "*_test.go,*.tmp" \
  --max-depth 3

# 配置管理
go run cmd/cli/main.go config show
go run cmd/cli/main.go config set output.format markdown

```

#### 优点
- ✅ 完整的配置体系支持
- ✅ 丰富的命令和参数选项
- ✅ 强大的过滤和处理能力
- ✅ 适合自动化和脚本集成
- ✅ 团队协作标准化

#### 学习成本
- ⚠️ 需要理解命令结构
- ⚠️ 参数选项较多

## 配置使用最佳实践

### 根目录 main.go（改进后）

1. **创建配置文件**（`config.yaml`）：
```yaml
# 文件处理设置
file_processing:
  recursive: true
  include_hidden: false

# 过滤规则
filters:
  max_depth: 0  # 0表示无限制
  max_file_size: 10485760  # 10MB
  exclude_patterns:
    - "*.log"
    - "*.tmp"
    - "node_modules"
    - ".git"
    - "*.exe"
    - "*.dll"
  include_patterns: []
  exclude_binary: true
  follow_symlinks: false

# 输出设置
output:
  format: markdown
  include_content: true
  max_content_size: 1048576  # 1MB
  include_metadata: true
```

2. **使用环境变量**：
```bash
# Windows (PowerShell)
$env:CCG_MAX_DEPTH="3"
$env:CCG_EXCLUDE_BINARY="true"

# Linux/Mac
export CCG_MAX_DEPTH=3
export CCG_EXCLUDE_BINARY=true
```

### cmd/cli/main.go

1. **配置文件位置**：
   - 默认：`config.yaml`（当前目录）
   - 自定义：`--config path/to/config.yaml`
   - 全局：`~/.code-context-generator/config.yaml`

2. **配置管理命令**：
```bash
# 查看当前配置
go run cmd/cli/main.go config show

# 设置配置项
go run cmd/cli/main.go config set filters.max_depth 3
go run cmd/cli/main.go config set output.format json

# 重置配置
go run cmd/cli/main.go config reset
```

## 迁移指南

### 从简单入口迁移到专业入口

如果你发现需要更多功能，可以平滑迁移：

1. **保持配置文件**：两个入口点使用相同的配置文件格式
2. **参数映射**：
   ```bash
   # 简单版本
   go run main.go -f markdown -o docs.md
   
   # 专业版本（等效）
   go run cmd/cli/main.go generate -f markdown -o docs.md
   ```

3. **逐步采用高级功能**：
   ```bash
   # 添加过滤
   go run cmd/cli/main.go generate -f markdown -o docs.md --exclude-patterns "*.log"
   
   # 使用配置
   go run cmd/cli/main.go generate --config my-config.yaml
   ```

## 常见问题

### Q: 两个入口点生成的输出有区别吗？

**A**: 在配置复用改进完成后，两个入口点使用相同的配置和处理逻辑，生成的输出应该是一致的。当前根目录版本需要改进配置加载。

### Q: 应该选择哪个入口点？

**A**: 
- **新手用户**：从根目录 `main.go` 开始
- **简单使用**：根目录 `main.go` 足够
- **专业需求**：使用 `cmd/cli/main.go`
- **自动化场景**：必须使用 `cmd/cli/main.go`

### Q: 可以同时使用两个入口点吗？

**A**: 可以，它们是完全独立的程序。但要注意：
- 使用相同的配置文件避免重复配置
- 输出文件路径避免冲突
- 理解各自的参数差异

### Q: 如何确保配置一致性？

**A**: 
1. 使用版本控制管理配置文件
2. 在团队内标准化配置模板
3. 使用 `cmd/cli/main.go` 的配置管理功能
4. 定期检查和同步配置

## 性能对比

| 场景 | 根目录 main.go | cmd/cli/main.go |
|------|---------------|-----------------|
| **启动时间** | 快（代码简单） | 稍慢（框架加载） |
| **小项目处理** | 高效 | 高效 |
| **大项目处理** | 中等 | 优化更好 |
| **内存使用** | 较低 | 中等 |
| **并发处理** | 基础 | 支持并发 |

## 总结建议

### 🟢 推荐使用根目录 main.go 的情况
- 个人项目文档生成
- 快速原型和验证
- 教学和演示场景
- 不喜欢复杂命令的用户

### 🟢 推荐使用 cmd/cli/main.go 的情况
- 企业级项目和团队协作
- 自动化构建和部署
- 需要精细控制的场景
- 专业开发者和高级用户

### 🔧 最佳实践
1. **新手起步**：从根目录 `main.go` 开始，快速上手
2. **需求增长**：逐步迁移到 `cmd/cli/main.go` 获得更多功能
3. **团队协作**：统一使用 `cmd/cli/main.go` 和标准化配置
4. **配置管理**：使用版本控制管理配置文件，确保一致性

通过合理选择入口点，可以在简单性和功能性之间找到最佳平衡，提高开发效率和文档质量。
```

### dual-entry-points-analysis.md

- **路径**: `D:\ide\tool\code-context-generator\docs\plan\dual-entry-points-analysis.md`
- **大小**: 7567 字节
- **修改时间**: 2025-10-02T17:14:57+08:00

```md
# 双入口点架构分析与改进方案

## 概述

代码上下文生成器项目包含两个主要的程序入口点，分别服务于不同的使用场景和需求。本文档分析这两个入口点的关系、差异以及存在的问题，并提出改进方案。

## 入口点对比分析

### 1. 根目录 main.go（简单入口）

**路径**: `/main.go`

**特点**:
- **简单直观**: 直接运行，无需学习命令结构
- **交互式体验**: 强制文件选择和格式选择交互
- **手动参数解析**: 自定义参数解析逻辑
- **轻量级**: 代码量少，依赖简单
- **快速上手**: 适合新用户快速体验功能

**支持的命令格式**:
```bash
go run main.go [generate] -f markdown -o output.md
go run main.go -h
go run main.go  # 进入交互式模式
```

**优点**:
- 零学习成本
- 交互式体验友好
- 快速验证功能

**缺点**:
- 功能相对简单
- 配置复用不足
- 扩展性有限

### 2. cmd/cli/main.go（专业CLI）

**路径**: `/cmd/cli/main.go`

**特点**:
- **专业CLI框架**: 基于Cobra构建的完整命令行应用
- **丰富的命令结构**: 支持generate、config等子命令
- **完善的参数体系**: 支持长参数、短参数、默认值、参数验证
- **配置管理**: 支持配置文件加载和环境变量
- **高级功能**: 支持递归控制、文件过滤、内容包含等高级选项

**支持的命令格式**:
```bash
go run cmd/cli/main.go generate -f markdown -o output.md --max-depth 3
go run cmd/cli/main.go config show
```

**优点**:
- 功能完整丰富
- 配置复用充分
- 扩展性强
- 适合自动化脚本

**缺点**:
- 学习成本相对较高
- 需要理解命令结构

## 当前存在的问题

### 1. 配置复用问题

**根目录 main.go 存在的问题**:
- ❌ 未加载配置文件（config.yaml）
- ❌ 未使用环境变量中的配置
- ❌ 硬编码的排除规则（`.git`, `node_modules`等）
- ❌ 忽略规则未复用已有配置

**具体表现**:
```go
// 根目录 main.go - 硬编码配置
selectOptions := &types.SelectOptions{
    Recursive:       true,
    ShowHidden:      false,
    MaxDepth:        0,
    IncludePatterns: []string{},
    ExcludePatterns: []string{".git", "node_modules", "*.exe", "*.dll"}, // 硬编码
}
```

对比 CLI 版本的配置加载:
```go
// cmd/cli/main.go - 正确的配置加载
configManager := config.NewManager()
if configPath != "" {
    if err := configManager.Load(configPath); err != nil {
        return fmt.Errorf("加载配置文件失败: %w", err)
    }
} else {
    defaultConfigPath := "config.yaml"
    configManager.Load(defaultConfigPath) // 忽略错误，使用默认配置
}
cfg = configManager.Get()
```

### 2. 工具复用问题

- ❌ 使用了不同的文件系统遍历器
- ❌ 未复用CLI版本的高级功能（如文件内容读取、哈希计算）
- ❌ 缺少标准化处理（如换行符标准化）

### 3. 用户体验不一致

- ❌ 两个入口点的参数格式不完全兼容
- ❌ 输出格式和处理逻辑有差异
- ❌ 错误处理机制不同

## 改进方案

### 方案一：配置复用改进

修改根目录 `main.go`，使其正确加载和使用配置：

```go
func main() {
    // 首先加载.env文件（如果存在）
    if err := env.LoadEnv(""); err != nil {
        log.Printf("警告: 加载.env文件失败: %v", err)
    }

    // 创建配置管理器并加载配置
    configManager := config.NewManager()
    
    // 尝试加载配置文件
    defaultConfigPath := "config.yaml"
    if err := configManager.Load(defaultConfigPath); err != nil {
        log.Printf("警告: 加载配置文件失败，使用默认配置: %v", err)
    }
    
    cfg := configManager.Get()
    
    // 使用配置中的设置
    selectOptions := &types.SelectOptions{
        Recursive:       cfg.FileProcessing.Recursive,
        ShowHidden:      cfg.FileProcessing.IncludeHidden,
        MaxDepth:        cfg.Filters.MaxDepth,
        IncludePatterns: cfg.Filters.IncludePatterns,
        ExcludePatterns: cfg.Filters.ExcludePatterns, // 使用配置文件中的排除规则
    }
    
    // ... 其余代码
}
```

### 方案二：工具复用改进

统一使用CLI版本的文件系统遍历器和处理逻辑：

```go
// 替换原有的walker使用方式
walker := filesystem.NewFileSystemWalker(types.WalkOptions{})

walkOptions := &types.WalkOptions{
    MaxDepth:        cfg.Filters.MaxDepth,
    MaxFileSize:     cfg.Filters.MaxFileSize,
    ExcludePatterns: cfg.Filters.ExcludePatterns,
    IncludePatterns: cfg.Filters.IncludePatterns,
    FollowSymlinks:  cfg.Filters.FollowSymlinks,
    ShowHidden:      cfg.FileProcessing.IncludeHidden,
    ExcludeBinary:   cfg.Filters.ExcludeBinary,
}

result, err := walker.Walk(currentDir, walkOptions)
```

### 方案三：参数标准化

使根目录版本的参数与CLI版本保持一致：

```go
// 支持更多CLI版本的参数
var (
    format, outputFile string
    showHelp, verbose bool
    maxDepth int
    excludeBinary bool
)

// 解析更多参数
for i := 0; i < len(args); i++ {
    arg := args[i]
    switch arg {
    case "-f", "--format":
        if i+1 < len(args) {
            format = args[i+1]
            i++
        }
    case "-o", "--output":
        if i+1 < len(args) {
            outputFile = args[i+1]
            i++
        }
    case "-v", "--verbose":
        verbose = true
    case "--max-depth":
        if i+1 < len(args) {
            maxDepth, _ = strconv.Atoi(args[i+1])
            i++
        }
    case "--exclude-binary":
        excludeBinary = true
    case "-h", "--help":
        showHelp = true
    case "generate":
        // 忽略generate参数
    }
}
```

### 方案四：输出标准化

使用CLI版本的输出标准化处理：

```go
// 格式化输出后，使用标准化处理
outputData, err := formatter.Format(contextData)
if err != nil {
    log.Fatalf("格式化输出失败: %v", err)
}

// 标准化换行符为当前操作系统格式
normalizedData := utils.NormalizeLineEndings(outputData)

// 保存到文件
if err := os.WriteFile(finalOutputFile, []byte(normalizedData), 0644); err != nil {
    log.Fatalf("写入输出文件失败: %v", err)
}
```

## 推荐实施策略

### 阶段一：配置复用（高优先级）
1. 修改根目录 `main.go` 加载配置文件
2. 使用配置中的忽略规则和扫描参数
3. 保持向后兼容性

### 阶段二：工具统一（中优先级）
1. 统一文件系统遍历器使用
2. 标准化输出处理
3. 错误处理机制统一

### 阶段三：功能增强（低优先级）
1. 添加更多CLI版本的参数支持
2. 增强交互式体验
3. 完善帮助文档

## 实施建议

1. **保持简单入口的简洁性**：即使改进配置复用，也要保持根目录版本的简单易用特点
2. **渐进式改进**：分阶段实施，避免一次性大幅修改导致稳定性问题
3. **充分测试**：每个阶段都要充分测试，确保不影响现有功能
4. **文档同步**：更新相关文档，说明两个入口点的差异和使用场景

## 使用建议

### 何时使用根目录 main.go
- 快速体验功能
- 简单的交互式使用
- 不需要复杂配置的场景
- 新用户初次使用

### 何时使用 cmd/cli/main.go
- 需要自动化脚本
- 复杂的文件过滤和处理需求
- 需要配置文件管理
- 专业用户和高级功能需求

通过合理的架构设计和渐进式改进，可以让两个入口点各自发挥优势，为不同需求的用户提供最佳的使用体验。
```

### temp

- **路径**: `D:\ide\tool\code-context-generator\docs\prompt\temp`
- **大小**: 1620 字节
- **修改时间**: 2025-10-02T17:07:03+08:00

**[二进制文件 - 内容未显示]**

### 输出格式配置.txt

- **路径**: `D:\ide\tool\code-context-generator\docs\prompt\输出格式配置.txt`
- **大小**: 472 字节
- **修改时间**: 2025-09-30T20:56:37+08:00

```txt
本项目的目的是使用go语言实现一个能方便的通过终端选择文件/文件夹，
并将选中的文件的相对路径与内容打包为结构化的文件（如xml/json/md等），
快速整合文件内容，跨文件构建上下文，方便用户将多个文件的内容快速转为提示词。

采用统一配置文件的方案，并添加对yml/toml的支持，并尽量通过go标准库输出相应文件，规则配置也应当与go标准库对齐
```

### quickstart.md

- **路径**: `D:\ide\tool\code-context-generator\docs\quickstart.md`
- **大小**: 1897 字节
- **修改时间**: 2025-10-02T17:13:54+08:00

```md
# 🚀 快速入门指南

## 安装

### 从源码编译
```bash
git clone https://github.com/yourusername/code-context-generator.git
cd code-context-generator
go build -o code-context-generator cmd/cli/main.go
```

## 基础使用

### 扫描当前目录
```bash
./code-context-generator generate
```

### 扫描指定目录
```bash
./code-context-generator generate /path/to/your/project
```

### 指定输出格式
```bash
# Markdown格式
./code-context-generator generate -f markdown -o project.md

# XML格式
./code-context-generator generate -f xml -o project.xml
```

### 智能格式覆盖
```bash
# 使用config-json.yaml自动应用JSON格式
./code-context-generator generate -c config-json.yaml

# 使用config-xml.yaml自动应用XML格式  
./code-context-generator generate -c config-xml.yaml
```

### 包含文件内容
```bash
./code-context-generator generate -C -o context.json
```

## 常用命令

### 文件过滤
```bash
# 排除特定文件
./code-context-generator generate -e "*.log" -e "node_modules"

# 只包含特定扩展名
./code-context-generator generate -i "*.go" -i "*.md"

# 限制文件大小（10MB）
./code-context-generator generate -s 10485760
```



## 配置文件

### 创建默认配置
```bash
./code-context-generator config init
```

### 基础配置示例
```toml
[output]
format = "json"

[file_processing]
max_file_size = 10485760  # 10MB
exclude_patterns = ["*.log", "node_modules", ".git"]
```

### 智能格式覆盖配置
工具支持基于配置文件名的智能格式识别：
- `config-json.yaml` - 自动应用 JSON 格式配置
- `config-xml.yaml` - 自动应用 XML 格式配置
- `config-toml.yaml` - 自动应用 TOML 格式配置
- `config-markdown.yaml` - 自动应用 Markdown 格式配置

例如，创建 `config-json.yaml` 文件时，工具会自动设置 `output.format = "json"` 并应用 JSON 相关的配置选项。
```

### 说明.txt

- **路径**: `D:\ide\tool\code-context-generator\docs\说明.txt`
- **大小**: 145 字节
- **修改时间**: 2025-10-02T17:16:15+08:00

```txt
当前项目存在3种使用模式：
1.根目录main.go：简单的cli操作
2.cli


xml输出时会把符号转义为标记，避免歧义
```

### usage.md

- **路径**: `D:\ide\tool\code-context-generator\docs\usage.md`
- **大小**: 4210 字节
- **修改时间**: 2025-10-02T17:13:16+08:00

```md
# 📖 使用文档

## 功能特性

### 核心功能
- **多格式输出**: 支持JSON、XML、Markdown、TOML格式
- **智能文件过滤**: 基于扩展名和内容分析的二进制文件检测
- **内容提取**: 可选择性包含文件内容

### 高级特性
- **多线程处理**: 并行扫描提升性能
- **配置文件**: 支持TOML格式配置
- **路径匹配**: 支持通配符和正则表达式

## 安装

### 前置要求
- Go 1.24或更高版本
- Git（用于源码安装）

### 从源码安装
```bash
git clone https://github.com/yourusername/code-context-generator.git
cd code-context-generator
go build -o code-context-generator cmd/cli/main.go
```

## CLI使用指南

### 基本用法
```bash
# 扫描当前目录
./code-context-generator generate

# 扫描指定目录
./code-context-generator generate /path/to/project

# 指定输出格式
./code-context-generator generate -f markdown -o output.md
```

### 高级用法
```bash
# 包含文件内容
./code-context-generator generate -C -o context.json

# 排除特定文件
./code-context-generator generate -e "*.log" -e "node_modules"

# 只包含特定扩展名
./code-context-generator generate -i "*.go" -i "*.md"

# 限制文件大小（10MB）
./code-context-generator generate -s 10485760

# 限制扫描深度
./code-context-generator generate -d 3
```



### 配置管理
```bash
# 创建默认配置
./code-context-generator config init

# 使用自定义配置
./code-context-generator generate -c config.toml

# 使用智能格式覆盖配置
./code-context-generator generate -c config-json.yaml  # 自动使用JSON格式
./code-context-generator generate -c config-xml.yaml  # 自动使用XML格式
```

## 配置文件

### 智能格式覆盖
工具支持基于配置文件名的智能格式识别功能。当配置文件名包含特定格式关键词时，会自动应用对应的格式配置：

- `config-json.yaml` - 自动设置 `output.format = "json"`
- `config-xml.yaml` - 自动设置 `output.format = "xml"`
- `config-toml.yaml` - 自动设置 `output.format = "toml"`
- `config-markdown.yaml` 或 `config-md.yaml` - 自动设置 `output.format = "markdown"`

### 基础配置
```toml
[output]
format = "json"
encoding = "utf-8"

[file_processing]
max_file_size = 10485760  # 10MB
exclude_patterns = ["*.log", "node_modules", ".git"]
```

### 高级配置
```toml
[output]
format = "json"
pretty = true

[file_processing]
include_content = true
include_hash = true
max_file_size = 52428800  # 50MB
max_depth = 5
workers = 4
exclude_patterns = [
    "*.exe", "*.dll", "*.so", "*.dylib",
    "*.pyc", "*.pyo", "*.pyd",
    "node_modules", ".git", ".svn", ".hg",
    "__pycache__", "*.egg-info", "dist", "build"
]

[formats.json]
indent = "  "
sort_keys = true

[formats.markdown]
include_toc = true
```

## 命令参数详解

### generate命令
- `-f, --format`: 输出格式（json, xml, markdown, toml）
- `-o, --output`: 输出文件路径
- `-C, --content`: 包含文件内容
- `-H, --hash`: 包含文件哈希值
- `-e, --exclude`: 排除模式（可多次使用）
- `-i, --include`: 包含模式（可多次使用）
- `-s, --max-size`: 最大文件大小
- `-d, --max-depth`: 最大扫描深度
- `-c, --config`: 配置文件路径

### config命令
- `init`: 创建默认配置文件
- `validate`: 验证配置文件

## 实用示例

### 扫描Go项目
```bash
./code-context-generator generate -e "vendor" -f json -o go-project.json
```

### 扫描Python项目
```bash
./code-context-generator generate -e "venv" -e "__pycache__" -f markdown -o python-project.md
```

### 生成项目文档
```bash
./code-context-generator generate -C -H -f markdown -o documentation.md
```

## 故障排除

### 常见问题

**权限错误**: `permission denied`
```bash
chmod +x code-context-generator  # Linux/macOS
```

**找不到命令**: `command not found`
```bash
./code-context-generator  # 使用完整路径
```

**输出文件太大**: 
```bash
./code-context-generator generate -s 1048576  # 限制文件大小
```

### 调试模式
```bash
./code-context-generator generate --debug
```

### 获取帮助
```bash
./code-context-generator --help
./code-context-generator generate --help
```
```

### go.mod

- **路径**: `D:\ide\tool\code-context-generator\go.mod`
- **大小**: 212 字节
- **修改时间**: 2025-10-02T17:37:29+08:00

**[二进制文件 - 内容未显示]**

### go.sum

- **路径**: `D:\ide\tool\code-context-generator\go.sum`
- **大小**: 1556 字节
- **修改时间**: 2025-10-02T17:38:17+08:00

**[二进制文件 - 内容未显示]**

### performance-optimized.toml

- **路径**: `D:\ide\tool\code-context-generator\examples\performance-optimized.toml`
- **大小**: 2873 字节
- **修改时间**: 2025-10-01T00:05:15+08:00

```toml
# 代码上下文生成器 - 性能优化配置
# 适用于大型项目或需要高性能处理的场景

[output]
format = "json"          # 使用JSON格式，解析速度最快
encoding = "utf-8"
pretty = false           # 禁用美化输出，提高性能
output_dir = "./output"
filename_template = "fast_scan_{{.Timestamp}}.json"

[file_processing]
include_hidden = false
include_content = false  # 不包含文件内容，大幅提高性能
include_hash = false     # 不计算哈希值，节省CPU时间
max_file_size = 1048576  # 限制1MB，避免处理大文件
max_depth = 3            # 限制扫描深度，减少文件数量
buffer_size = 16384      # 增大缓冲区，提高I/O效率
workers = 12             # 增加工作线程数（根据CPU核心数调整）

# 最小化排除模式，只排除最常见的文件
exclude_patterns = [
    # 大文件和二进制
    "*.exe", "*.dll", "*.so", "*.dylib",
    
    # 依赖目录（通常很大）
    "node_modules", "vendor", ".git",
    
    # 临时文件
    "*.tmp", "*.temp", "*.log",
    
    # 构建产物
    "dist", "build", "target"
]

include_patterns = []  # 不排除任何特定类型的文件

[ui]
theme = "default"
show_progress = true     # 显示进度，了解处理状态
show_size = false        # 不显示大小，节省计算时间
show_date = false        # 不显示日期，节省计算时间
show_preview = false     # 不显示预览，节省内存
auto_complete = false    # 禁用自动补全，提高响应速度

[performance]
cache_enabled = true     # 启用缓存，提高重复扫描性能
cache_size = 500         # 增大缓存大小
memory_limit = 536870912  # 限制512MB内存使用
aggressive_gc = true     # 启用激进的垃圾回收

[logging]
level = "warn"           # 只记录警告和错误，减少I/O
file_path = ""           # 控制台输出，避免文件I/O
max_size = 10
max_backups = 3
max_age = 7

[formats.json]
enabled = true
indent = ""              # 无缩进，最小化输出大小
sort_keys = false        # 不排序键，提高性能
escape_html = false

[formats.xml]
enabled = false          # 禁用不使用的格式，节省内存

[formats.toml]
enabled = false          # 禁用不使用的格式，节省内存

[formats.markdown]
enabled = false          # 禁用不使用的格式，节省内存

# 性能监控配置
[monitoring]
enable_metrics = true    # 启用性能指标收集
memory_tracking = true   # 跟踪内存使用情况
time_tracking = true     # 跟踪处理时间
file_count_tracking = true  # 跟踪文件数量

# 快速扫描模式
[fast_mode]
enabled = true           # 启用快速模式
skip_symlinks = true     # 跳过符号链接
skip_empty_dirs = true   # 跳过空目录
parallel_walk = true     # 启用并行目录遍历
early_termination = false  # 禁用早期终止（确保完整性）
```

### basic-config.toml

- **路径**: `D:\ide\tool\code-context-generator\examples\basic-config.toml`
- **大小**: 3091 字节
- **修改时间**: 2025-10-01T00:04:08+08:00

```toml
# 代码上下文生成器 - 基础配置文件示例
# 适用于大多数项目的标准配置

[output]
format = "json"          # 输出格式: json, xml, toml, markdown
encoding = "utf-8"       # 文件编码
pretty = true            # 美化输出
output_dir = "./output"  # 输出目录
filename_template = "context_{{.Timestamp}}.{{.Format}}"  # 文件名模板

[file_processing]
include_hidden = false   # 是否包含隐藏文件
include_content = false  # 是否包含文件内容
include_hash = false     # 是否包含文件哈希值
max_file_size = 10485760  # 最大文件大小 (10MB)
max_depth = 0            # 最大扫描深度 (0表示无限制)
buffer_size = 8192       # 缓冲区大小
workers = 4              # 并发工作线程数

# 排除模式 (支持glob模式)
exclude_patterns = [
    # 编译产物
    "*.exe", "*.dll", "*.so", "*.dylib", "*.a", "*.lib",
    
    # Python
    "*.pyc", "*.pyo", "*.pyd", "__pycache__", "*.egg-info", ".pytest_cache",
    
    # Node.js
    "node_modules", "npm-debug.log", "yarn-error.log", ".npm", ".yarn",
    
    # 版本控制
    ".git", ".svn", ".hg", ".bzr", "_darcs", "CVS",
    
    # IDE和编辑器
    ".vscode", ".idea", "*.swp", "*.swo", "*~", ".DS_Store", "Thumbs.db",
    
    # 临时文件
    "*.tmp", "*.temp", "*.log", "*.bak", "*.backup",
    
    # 构建目录
    "dist", "build", "target", "out", "bin", "obj",
    
    # 依赖管理
    "vendor", "packages", "composer.lock", "package-lock.json",
    
    # 文档生成
    "docs/_build", "site", ".tox"
]

# 包含模式 (如果指定，则只包含匹配的文件)
include_patterns = []

[ui]
theme = "default"        # 界面主题
show_progress = true     # 显示进度条
show_size = true         # 显示文件大小
show_date = true         # 显示修改日期
show_preview = true      # 显示预览
auto_complete = true     # 自动补全
confirm_deletion = true  # 删除确认

[performance]
cache_enabled = true     # 启用缓存
cache_size = 100         # 缓存大小
memory_limit = 1073741824  # 内存限制 (1GB)

[logging]
level = "info"           # 日志级别: debug, info, warn, error
file_path = ""           # 日志文件路径 (空表示控制台输出)
max_size = 10            # 日志文件最大大小 (MB)
max_backups = 3          # 保留的旧日志文件数
max_age = 7              # 日志文件保留天数

[formats.json]
enabled = true
indent = "  "
sort_keys = true
escape_html = false

[formats.xml]
enabled = true
indent = "  "
use_cdata = false
declaration = true

[formats.toml]
enabled = true
indent = "  "

[formats.markdown]
enabled = true
template = "default"     # 模板: default, compact, detailed
include_toc = true       # 包含目录
heading_level = 2        # 标题级别
code_highlight = true    # 代码高亮

# 自定义字段映射 (可选)
[field_mapping]
# path = "file_path"
# size = "file_size"
# modified = "last_modified"

# 全局字段 (可选)
[global_fields]
# project_name = "MyProject"
# version = "1.0.0"
# author = "Your Name"
# description = "Project description"
```

### usage-examples.sh

- **路径**: `D:\ide\tool\code-context-generator\examples\usage-examples.sh`
- **大小**: 4208 字节
- **修改时间**: 2025-10-02T17:33:09+08:00

```sh
#!/bin/bash

# 代码上下文生成器 - 使用示例脚本
# 该脚本展示了如何使用不同的配置文件和参数

echo "🚀 代码上下文生成器 - 使用示例"
echo "=================================="

# 检查是否已安装工具
if ! command -v ./code-context-generator &> /dev/null; then
    echo "❌ 请先编译代码上下文生成器:"
    echo "   go build -o code-context-generator cmd/cli/main.go"
    exit 1
fi

# 创建输出目录
mkdir -p output/logs

echo ""
echo "1️⃣ 基础扫描 - 使用默认配置"
echo "------------------------"
./code-context-generator generate \
    -o output/basic-scan.json

echo ""
echo "2️⃣ 使用基础配置文件"
echo "------------------"
./code-context-generator generate \
    -c examples/basic-config.toml \
    -o output/basic-config-output.json

echo ""
echo "3️⃣ 生成项目文档（包含文件内容）"
echo "--------------------------------"
./code-context-generator generate \
    -c examples/project-documentation.toml \
    -o output/project-documentation.md

echo ""
echo "4️⃣ 高性能扫描（适合大项目）"
echo "----------------------------"
./code-context-generator generate \
    -c examples/performance-optimized.toml \
    -o output/fast-scan.json

echo ""
echo "5️⃣ 自定义参数扫描"
echo "----------------"
./code-context-generator generate \
    -f xml \
    -e "node_modules" -e ".git" -e "*.log" \
    -s 1048576 \
    -d 3 \
    -o output/custom-scan.xml

echo ""
echo "6️⃣ 自动文件扫描"
echo "----------------"
echo "📝 这将自动扫描当前目录..."
./code-context-generator generate \
    -f markdown \
    -o output/auto-scan.md

echo ""
echo "7️⃣ 生成配置文件"
echo "--------------"
./code-context-generator config init \
    -o output/my-config.toml

echo ""
echo "8️⃣ 验证配置文件"
echo "--------------"
./code-context-generator config validate \
    -c examples/basic-config.toml

echo ""
echo "9️⃣ 显示当前配置"
echo "--------------"
./code-context-generator config show

echo ""
echo "🔟 性能测试"
echo "----------"
echo "📊 扫描性能测试..."
time ./code-context-generator generate \
    -c examples/performance-optimized.toml \
    -o output/performance-test.json

echo ""
echo "📋 批处理示例 - 扫描多个目录"
echo "============================="

# 定义要扫描的目录数组
PROJECT_DIRS=(
    "src"
    "internal"
    "pkg"
    "cmd"
)

for dir in "${PROJECT_DIRS[@]}"; do
    if [ -d "$dir" ]; then
        echo "📁 扫描目录: $dir"
        ./code-context-generator generate \
            "$dir" \
            -f json \
            -e "*.log" -e "*.tmp" \
            -o "output/scan_${dir//\//_}.json"
    fi
done

echo ""
echo "🔄 定时任务示例"
echo "============="

# 创建定时任务脚本
cat > output/scheduled-scan.sh << 'EOF'
#!/bin/bash
# 定时扫描脚本
DATE=$(date +%Y%m%d_%H%M%S)
PROJECT_NAME=$(basename "$PWD")

./code-context-generator generate \
    -c examples/project-documentation.toml \
    -o "backup/${PROJECT_NAME}_documentation_${DATE}.md"

echo "✅ 备份完成: backup/${PROJECT_NAME}_documentation_${DATE}.md"
EOF

chmod +x output/scheduled-scan.sh

echo "✅ 定时任务脚本已创建: output/scheduled-scan.sh"
echo "   可以添加到crontab中实现定时备份"
echo "   示例: 0 2 * * * /path/to/scheduled-scan.sh"

echo ""
echo "📊 结果统计"
echo "=========="
echo "生成的文件:"
ls -la output/ | grep -E "\.(json|xml|md|toml)$"

echo ""
echo "文件大小统计:"
du -h output/* | sort -hr

echo ""
echo "✨ 示例完成！"
echo "============"
echo "📁 输出文件保存在: output/"
echo "📝 日志文件保存在: output/logs/"
echo ""
echo "💡 提示:"
echo "   - 使用 '-c' 参数指定配置文件"
echo "   - 使用 '-f' 参数指定输出格式"
echo "   - 使用 '-e' 参数排除文件/目录"
echo "   - 使用 '-s' 参数限制文件大小"
echo "   - 使用 '-d' 参数限制扫描深度"
echo "   - 使用 '--debug' 参数启用调试模式"
echo ""
echo "📚 更多帮助:"
echo "   ./code-context-generator --help"
echo "   ./code-context-generator generate --help"
echo "   cat docs/quickstart.md"
```

### usage-examples.bat

- **路径**: `D:\ide\tool\code-context-generator\examples\usage-examples.bat`
- **大小**: 5011 字节
- **修改时间**: 2025-10-02T17:33:18+08:00

```bat
@echo off
REM 代码上下文生成器 - Windows使用示例脚本
REM 该脚本展示了如何使用不同的配置文件和参数

echo 🚀 代码上下文生成器 - Windows使用示例
echo ==================================

REM 检查是否已编译工具
if not exist "code-context-generator.exe" (
    echo ❌ 请先编译代码上下文生成器:
    echo    go build -o code-context-generator.exe cmd\cli\main.go
    exit /b 1
)

REM 创建输出目录
if not exist "output" mkdir output
if not exist "output\logs" mkdir output\logs

echo.
echo 1️⃣ 基础扫描 - 使用默认配置
echo ------------------------
code-context-generator.exe generate -o output\basic-scan.json

echo.
echo 2️⃣ 使用基础配置文件
echo ------------------
code-context-generator.exe generate -c examples\basic-config.toml -o output\basic-config-output.json

echo.
echo 3️⃣ 生成项目文档（包含文件内容）
echo --------------------------------
code-context-generator.exe generate -c examples\project-documentation.toml -o output\project-documentation.md

echo.
echo 4️⃣ 高性能扫描（适合大项目）
echo ----------------------------
code-context-generator.exe generate -c examples\performance-optimized.toml -o output\fast-scan.json

echo.
echo 5️⃣ 自定义参数扫描
echo ----------------
code-context-generator.exe generate -f xml -e "node_modules" -e ".git" -e "*.log" -s 1048576 -d 3 -o output\custom-scan.xml

echo.
echo 6️⃣ 自动文件扫描
echo ----------------
echo 📝 这将自动扫描当前目录...
code-context-generator.exe select -m -f markdown -o output\selected-files.md

echo.
echo 7️⃣ 生成配置文件
echo --------------
code-context-generator.exe config init -o output\my-config.toml

echo.
echo 8️⃣ 验证配置文件
echo --------------
code-context-generator.exe config validate -c examples\basic-config.toml

echo.
echo 9️⃣ 显示当前配置
echo --------------
code-context-generator.exe config show

echo.
echo 🔟 性能测试
echo ----------
echo 📊 扫描性能测试...
echo 开始时间: %date% %time%
code-context-generator.exe generate -c examples\performance-optimized.toml -o output\performance-test.json
echo 结束时间: %date% %time%

echo.
echo 📋 批处理示例 - 扫描常见目录
echo =============================

REM 扫描src目录（如果存在）
if exist "src" (
    echo 📁 扫描目录: src
    code-context-generator.exe generate src -f json -e "*.log" -e "*.tmp" -o output\scan_src.json
)

REM 扫描internal目录（如果存在）
if exist "internal" (
    echo 📁 扫描目录: internal
    code-context-generator.exe generate internal -f json -e "*.log" -e "*.tmp" -o output\scan_internal.json
)

REM 扫描pkg目录（如果存在）
if exist "pkg" (
    echo 📁 扫描目录: pkg
    code-context-generator.exe generate pkg -f json -e "*.log" -e "*.tmp" -o output\scan_pkg.json
)

REM 扫描cmd目录（如果存在）
if exist "cmd" (
    echo 📁 扫描目录: cmd
    code-context-generator.exe generate cmd -f json -e "*.log" -e "*.tmp" -o output\scan_cmd.json
)

echo.
echo 🔄 定时任务示例
echo =============

REM 创建定时任务脚本
echo @echo off > output\scheduled-scan.bat
echo REM 定时扫描脚本 >> output\scheduled-scan.bat
echo set DATE=%%date:~-4,4%%%%date:~-10,2%%%%date:~-7,2%%_%%time:~0,2%%%%time:~3,2%%%%time:~6,2%% >> output\scheduled-scan.bat
echo set DATE=%%DATE: =0%% >> output\scheduled-scan.bat
echo for %%%%i in ("%%cd%%") do set PROJECT_NAME=%%%%~nxi >> output\scheduled-scan.bat
echo. >> output\scheduled-scan.bat
echo code-context-generator.exe generate -c examples\project-documentation.toml -o "backup\%%PROJECT_NAME%%_documentation_%%DATE%%.md" >> output\scheduled-scan.bat
echo. >> output\scheduled-scan.bat
echo echo ✅ 备份完成: backup\%%PROJECT_NAME%%_documentation_%%DATE%%.md >> output\scheduled-scan.bat

echo ✅ 定时任务脚本已创建: output\scheduled-scan.bat
echo    可以添加到Windows任务计划程序中实现定时备份

echo.
echo 📊 结果统计
echo ==========
echo 生成的文件:
dir output\*.json output\*.xml output\*.md output\*.toml 2>nul

echo.
echo 文件大小统计:
du -h output\* 2>nul | sort /R

REM 如果没有du命令，使用替代方案
if %errorlevel% neq 0 (
    echo 使用dir命令显示文件大小:
    dir output\ /-C | findstr /R "^[0-9].*[0-9]$"
)

echo.
echo ✨ 示例完成！
echo ============
echo 📁 输出文件保存在: output\
echo 📝 日志文件保存在: output\logs\
echo.
echo 💡 提示:
echo    - 使用 '-c' 参数指定配置文件
echo    - 使用 '-f' 参数指定输出格式
echo    - 使用 '-e' 参数排除文件/目录
echo    - 使用 '-s' 参数限制文件大小
echo    - 使用 '-d' 参数限制扫描深度
echo    - 使用 '--debug' 参数启用调试模式
echo.
echo 📚 更多帮助:
echo    code-context-generator.exe --help
echo    code-context-generator.exe generate --help
echo    type docs\quickstart.md

echo.
pause
```

### project-documentation.toml

- **路径**: `D:\ide\tool\code-context-generator\examples\project-documentation.toml`
- **大小**: 3957 字节
- **修改时间**: 2025-10-01T00:04:42+08:00

```toml
# 代码上下文生成器 - 项目文档生成配置
# 适用于生成完整的项目文档，包含文件内容和结构信息

[output]
format = "markdown"      # 使用Markdown格式，便于阅读和分享
encoding = "utf-8"
pretty = true
output_dir = "./docs"    # 输出到docs目录
filename_template = "{{.ProjectName}}_documentation_{{.Date}}.md"

[file_processing]
include_hidden = false
include_content = true   # 包含文件内容，生成完整文档
include_hash = true      # 包含哈希值，用于完整性验证
max_file_size = 524288   # 最大512KB，避免包含过大的文件
max_depth = 5            # 限制扫描深度，避免过深的目录结构
buffer_size = 8192
workers = 6              # 增加工作线程数，提高处理速度

# 排除模式 - 针对文档生成优化
exclude_patterns = [
    # 大文件和二进制文件
    "*.exe", "*.dll", "*.so", "*.dylib", "*.bin", "*.dat", "*.db",
    
    # 图片和媒体文件
    "*.jpg", "*.jpeg", "*.png", "*.gif", "*.svg", "*.ico", "*.mp4", "*.mp3",
    
    # 压缩包和归档
    "*.zip", "*.rar", "*.7z", "*.tar", "*.gz", "*.bz2",
    
    # 临时文件和缓存
    "*.tmp", "*.temp", "*.cache", "*.log", "*.bak", "*.backup", "*.old",
    
    # 版本控制
    ".git", ".gitignore", ".gitattributes",
    ".svn", ".hg", ".bzr", "_darcs", "CVS",
    
    # 依赖管理
    "node_modules", "vendor", "packages", ".npm", ".yarn",
    "go.sum", "go.mod", "package-lock.json", "yarn.lock",
    
    # 构建产物
    "dist", "build", "target", "out", "bin", "obj", "lib",
    
    # IDE和编辑器配置
    ".vscode", ".idea", "*.swp", "*.swo", "*~",
    
    # 操作系统文件
    ".DS_Store", "Thumbs.db", "desktop.ini",
    
    # Python相关
    "__pycache__", "*.pyc", "*.pyo", "*.pyd",
    ".pytest_cache", "*.egg-info", ".eggs",
    
    # 测试覆盖和报告
    ".coverage", "htmlcov", "coverage.xml", ".tox",
    
    # 文档生成产物
    "docs/_build", "site", ".tox"
]

# 重点关注源代码和文档文件
include_patterns = [
    "*.go", "*.py", "*.js", "*.ts", "*.jsx", "*.tsx",
    "*.java", "*.cpp", "*.c", "*.h", "*.hpp",
    "*.rb", "*.php", "*.rs", "*.swift", "*.kt",
    "*.md", "*.txt", "*.rst", "*.adoc",
    "*.json", "*.yaml", "*.yml", "*.toml", "*.xml",
    "*.html", "*.css", "*.scss", "*.sass", "*.less",
    "*.sql", "*.sh", "*.bat", "*.ps1",
    "Makefile", "Dockerfile", "docker-compose.yml",
    "LICENSE", "README*", "CHANGELOG*", "CONTRIBUTING*"
]

[ui]
theme = "default"
show_progress = true
show_size = true
show_date = true
show_preview = true

[performance]
cache_enabled = true
cache_size = 200
memory_limit = 2147483648  # 2GB内存限制

[logging]
level = "info"
file_path = "./logs/documentation.log"
max_size = 50
max_backups = 5
max_age = 30

[formats.markdown]
enabled = true
template = "detailed"    # 使用详细模板
include_toc = true       # 包含目录，便于导航
heading_level = 1        # 从一级标题开始
code_highlight = true    # 启用代码高亮
include_metadata = true  # 包含元数据信息

# 自定义字段映射，优化文档结构
[field_mapping]
path = "文件路径"
size = "文件大小"
modified = "修改时间"
content = "文件内容"
hash = "哈希值"
extension = "文件类型"

# 全局字段，添加到每个文档
[global_fields]
documentation_type = "项目文档"
generated_by = "代码上下文生成器"
version = "1.0.0"
documentation_version = "1.0"
language = "zh-CN"

# 文档特定配置
[documentation]
project_name = "{{.ProjectName}}"  # 项目名称（自动检测）
project_description = "自动生成的项目文档"
include_file_tree = true         # 包含文件树结构
include_statistics = true          # 包含统计信息
include_summary = true             # 包含摘要信息
group_by_type = true              # 按文件类型分组
sort_by_size = false              # 按文件大小排序（false表示按路径排序）
```

### config.yaml

- **路径**: `D:\ide\tool\code-context-generator\internal\config\config.yaml`
- **大小**: 2430 字节
- **修改时间**: 2025-10-02T17:23:27+08:00

```yaml
formats:
  xml:
    enabled: true
    structure:
      file: file
      files: files
      folder: folder
      root: context
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  json:
    enabled: true
    structure:
      file: file
      folder: folder
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  toml:
    enabled: true
    structure:
      file_section: file
      folder_section: folder
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  markdown:
    enabled: true
    structure:
      code_block: "```"
      file_header: "##"
      folder_header: "###"
    fields: {}
    template: ""
    formatting:
      add_toc: false
      code_language: true
      separator: |+
        

fields:
  custom_names:
    filecontent: content
    filename: name
    filepath: path
  filter:
    include: []
    exclude: []
  processing:
    max_length: 0
    add_line_numbers: false
    trim_whitespace: true
    code_highlight: false
filters:
  max_file_size: 10MB
  exclude_patterns:
  - "*.tmp"
  - "*.log"
  - "*.swp"
  - .*
  - node_modules/
  - target/
  - dist/
  - build/
  - .env
  - .git/
  - .vscode/
  - .idea/
  - __pycache__/
  - "*.pyc"
  - .venv
  - "*.class"
  include_patterns: []
  max_depth: 0
  follow_symlinks: false
  exclude_binary: true
output:
  format: "markdown"
  encoding: "utf-8"
  includemetadata: true
  includestatistics: true
  templatepath: ""
  default_format: xml
  output_dir: ""
  filename_template: context_{{.timestamp}}.{{.extension}}
  timestamp_format: "20060102_150405"

file_processing:
  includehidden: false
  includecontent: true
  maxfilesize: "1MB"
  binarydetection: true
  encodingdetection: true
  maxdepth: 0
  excludepatterns:
    - ".git"
    - "node_modules"
    - "*.exe"
    - "*.dll"
    - "*.so"
    - "*.dylib"
    - "*.class"
    - "*.pyc"
    - "__pycache__"
    - ".DS_Store"
    - "Thumbs.db"
  includepatterns: []
  includehash: false
performance:
  maxworkers: 0
  buffersize: 4096
  cachesize: 1000
  cacheenabled: false
logging:
  level: "info"
  format: "text"
  output: "stdout"
  filepath: ""
  maxsize: 0
  maxbackups: 0
  maxage: 0

```

### config.go

- **路径**: `D:\ide\tool\code-context-generator\internal\config\config.go`
- **大小**: 20009 字节
- **修改时间**: 2025-10-02T17:31:47+08:00

```go
// Package config 提供配置管理功能
package config

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"code-context-generator/internal/env"
	"code-context-generator/pkg/constants"
	"code-context-generator/pkg/types"

	"github.com/BurntSushi/toml"
	"github.com/goccy/go-yaml"
)

// Manager 配置管理器接口
type Manager interface {
	Load(configPath string) error
	Get() *types.Config
	Validate() error
	Reload() error
	Save(configPath string, format string) error
	GetEnvOverrides() map[string]string
	GenerateOutput(data types.ContextData, format string) (string, error)
	GetOutputFilename(format string) string
}

// ConfigManager 配置管理器实现
type ConfigManager struct {
	config     *types.Config
	mu         sync.RWMutex
	configPath string
}

// NewManager 创建新的配置管理器
func NewManager() Manager {
	return &ConfigManager{
		config: GetDefaultConfig(),
	}
}

// Load 加载配置文件
func (cm *ConfigManager) Load(configPath string) error {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	if configPath == "" {
		configPath = constants.DefaultConfigFile
	}

	// 首先加载.env文件（如果存在）
	if err := env.LoadEnv(""); err != nil {
		// 如果.env文件加载失败，记录警告但不中断程序
		fmt.Printf("警告: 加载.env文件失败: %v\n", err)
	}

	// 检查文件是否存在
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		// 如果文件不存在，使用默认配置，不再自动创建配置文件
		cm.config = GetDefaultConfig()
		cm.configPath = configPath
		return nil
	}

	config, err := LoadConfig(configPath)
	if err != nil {
		return fmt.Errorf("加载配置文件失败: %w", err)
	}

	// 应用环境变量覆盖
	cm.applyEnvOverrides(config)

	// 应用格式特定的配置覆盖（基于配置文件名）
	applyFormatSpecificConfig(config, configPath)

	cm.config = config
	cm.configPath = configPath
	return nil
}

// Get 获取当前配置
func (cm *ConfigManager) Get() *types.Config {
	cm.mu.RLock()
	defer cm.mu.RUnlock()
	return cm.config
}

// Validate 验证配置
func (cm *ConfigManager) Validate() error {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	if cm.config == nil {
		return fmt.Errorf("配置为空")
	}

	// 验证格式配置
	formats := []string{constants.FormatXML, constants.FormatJSON, constants.FormatTOML, constants.FormatMarkdown}
	hasEnabled := false
	for _, format := range formats {
		if cm.isFormatEnabled(format) {
			hasEnabled = true
			break
		}
	}

	if !hasEnabled {
		return fmt.Errorf("至少需要启用一种输出格式")
	}

	// 验证输出配置
	if cm.config.Output.FilenameTemplate == "" {
		return fmt.Errorf("文件名模板不能为空")
	}

	// 验证时间格式
	if _, err := time.Parse(cm.config.Output.TimestampFormat, time.Now().Format(cm.config.Output.TimestampFormat)); err != nil {
		return fmt.Errorf("时间格式无效: %w", err)
	}

	return nil
}

// Reload 重新加载配置
func (cm *ConfigManager) Reload() error {
	if cm.configPath == "" {
		return fmt.Errorf("配置文件路径未设置")
	}
	return cm.Load(cm.configPath)
}

// Save 保存配置到文件
func (cm *ConfigManager) Save(configPath string, format string) error {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	if cm.config == nil {
		return fmt.Errorf("配置为空")
	}

	switch strings.ToLower(format) {
	case "yaml", "yml":
		return cm.saveYAML(configPath)
	case "json":
		return cm.saveJSON(configPath)
	case "toml":
		return cm.saveTOML(configPath)
	default:
		return fmt.Errorf("不支持的格式: %s", format)
	}
}

// GetEnvOverrides 获取环境变量覆盖
func (cm *ConfigManager) GetEnvOverrides() map[string]string {
	envVars := env.GetAllEnvVars()
	overrides := make(map[string]string)

	// 将环境变量名映射到配置字段名
	mapping := map[string]string{
		env.EnvDefaultFormat:    "default_format",
		env.EnvOutputDir:        "output_dir",
		env.EnvFilenameTemplate: "filename_template",
		env.EnvTimestampFormat:  "timestamp_format",
		env.EnvMaxFileSize:      "max_file_size",
		env.EnvMaxDepth:         "max_depth",
		env.EnvRecursive:        "recursive",
		env.EnvIncludeHidden:    "include_hidden",
		env.EnvFollowSymlinks:   "follow_symlinks",
		env.EnvExcludeBinary:    "exclude_binary",
		env.EnvExcludePatterns:  "exclude_patterns",
	}

	for envKey, fieldName := range mapping {
		if value, exists := envVars[envKey]; exists && value != "" {
			overrides[fieldName] = value
		}
	}

	return overrides
}

// applyEnvOverrides 应用环境变量覆盖到配置
func (cm *ConfigManager) applyEnvOverrides(config *types.Config) {
	// 应用输出格式覆盖
	if format := env.GetDefaultFormat(); format != "" {
		config.Output.DefaultFormat = format
	}

	// 应用输出目录覆盖
	if outputDir := env.GetOutputDir(); outputDir != "" {
		config.Output.OutputDir = outputDir
	}

	// 应用文件名模板覆盖
	if filenameTemplate := env.GetFilenameTemplate(); filenameTemplate != "" {
		config.Output.FilenameTemplate = filenameTemplate
	}

	// 应用时间戳格式覆盖
	if timestampFormat := env.GetTimestampFormat(); timestampFormat != "" {
		config.Output.TimestampFormat = timestampFormat
	}

	// 应用最大文件大小覆盖
	if maxFileSize := env.GetMaxFileSize(); maxFileSize != "" {
		config.Filters.MaxFileSize = maxFileSize
	}

	// 应用最大深度覆盖
	config.Filters.MaxDepth = env.GetMaxDepth()

	// 应用排除模式覆盖
	if excludePatterns := env.GetExcludePatterns(); excludePatterns != "" {
		config.Filters.ExcludePatterns = strings.Split(excludePatterns, ",")
	}

	// 应用跟随符号链接覆盖
	config.Filters.FollowSymlinks = env.GetFollowSymlinks()

	// 应用排除二进制文件覆盖
	config.Filters.ExcludeBinary = env.GetExcludeBinary()
}

// GenerateOutput 生成输出内容
func (cm *ConfigManager) GenerateOutput(data types.ContextData, format string) (string, error) {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	switch strings.ToLower(format) {
	case constants.FormatXML:
		return cm.generateXML(data)
	case constants.FormatJSON:
		return cm.generateJSON(data)
	case constants.FormatTOML:
		return cm.generateTOML(data)
	case constants.FormatMarkdown:
		return cm.generateMarkdown(data)
	default:
		return "", fmt.Errorf("不支持的格式: %s", format)
	}
}

// GetOutputFilename 生成输出文件名
func (cm *ConfigManager) GetOutputFilename(format string) string {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	template := cm.config.Output.FilenameTemplate
	if template == "" {
		template = constants.DefaultFilenameTemplate
	}

	timestamp := time.Now().Format(cm.config.Output.TimestampFormat)
	if timestamp == "" {
		timestamp = time.Now().Format(constants.DefaultTimestampFormat)
	}

	filename := strings.ReplaceAll(template, "{{.timestamp}}", timestamp)
	filename = strings.ReplaceAll(filename, "{{.extension}}", format)

	return filename
}

// saveConfig 内部保存配置（不加锁）
func (cm *ConfigManager) saveConfig(configPath string, format string) error {
	if cm.config == nil {
		return fmt.Errorf("配置为空")
	}

	switch strings.ToLower(format) {
	case "yaml", "yml":
		return cm.saveYAML(configPath)
	case "json":
		return cm.saveJSON(configPath)
	case "toml":
		return cm.saveTOML(configPath)
	default:
		return fmt.Errorf("不支持的格式: %s", format)
	}
}

// 辅助方法

func (cm *ConfigManager) isFormatEnabled(format string) bool {
	switch format {
	case constants.FormatXML:
		return cm.config.Formats.XML.Enabled
	case constants.FormatJSON:
		return cm.config.Formats.JSON.Enabled
	case constants.FormatTOML:
		return cm.config.Formats.TOML.Enabled
	case constants.FormatMarkdown:
		return cm.config.Formats.Markdown.Enabled
	default:
		return false
	}
}

func (cm *ConfigManager) saveYAML(configPath string) error {
	data, err := yaml.Marshal(cm.config)
	if err != nil {
		return fmt.Errorf("YAML序列化失败: %w", err)
	}
	return os.WriteFile(configPath, data, 0644)
}

func (cm *ConfigManager) saveJSON(configPath string) error {
	data, err := json.MarshalIndent(cm.config, "", "  ")
	if err != nil {
		return fmt.Errorf("JSON序列化失败: %w", err)
	}
	return os.WriteFile(configPath, data, 0644)
}

func (cm *ConfigManager) saveTOML(configPath string) error {
	file, err := os.Create(configPath)
	if err != nil {
		return fmt.Errorf("创建文件失败: %w", err)
	}
	defer file.Close()

	encoder := toml.NewEncoder(file)
	if err := encoder.Encode(cm.config); err != nil {
		return fmt.Errorf("TOML编码失败: %w", err)
	}
	return nil
}

func (cm *ConfigManager) generateXML(data types.ContextData) (string, error) {
	// 获取XML配置
	xmlConfig := cm.config.Formats.XML

	var sb strings.Builder

	// 添加XML声明
	if xmlConfig.Formatting.Declaration {
		encoding := xmlConfig.Formatting.Encoding
		if encoding == "" {
			encoding = "UTF-8"
		}
		sb.WriteString(fmt.Sprintf(`<?xml version="1.0" encoding="%s"?>`, encoding))
		sb.WriteString("\n")
	}

	// 生成根元素
	rootTag := xmlConfig.RootTag
	if rootTag == "" {
		rootTag = "context"
	}

	sb.WriteString(fmt.Sprintf("<%s>\n", rootTag))

	// 生成元数据
	if data.Metadata != nil {
		sb.WriteString("  <metadata>\n")
		for key, value := range data.Metadata {
			sb.WriteString(fmt.Sprintf("    <%s>%v</%s>\n", key, value, key))
		}
		sb.WriteString("  </metadata>\n")
	}

	// 生成文件部分
	if len(data.Files) > 0 {
		filesTag := xmlConfig.FilesTag
		if filesTag == "" {
			filesTag = "files"
		}
		sb.WriteString(fmt.Sprintf("  <%s>\n", filesTag))

		fileTag := xmlConfig.FileTag
		if fileTag == "" {
			fileTag = "file"
		}

		for _, file := range data.Files {
			sb.WriteString(fmt.Sprintf("    <%s>\n", fileTag))

			// 获取字段映射
			pathField := xmlConfig.Fields["path"]
			if pathField == "" {
				pathField = "path"
			}
			sb.WriteString(fmt.Sprintf("      <%s>%s</%s>\n", pathField, escapeXML(file.Path), pathField))

			if file.Content != "" {
				contentField := xmlConfig.Fields["content"]
				if contentField == "" {
					contentField = "content"
				}
				sb.WriteString(fmt.Sprintf("      <%s><![CDATA[%s]]></%s>\n", contentField, file.Content, contentField))
			}

			sb.WriteString(fmt.Sprintf("    </%s>\n", fileTag))
		}
		sb.WriteString(fmt.Sprintf("  </%s>\n", filesTag))
	}

	// 生成文件夹部分
	if len(data.Folders) > 0 {
		folderTag := xmlConfig.FolderTag
		if folderTag == "" {
			folderTag = "folder"
		}

		for _, folder := range data.Folders {
			sb.WriteString(fmt.Sprintf("  <%s>\n", folderTag))

			pathField := xmlConfig.Fields["path"]
			if pathField == "" {
				pathField = "path"
			}
			sb.WriteString(fmt.Sprintf("    <%s>%s</%s>\n", pathField, escapeXML(folder.Path), pathField))

			if len(folder.Files) > 0 {
				filesTag := xmlConfig.FilesTag
				if filesTag == "" {
					filesTag = "files"
				}
				sb.WriteString(fmt.Sprintf("    <%s>\n", filesTag))

				fileTag := xmlConfig.FileTag
				if fileTag == "" {
					fileTag = "file"
				}

				for _, file := range folder.Files {
					sb.WriteString(fmt.Sprintf("      <%s>\n", fileTag))

					filenameField := xmlConfig.Fields["filename"]
					if filenameField == "" {
						filenameField = "filename"
					}
					sb.WriteString(fmt.Sprintf("        <%s>%s</%s>\n", filenameField, escapeXML(file.Name), filenameField))

					if file.Content != "" {
						contentField := xmlConfig.Fields["content"]
						if contentField == "" {
							contentField = "content"
						}
						sb.WriteString(fmt.Sprintf("        <%s><![CDATA[%s]]></%s>\n", contentField, file.Content, contentField))
					}

					sb.WriteString(fmt.Sprintf("      </%s>\n", fileTag))
				}
				sb.WriteString(fmt.Sprintf("    </%s>\n", filesTag))
			}

			sb.WriteString(fmt.Sprintf("  </%s>\n", folderTag))
		}
	}

	sb.WriteString(fmt.Sprintf("</%s>", rootTag))

	return sb.String(), nil
}

// escapeXML 转义XML特殊字符
func escapeXML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	s = strings.ReplaceAll(s, "'", "&apos;")
	return s
}

func (cm *ConfigManager) generateJSON(data types.ContextData) (string, error) {
	// 实现JSON生成逻辑
	output, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return "", fmt.Errorf("JSON生成失败: %w", err)
	}
	return string(output), nil
}

func (cm *ConfigManager) generateTOML(data types.ContextData) (string, error) {
	// 实现TOML生成逻辑
	var buf strings.Builder
	encoder := toml.NewEncoder(&buf)
	if err := encoder.Encode(data); err != nil {
		return "", fmt.Errorf("TOML生成失败: %w", err)
	}
	return buf.String(), nil
}

func (cm *ConfigManager) generateMarkdown(data types.ContextData) (string, error) {
	// 实现Markdown生成逻辑
	var sb strings.Builder

	// 添加文件部分
	for _, file := range data.Files {
		sb.WriteString(fmt.Sprintf("## 文件: %s\n\n", file.Path))
		sb.WriteString("```\n")
		sb.WriteString(file.Content)
		sb.WriteString("\n```\n\n")
	}

	// 添加文件夹部分
	for _, folder := range data.Folders {
		sb.WriteString(fmt.Sprintf("### 文件夹: %s\n\n", folder.Path))
		for _, file := range folder.Files {
			sb.WriteString(fmt.Sprintf("#### 文件: %s\n\n", file.Name))
			sb.WriteString("```\n")
			sb.WriteString(file.Content)
			sb.WriteString("\n```\n\n")
		}
	}

	return sb.String(), nil
}

// LoadConfig 从文件加载配置（辅助函数）
func LoadConfig(configPath string) (*types.Config, error) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("读取配置文件失败: %w", err)
	}

	ext := strings.ToLower(filepath.Ext(configPath))
	var config types.Config

	switch ext {
	case ".yaml", ".yml":
		if err := yaml.Unmarshal(data, &config); err != nil {
			return nil, fmt.Errorf("YAML解析失败: %w", err)
		}
	case ".json":
		if err := json.Unmarshal(data, &config); err != nil {
			return nil, fmt.Errorf("JSON解析失败: %w", err)
		}
	case ".toml":
		if _, err := toml.Decode(string(data), &config); err != nil {
			return nil, fmt.Errorf("TOML解析失败: %w", err)
		}
	case ".xml":
		// 对于XML配置文件，我们需要特殊处理，因为XML结构通常与Go结构体不匹配
		// 这里我们使用一个简化的XML解析，或者返回错误提示用户使用支持的格式
		return nil, fmt.Errorf("XML配置文件格式暂不支持，请使用YAML、JSON或TOML格式")
	default:
		return nil, fmt.Errorf("不支持的配置文件格式: %s", ext)
	}

	// 根据配置文件名应用相应的格式配置
	applyFormatSpecificConfig(&config, configPath)

	return &config, nil
}

// applyFormatSpecificConfig 根据配置文件名应用相应的格式配置
func applyFormatSpecificConfig(config *types.Config, configPath string) {
	// 将配置文件名转换为小写以便匹配
	configName := strings.ToLower(filepath.Base(configPath))

	// 根据配置文件名中是否包含特定格式名称来应用相应的格式配置
	if strings.Contains(configName, "xml") {
		// 如果配置文件名包含xml，应用XML格式配置
		if config.Formats.XML.Enabled {
			config.Output.DefaultFormat = "xml"
		}
	} else if strings.Contains(configName, "json") {
		// 如果配置文件名包含json，应用JSON格式配置
		if config.Formats.JSON.Enabled {
			config.Output.DefaultFormat = "json"
		}
	} else if strings.Contains(configName, "toml") {
		// 如果配置文件名包含toml，应用TOML格式配置
		if config.Formats.TOML.Enabled {
			config.Output.DefaultFormat = "toml"
		}
	} else if strings.Contains(configName, "markdown") || strings.Contains(configName, "md") {
		// 如果配置文件名包含markdown或md，应用Markdown格式配置
		if config.Formats.Markdown.Enabled {
			config.Output.DefaultFormat = "markdown"
		}
	}
}

// GetDefaultConfig 获取默认配置
func GetDefaultConfig() *types.Config {
	return &types.Config{
		FileProcessing: types.FileProcessingConfig{
			IncludeHidden:  false,
			IncludeContent: true, // 默认包含文件内容
			IncludeHash:    false,
		},
		Formats: types.FormatsConfig{
			XML: types.XMLFormatConfig{
				FormatConfig: types.FormatConfig{
					Enabled: true,
					Fields: map[string]string{
						"path":     "path",
						"content":  "content",
						"filename": "filename",
					},
				},
				RootTag:   "context",
				FileTag:   "file",
				FilesTag:  "files",
				FolderTag: "folder",
				Formatting: types.XMLFormattingConfig{
					Indent:      "  ",
					Declaration: true,
					Encoding:    "UTF-8",
				},
			},
			JSON: types.FormatConfig{
				Enabled: true,
				Structure: map[string]interface{}{
					"file":   "file",
					"folder": "folder",
				},
				Fields: map[string]string{
					"path":     "path",
					"content":  "content",
					"filename": "filename",
				},
			},
			TOML: types.FormatConfig{
				Enabled: true,
				Structure: map[string]interface{}{
					"file_section":   "file",
					"folder_section": "folder",
				},
				Fields: map[string]string{
					"path":     "path",
					"content":  "content",
					"filename": "filename",
				},
			},
			Markdown: types.FormatConfig{
				Enabled: true,
				Structure: map[string]interface{}{
					"file_header":   "##",
					"folder_header": "###",
					"code_block":    "```",
				},
				Formatting: map[string]interface{}{
					"separator":     "\n\n",
					"add_toc":       false,
					"code_language": true,
				},
			},
		},
		Fields: types.FieldsConfig{
			CustomNames: map[string]string{
				"filepath":    "path",
				"filecontent": "content",
				"filename":    "name",
			},
			Filter: struct {
				Include []string `yaml:"include" json:"include" toml:"include"`
				Exclude []string `yaml:"exclude" json:"exclude" toml:"exclude"`
			}{
				Include: []string{},
				Exclude: []string{},
			},
			Processing: struct {
				MaxLength      int  `yaml:"max_length" json:"max_length" toml:"max_length"`
				AddLineNumbers bool `yaml:"add_line_numbers" json:"add_line_numbers" toml:"add_line_numbers"`
				TrimWhitespace bool `yaml:"trim_whitespace" json:"trim_whitespace" toml:"trim_whitespace"`
				CodeHighlight  bool `yaml:"code_highlight" json:"code_highlight" toml:"code_highlight"`
			}{
				MaxLength:      0,
				AddLineNumbers: false,
				TrimWhitespace: true,
				CodeHighlight:  false,
			},
		},
		Filters: types.FiltersConfig{
			MaxFileSize:     "10MB",
			ExcludePatterns: constants.DefaultExcludePatterns,
			IncludePatterns: []string{},
			MaxDepth:        constants.DefaultMaxDepth,
			FollowSymlinks:  false,
			ExcludeBinary:   false, // 改为不排除二进制文件，让它们显示为[二进制文件]
		},
		Output: types.OutputConfig{
			DefaultFormat:    constants.DefaultFormat,
			OutputDir:        constants.DefaultOutputDir,
			FilenameTemplate: constants.DefaultFilenameTemplate,
			TimestampFormat:  constants.DefaultTimestampFormat,
		},
		UI: types.UIConfig{
			Selector: struct {
				ShowHidden   bool `yaml:"show_hidden" json:"show_hidden" toml:"show_hidden"`
				ShowSize     bool `yaml:"show_size" json:"show_size" toml:"show_size"`
				ShowModified bool `yaml:"show_modified" json:"show_modified" toml:"show_modified"`
			}{
				ShowHidden:   constants.DefaultShowHidden,
				ShowSize:     constants.DefaultShowSize,
				ShowModified: constants.DefaultShowModified,
			},
		},
	}
}

```

### config_test.yaml

- **路径**: `D:\ide\tool\code-context-generator\internal\config\config_test.yaml`
- **大小**: 2319 字节
- **修改时间**: 2025-10-02T17:23:46+08:00

```yaml
formats:
  xml:
    enabled: true
    structure:
      file: file
      files: files
      folder: folder
      root: context
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  json:
    enabled: true
    structure:
      file: file
      folder: folder
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  toml:
    enabled: true
    structure:
      file_section: file
      folder_section: folder
    fields:
      content: content
      filename: filename
      path: path
    template: ""
    formatting: {}
  markdown:
    enabled: true
    structure:
      code_block: "```"
      file_header: "##"
      folder_header: "###"
    fields: {}
    template: ""
    formatting:
      add_toc: false
      code_language: true
      separator: |+
        

fields:
  custom_names:
    filecontent: content
    filename: name
    filepath: path
  filter:
    include: []
    exclude: []
  processing:
    max_length: 0
    add_line_numbers: false
    trim_whitespace: true
    code_highlight: false
filters:
  max_file_size: 10MB
  exclude_patterns:
  - "*.tmp"
  - "*.log"
  - "*.swp"
  - .*
  - node_modules/
  - target/
  - dist/
  - build/
  - .env
  - .git/
  - .vscode/
  - .idea/
  - __pycache__/
  - "*.pyc"
  - .venv
  - "*.class"
  include_patterns: []
  max_depth: 0
  follow_symlinks: false
output:
  format: ""
  file_path: ""
  encoding: ""
  default_format: xml
  output_dir: ""
  filename_template: context_{{.timestamp}}.{{.extension}}
  timestamp_format: "20060102_150405"
ui:
  theme: ""
  show_progress: false
  show_size: false
  show_date: false
  show_preview: false
  selector:
    show_hidden: false
    show_size: true
    show_modified: false
  autocomplete:
    enabled: true
    min_chars: 1
    max_suggestions: 10
file_processing:
  includehidden: false
  maxfilesize: "1MB"
  maxdepth: 0
  excludepatterns: []
  includepatterns: []
  includecontent: true
  includehash: false
performance:
  maxworkers: 0
  buffersize: 0
  cacheenabled: false
  cachesize: 0
logging:
  level: ""
  filepath: ""
  maxsize: 0
  maxbackups: 0
  maxage: 0

```

### config_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\config\config_test.go`
- **大小**: 11261 字节
- **修改时间**: 2025-10-01T19:22:49+08:00

```go
// Package config 提供配置管理功能的单元测试
package config

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	
	"code-context-generator/pkg/constants"
	"code-context-generator/pkg/types"
)

// TestNewManager 测试创建新的配置管理器
func TestNewManager(t *testing.T) {
	manager := NewManager()
	if manager == nil {
		t.Fatal("NewManager() 返回 nil")
	}

	cm, ok := manager.(*ConfigManager)
	if !ok {
		t.Fatal("NewManager() 返回的类型不是 *ConfigManager")
	}

	if cm.config == nil {
		t.Fatal("ConfigManager.config 为 nil")
	}
}

// TestConfigManager_Load 测试加载配置文件
func TestConfigManager_Load(t *testing.T) {
	// 创建临时配置文件
	tempDir := t.TempDir()
	yamlConfig := filepath.Join(tempDir, "test.yaml")

	// 创建测试配置数据
	testConfig := GetDefaultConfig()
	testConfig.Output.DefaultFormat = "json"
	testConfig.Output.OutputDir = "./test_output"

	// 保存为YAML配置文件
	err := os.WriteFile(yamlConfig, []byte(`formats:
  xml:
    enabled: true
  json:
    enabled: true
  toml:
    enabled: true
  markdown:
    enabled: true
fields:
  custom_names: {}
  filter:
    include: []
    exclude: []
  processing:
    max_length: 0
    add_line_numbers: false
    trim_whitespace: true
    code_highlight: false
filters:
  max_file_size: "10MB"
  exclude_patterns: []
  include_patterns: []
  max_depth: 0
  follow_symlinks: false
output:
  default_format: "json"
  output_dir: "./test_output"
  filename_template: "context_{{.timestamp}}.{{.extension}}"
  timestamp_format: "20060102_150405"
ui:
  selector:
    show_hidden: false
    show_size: true
    show_modified: false
  autocomplete:
    enabled: true
    min_chars: 1
    max_suggestions: 10
`), 0644)
	if err != nil {
		t.Fatalf("创建测试配置文件失败: %v", err)
	}

	tests := []struct {
		name       string
		configPath string
		wantErr    bool
	}{
		{"加载YAML配置", yamlConfig, false},
		{"加载不存在的文件", filepath.Join(tempDir, "nonexistent.yaml"), false}, // 应该创建默认配置
		{"空路径", "", false}, // 应该使用默认配置
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			manager := NewManager()
			err := manager.Load(tt.configPath)
			
			if tt.wantErr && err == nil {
				t.Errorf("Load() 期望错误但没有得到错误")
			}
			if !tt.wantErr && err != nil {
				t.Errorf("Load() 出现意外错误: %v", err)
			}
		})
	}
}

// TestConfigManager_Get 测试获取配置
func TestConfigManager_Get(t *testing.T) {
	manager := NewManager()
	config := manager.Get()
	
	if config == nil {
		t.Fatal("Get() 返回 nil")
	}

	// 验证默认配置值
	if config.Output.DefaultFormat != constants.DefaultFormat {
		t.Errorf("默认格式不匹配: 期望 %s, 得到 %s", constants.DefaultFormat, config.Output.DefaultFormat)
	}
	
	if config.Output.FilenameTemplate != constants.DefaultFilenameTemplate {
		t.Errorf("文件名模板不匹配: 期望 %s, 得到 %s", constants.DefaultFilenameTemplate, config.Output.FilenameTemplate)
	}
}

// TestConfigManager_Validate 测试配置验证
func TestConfigManager_Validate(t *testing.T) {
	tests := []struct {
		name    string
		setup   func() Manager
		wantErr bool
	}{
		{
			name: "有效配置",
			setup: func() Manager {
				manager := NewManager()
				return manager
			},
			wantErr: false,
		},
		{
			name: "空配置",
			setup: func() Manager {
				return &ConfigManager{config: nil}
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			manager := tt.setup()
			err := manager.Validate()
			
			if tt.wantErr && err == nil {
				t.Errorf("Validate() 期望错误但没有得到错误")
			}
			if !tt.wantErr && err != nil {
				t.Errorf("Validate() 出现意外错误: %v", err)
			}
		})
	}
}

// TestConfigManager_Save 测试保存配置
func TestConfigManager_Save(t *testing.T) {
	tempDir := t.TempDir()
	
	tests := []struct {
		name      string
		format    string
		wantErr   bool
	}{
		{"保存为YAML", "yaml", false},
		{"保存为JSON", "json", false},
		{"保存为TOML", "toml", false},
		{"保存为不支持的格式", "unsupported", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			manager := NewManager()
			configPath := filepath.Join(tempDir, "test."+tt.format)
			
			err := manager.Save(configPath, tt.format)
			
			if tt.wantErr && err == nil {
				t.Errorf("Save() 期望错误但没有得到错误")
			}
			if !tt.wantErr && err != nil {
				t.Errorf("Save() 出现意外错误: %v", err)
			}
			
			if !tt.wantErr {
				// 验证文件已创建
				if _, err := os.Stat(configPath); os.IsNotExist(err) {
					t.Errorf("Save() 未创建文件: %s", configPath)
				}
			}
		})
	}
}

// TestConfigManager_GetEnvOverrides 测试获取环境变量覆盖
func TestConfigManager_GetEnvOverrides(t *testing.T) {
	// 设置测试环境变量
	os.Setenv(constants.EnvPrefix+"DEFAULT_FORMAT", "json")
	os.Setenv(constants.EnvPrefix+"OUTPUT_DIR", "/test/output")
	os.Setenv(constants.EnvPrefix+"MAX_DEPTH", "5")
	
	// 清理环境变量
	defer func() {
		os.Unsetenv(constants.EnvPrefix + "DEFAULT_FORMAT")
		os.Unsetenv(constants.EnvPrefix + "OUTPUT_DIR")
		os.Unsetenv(constants.EnvPrefix + "MAX_DEPTH")
	}()
	
	manager := NewManager()
	overrides := manager.GetEnvOverrides()
	
	if overrides == nil {
		t.Fatal("GetEnvOverrides() 返回 nil")
	}
	
	// 验证环境变量覆盖
	if overrides["default_format"] != "json" {
		t.Errorf("期望 default_format = json, 得到 %s", overrides["default_format"])
	}
	if overrides["output_dir"] != "/test/output" {
		t.Errorf("期望 output_dir = /test/output, 得到 %s", overrides["output_dir"])
	}
	if overrides["max_depth"] != "5" {
		t.Errorf("期望 max_depth = 5, 得到 %s", overrides["max_depth"])
	}
}

// TestConfigManager_GetOutputFilename 测试生成输出文件名
func TestConfigManager_GetOutputFilename(t *testing.T) {
	manager := NewManager()
	
	filename := manager.GetOutputFilename("txt")
	
	if filename == "" {
		t.Error("GetOutputFilename() 返回空文件名")
	}
	
	// 验证文件名包含扩展名
	if !strings.Contains(filename, "txt") {
		t.Errorf("文件名 %s 不包含扩展名 txt", filename)
	}
	
	// 验证文件名包含时间戳占位符
	if !strings.Contains(filename, "{{.timestamp}}") && !strings.Contains(filename, "20") {
		t.Errorf("文件名 %s 不包含时间戳信息", filename)
	}
}

// TestConfigManager_Reload 测试重新加载配置
func TestConfigManager_Reload(t *testing.T) {
	manager := NewManager()
	
	// 测试未设置路径时的重载
	err := manager.Reload()
	if err == nil {
		t.Error("期望Reload()在未设置路径时返回错误")
	}
	
	// 创建临时配置文件
	tempFile := filepath.Join(t.TempDir(), "config_test.yaml")
	err = manager.Save(tempFile, "yaml")
	if err != nil {
		t.Fatalf("保存配置文件失败: %v", err)
	}
	
	// 加载配置
	err = manager.Load(tempFile)
	if err != nil {
		t.Fatalf("加载配置文件失败: %v", err)
	}
	
	// 修改配置
	config := manager.Get()
	originalFormat := config.Output.DefaultFormat
	config.Output.DefaultFormat = "json"
	
	// 重新加载配置
	err = manager.Reload()
	if err != nil {
		t.Errorf("Reload() 失败: %v", err)
	}
	
	// 验证配置已恢复
	config = manager.Get()
	if config.Output.DefaultFormat != originalFormat {
		t.Errorf("配置未正确重载: 期望 %s, 得到 %s", originalFormat, config.Output.DefaultFormat)
	}
}

// TestConfigManager_GenerateOutput 测试生成输出内容
func TestConfigManager_GenerateOutput(t *testing.T) {
	manager := NewManager()
	
	// 创建简单的测试数据（避免XML序列化问题）
	testData := types.ContextData{
		Files: []types.FileInfo{
			{
				Name:    "test.go",
				Path:    "test.go",
				Content: "package main\n\nfunc main() {}",
				Size:    30,
			},
		},
		Folders: []types.FolderInfo{
			{
				Name:  "src",
				Path:  "src",
				Files: []types.FileInfo{
					{
						Name:    "main.go",
						Path:    "src/main.go",
						Content: "package main",
						Size:    20,
					},
				},
			},
		},
		FileCount:   1,
		FolderCount: 1,
	}
	
	tests := []struct {
		name    string
		format  string
		wantErr bool
	}{
		{"生成JSON", "json", false},
		{"生成TOML", "toml", false},
		{"生成Markdown", "markdown", false},
		{"不支持的格式", "unsupported", true},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output, err := manager.GenerateOutput(testData, tt.format)
			if (err != nil) != tt.wantErr {
				t.Errorf("GenerateOutput() error = %v, wantErr %v", err, tt.wantErr)
			}
			if !tt.wantErr && output == "" {
				t.Error("GenerateOutput() 返回空字符串")
			}
		})
	}
}

// TestGetDefaultConfig 测试获取默认配置
func TestGetDefaultConfig(t *testing.T) {
	config := GetDefaultConfig()
	
	if config == nil {
		t.Fatal("GetDefaultConfig() 返回 nil")
	}

	// 验证默认配置的关键字段
	if config.Output.DefaultFormat == "" {
		t.Error("默认格式不能为空")
	}
	
	if config.Output.FilenameTemplate == "" {
		t.Error("文件名模板不能为空")
	}
}

// TestLoadConfig 测试加载配置文件
func TestLoadConfig(t *testing.T) {
	tests := []struct {
		name      string
		content   string
		extension string
		wantErr   bool
	}{
		{
			name: "加载YAML配置",
			content: `output:
  default_format: json
  filename_template: "{{.timestamp}}.{{.extension}}"
`,
			extension: ".yaml",
			wantErr: false,
		},
		{
			name: "加载JSON配置",
			content: `{
  "output": {
	"default_format": "json",
	"filename_template": "{{.timestamp}}.{{.extension}}"
  }
}`,
			extension: ".json",
			wantErr: false,
		},
		{
			name: "加载TOML配置",
			content: `[output]
default_format = "json"
filename_template = "{{.timestamp}}.{{.extension}}"
`,
			extension: ".toml",
			wantErr: false,
		},
		{
			name:      "不支持的格式",
			content:   `test content`,
			extension: ".txt",
			wantErr: true,
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tempFile := filepath.Join(t.TempDir(), "config"+tt.extension)
			err := os.WriteFile(tempFile, []byte(tt.content), 0644)
			if err != nil {
				t.Fatalf("写入测试文件失败: %v", err)
			}
			
			config, err := LoadConfig(tempFile)
			if (err != nil) != tt.wantErr {
				t.Errorf("LoadConfig() error = %v, wantErr %v", err, tt.wantErr)
			}
			
			if !tt.wantErr && config == nil {
				t.Error("LoadConfig() 返回 nil 配置")
			}
		})
	}
}

// 辅助函数
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsHelper(s, substr))
}

func containsHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
```

### env_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\env\env_test.go`
- **大小**: 19221 字节
- **修改时间**: 2025-10-02T17:30:13+08:00

```go
// Package env 提供.env文件加载和环境变量管理功能的单元测试
package env

import (
	"os"
	"strings"
	"testing"
)

// TestLoadEnv 测试加载.env文件功能
func TestLoadEnv(t *testing.T) {
	// 保存原始环境变量
	originalEnv := make(map[string]string)
	for _, key := range []string{"TEST_KEY_1", "TEST_KEY_2", "CODE_CONTEXT_DEFAULT_FORMAT"} {
		originalEnv[key] = os.Getenv(key)
	}

	// 测试用例结束后恢复原始环境变量
	defer func() {
		for key, value := range originalEnv {
			if value == "" {
				os.Unsetenv(key)
			} else {
				os.Setenv(key, value)
			}
		}
		// 删除测试文件
		os.Remove(".env")
		os.Remove("test.env")
	}()

	tests := []struct {
		name          string
		envPath       string
		envContent    string
		expectedError bool
	}{
		{
			name:          "加载不存在的.env文件",
			envPath:       "",
			envContent:    "",
			expectedError: false, // 不应该报错
		},
		{
			name:          "加载存在的.env文件",
			envPath:       ".env",
			envContent:    "TEST_KEY_1=value1\nTEST_KEY_2=value2\n",
			expectedError: false,
		},
		{
			name:          "加载指定路径的.env文件",
			envPath:       "test.env",
			envContent:    "CODE_CONTEXT_DEFAULT_FORMAT=json\n",
			expectedError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 清理环境
			os.Unsetenv("TEST_KEY_1")
			os.Unsetenv("TEST_KEY_2")
			os.Unsetenv("CODE_CONTEXT_DEFAULT_FORMAT")

			// 如果指定了内容，创建.env文件
			if tt.envContent != "" && tt.envPath != "" {
				err := os.WriteFile(tt.envPath, []byte(tt.envContent), 0644)
				if err != nil {
					t.Fatalf("创建测试文件失败: %v", err)
				}
			}

			err := LoadEnv(tt.envPath)
			if (err != nil) != tt.expectedError {
				t.Errorf("LoadEnv() error = %v, expectedError %v", err, tt.expectedError)
			}

			// 验证环境变量是否正确设置
			if tt.envContent != "" && err == nil {
				lines := strings.Split(tt.envContent, "\n")
				for _, line := range lines {
					if line != "" && !strings.HasPrefix(line, "#") {
						parts := strings.SplitN(line, "=", 2)
						if len(parts) == 2 {
							key, expectedValue := parts[0], parts[1]
							actualValue := os.Getenv(key)
							if actualValue != expectedValue {
								t.Errorf("环境变量 %s = %v, 期望 %v", key, actualValue, expectedValue)
							}
						}
					}
				}
			}

			// 清理测试文件
			if tt.envPath != "" && tt.envPath != ".env" {
				os.Remove(tt.envPath)
			}
		})
	}
}

// TestGetEnvWithDefault 测试获取环境变量（带默认值）
func TestGetEnvWithDefault(t *testing.T) {
	// 保存原始环境变量
	originalValue := os.Getenv("TEST_ENV_VAR")
	defer func() {
		if originalValue == "" {
			os.Unsetenv("TEST_ENV_VAR")
		} else {
			os.Setenv("TEST_ENV_VAR", originalValue)
		}
	}()

	tests := []struct {
		name         string
		key          string
		defaultValue string
		setValue     string
		expected     string
	}{
		{
			name:         "环境变量存在",
			key:          "TEST_ENV_VAR",
			defaultValue: "default",
			setValue:     "actual",
			expected:     "actual",
		},
		{
			name:         "环境变量不存在",
			key:          "TEST_ENV_VAR_NOT_EXIST",
			defaultValue: "default",
			setValue:     "",
			expected:     "default",
		},
		{
			name:         "环境变量为空",
			key:          "TEST_ENV_VAR",
			defaultValue: "default",
			setValue:     "",
			expected:     "default",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 设置环境变量
			if tt.setValue != "" {
				os.Setenv(tt.key, tt.setValue)
			} else {
				os.Unsetenv(tt.key)
			}

			result := GetEnvWithDefault(tt.key, tt.defaultValue)
			if result != tt.expected {
				t.Errorf("GetEnvWithDefault() = %v, 期望 %v", result, tt.expected)
			}
		})
	}
}

// TestGetEnvBool 测试获取布尔类型的环境变量
func TestGetEnvBool(t *testing.T) {
	// 保存原始环境变量
	originalValue := os.Getenv("TEST_BOOL_VAR")
	defer func() {
		if originalValue == "" {
			os.Unsetenv("TEST_BOOL_VAR")
		} else {
			os.Setenv("TEST_BOOL_VAR", originalValue)
		}
	}()

	tests := []struct {
		name         string
		key          string
		defaultValue bool
		setValue     string
		expected     bool
	}{
		{
			name:         "环境变量为true",
			key:          "TEST_BOOL_VAR",
			defaultValue: false,
			setValue:     "true",
			expected:     true,
		},
		{
			name:         "环境变量为false",
			key:          "TEST_BOOL_VAR",
			defaultValue: true,
			setValue:     "false",
			expected:     false,
		},
		{
			name:         "环境变量为1",
			key:          "TEST_BOOL_VAR",
			defaultValue: false,
			setValue:     "1",
			expected:     true,
		},
		{
			name:         "环境变量为0",
			key:          "TEST_BOOL_VAR",
			defaultValue: true,
			setValue:     "0",
			expected:     false,
		},
		{
			name:         "环境变量不存在",
			key:          "TEST_BOOL_VAR_NOT_EXIST",
			defaultValue: true,
			setValue:     "",
			expected:     true,
		},
		{
			name:         "环境变量为无效值",
			key:          "TEST_BOOL_VAR",
			defaultValue: true,
			setValue:     "invalid",
			expected:     true, // 返回默认值
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 设置环境变量
			if tt.setValue != "" {
				os.Setenv(tt.key, tt.setValue)
			} else {
				os.Unsetenv(tt.key)
			}

			result := GetEnvBool(tt.key, tt.defaultValue)
			if result != tt.expected {
				t.Errorf("GetEnvBool() = %v, 期望 %v", result, tt.expected)
			}
		})
	}
}

// TestGetEnvInt 测试获取整数类型的环境变量
func TestGetEnvInt(t *testing.T) {
	// 保存原始环境变量
	originalValue := os.Getenv("TEST_INT_VAR")
	defer func() {
		if originalValue == "" {
			os.Unsetenv("TEST_INT_VAR")
		} else {
			os.Setenv("TEST_INT_VAR", originalValue)
		}
	}()

	tests := []struct {
		name         string
		key          string
		defaultValue int
		setValue     string
		expected     int
	}{
		{
			name:         "环境变量为有效整数",
			key:          "TEST_INT_VAR",
			defaultValue: 10,
			setValue:     "42",
			expected:     42,
		},
		{
			name:         "环境变量为负数",
			key:          "TEST_INT_VAR",
			defaultValue: 10,
			setValue:     "-5",
			expected:     -5,
		},
		{
			name:         "环境变量不存在",
			key:          "TEST_INT_VAR_NOT_EXIST",
			defaultValue: 10,
			setValue:     "",
			expected:     10,
		},
		{
			name:         "环境变量为无效值",
			key:          "TEST_INT_VAR",
			defaultValue: 10,
			setValue:     "invalid",
			expected:     10, // 返回默认值
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 设置环境变量
			if tt.setValue != "" {
				os.Setenv(tt.key, tt.setValue)
			} else {
				os.Unsetenv(tt.key)
			}

			result := GetEnvInt(tt.key, tt.defaultValue)
			if result != tt.expected {
				t.Errorf("GetEnvInt() = %v, 期望 %v", result, tt.expected)
			}
		})
	}
}

// TestGetEnvInt64 测试获取int64类型的环境变量
func TestGetEnvInt64(t *testing.T) {
	// 保存原始环境变量
	originalValue := os.Getenv("TEST_INT64_VAR")
	defer func() {
		if originalValue == "" {
			os.Unsetenv("TEST_INT64_VAR")
		} else {
			os.Setenv("TEST_INT64_VAR", originalValue)
		}
	}()

	tests := []struct {
		name         string
		key          string
		defaultValue int64
		setValue     string
		expected     int64
	}{
		{
			name:         "环境变量为有效int64",
			key:          "TEST_INT64_VAR",
			defaultValue: 100,
			setValue:     "9223372036854775807", // MaxInt64
			expected:     9223372036854775807,
		},
		{
			name:         "环境变量为大负数",
			key:          "TEST_INT64_VAR",
			defaultValue: 100,
			setValue:     "-9223372036854775808", // MinInt64
			expected:     -9223372036854775808,
		},
		{
			name:         "环境变量不存在",
			key:          "TEST_INT64_VAR_NOT_EXIST",
			defaultValue: 100,
			setValue:     "",
			expected:     100,
		},
		{
			name:         "环境变量为无效值",
			key:          "TEST_INT64_VAR",
			defaultValue: 100,
			setValue:     "invalid",
			expected:     100, // 返回默认值
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 设置环境变量
			if tt.setValue != "" {
				os.Setenv(tt.key, tt.setValue)
			} else {
				os.Unsetenv(tt.key)
			}

			result := GetEnvInt64(tt.key, tt.defaultValue)
			if result != tt.expected {
				t.Errorf("GetEnvInt64() = %v, 期望 %v", result, tt.expected)
			}
		})
	}
}

// TestParseFileSize 测试文件大小解析功能
func TestParseFileSize(t *testing.T) {
	tests := []struct {
		name     string
		sizeStr  string
		expected int64
	}{
		{
			name:     "空字符串",
			sizeStr:  "",
			expected: 0,
		},
		{
			name:     "纯数字（字节）",
			sizeStr:  "1024",
			expected: 1024,
		},
		{
			name:     "KB单位",
			sizeStr:  "10KB",
			expected: 10 * 1024,
		},
		{
			name:     "MB单位",
			sizeStr:  "5MB",
			expected: 5 * 1024 * 1024,
		},
		{
			name:     "GB单位",
			sizeStr:  "2GB",
			expected: 2 * 1024 * 1024 * 1024,
		},
		{
			name:     "小写单位",
			sizeStr:  "10mb",
			expected: 10 * 1024 * 1024,
		},
		{
			name:     "带空格",
			sizeStr:  "  10 MB  ",
			expected: 10 * 1024 * 1024,
		},
		{
			name:     "无效格式（无数字）",
			sizeStr:  "MB",
			expected: 0,
		},
		{
			name:     "无效单位",
			sizeStr:  "10TB",
			expected: 10, // 默认按字节处理
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ParseFileSize(tt.sizeStr)
			if result != tt.expected {
				t.Errorf("ParseFileSize(%q) = %v, 期望 %v", tt.sizeStr, result, tt.expected)
			}
		})
	}
}

// TestGetAllEnvVars 测试获取所有环境变量配置
func TestGetAllEnvVars(t *testing.T) {
	// 保存原始环境变量
	originalValues := make(map[string]string)
	envKeys := []string{
		EnvDefaultFormat,
		EnvOutputDir,
		EnvFilenameTemplate,
		EnvTimestampFormat,
		EnvMaxFileSize,
		EnvMaxDepth,
		EnvRecursive,
		EnvIncludeHidden,
		EnvFollowSymlinks,
		EnvExcludeBinary,
		EnvExcludePatterns,
	}

	for _, key := range envKeys {
		originalValues[key] = os.Getenv(key)
	}

	defer func() {
		// 恢复原始环境变量
		for key, value := range originalValues {
			if value == "" {
				os.Unsetenv(key)
			} else {
				os.Setenv(key, value)
			}
		}
	}()

	// 设置一些测试环境变量
	os.Setenv(EnvDefaultFormat, "json")
	os.Setenv(EnvOutputDir, "/tmp/output")
	os.Setenv(EnvMaxFileSize, "20MB")
	os.Setenv(EnvMaxDepth, "5")
	os.Setenv(EnvRecursive, "true")
	os.Setenv(EnvIncludeHidden, "true")
	os.Setenv(EnvFollowSymlinks, "true")
	os.Setenv(EnvExcludeBinary, "false")
	os.Setenv(EnvExcludePatterns, "*.tmp,*.log")

	result := GetAllEnvVars()

	// 验证结果
	if result[EnvDefaultFormat] != "json" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvDefaultFormat, result[EnvDefaultFormat], "json")
	}

	if result[EnvOutputDir] != "/tmp/output" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvOutputDir, result[EnvOutputDir], "/tmp/output")
	}

	if result[EnvMaxFileSize] != "20MB" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvMaxFileSize, result[EnvMaxFileSize], "20MB")
	}

	if result[EnvMaxDepth] != "5" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvMaxDepth, result[EnvMaxDepth], "5")
	}

	if result[EnvRecursive] != "true" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvRecursive, result[EnvRecursive], "true")
	}

	if result[EnvIncludeHidden] != "true" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvIncludeHidden, result[EnvIncludeHidden], "true")
	}

	if result[EnvFollowSymlinks] != "true" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvFollowSymlinks, result[EnvFollowSymlinks], "true")
	}

	if result[EnvExcludeBinary] != "false" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvExcludeBinary, result[EnvExcludeBinary], "false")
	}

	if result[EnvExcludePatterns] != "*.tmp,*.log" {
		t.Errorf("GetAllEnvVars()[%s] = %v, 期望 %v", EnvExcludePatterns, result[EnvExcludePatterns], "*.tmp,*.log")
	}
}

// TestApplyEnvOverrides 测试应用环境变量覆盖
func TestApplyEnvOverrides(t *testing.T) {
	config := make(map[string]interface{})

	// 保存原始环境变量
	originalValues := make(map[string]string)
	envKeys := []string{
		EnvDefaultFormat,
		EnvOutputDir,
		EnvMaxFileSize,
	}

	for _, key := range envKeys {
		originalValues[key] = os.Getenv(key)
	}

	defer func() {
		// 恢复原始环境变量
		for key, value := range originalValues {
			if value == "" {
				os.Unsetenv(key)
			} else {
				os.Setenv(key, value)
			}
		}
	}()

	// 设置测试环境变量
	os.Setenv(EnvDefaultFormat, "toml")
	os.Setenv(EnvOutputDir, "/test/output")
	os.Setenv(EnvMaxFileSize, "50MB")

	ApplyEnvOverrides(config)

	// 验证配置是否被正确应用
	if config[EnvDefaultFormat] != "toml" {
		t.Errorf("ApplyEnvOverrides() 设置 %s = %v, 期望 %v", EnvDefaultFormat, config[EnvDefaultFormat], "toml")
	}

	if config[EnvOutputDir] != "/test/output" {
		t.Errorf("ApplyEnvOverrides() 设置 %s = %v, 期望 %v", EnvOutputDir, config[EnvOutputDir], "/test/output")
	}

	if config[EnvMaxFileSize] != "50MB" {
		t.Errorf("ApplyEnvOverrides() 设置 %s = %v, 期望 %v", EnvMaxFileSize, config[EnvMaxFileSize], "50MB")
	}
}

// TestConfigGetterFunctions 测试配置获取函数
func TestConfigGetterFunctions(t *testing.T) {
	// 保存原始环境变量
	originalValues := make(map[string]string)
	envKeys := []string{
		EnvDefaultFormat,
		EnvOutputDir,
		EnvFilenameTemplate,
		EnvTimestampFormat,
		EnvMaxFileSize,
		EnvMaxDepth,
		EnvRecursive,
		EnvIncludeHidden,
		EnvFollowSymlinks,
		EnvExcludeBinary,
		EnvExcludePatterns,
	}

	for _, key := range envKeys {
		originalValues[key] = os.Getenv(key)
	}

	defer func() {
		// 恢复原始环境变量
		for key, value := range originalValues {
			if value == "" {
				os.Unsetenv(key)
			} else {
				os.Setenv(key, value)
			}
		}
	}()

	// 测试字符串配置获取函数
	t.Run("字符串配置获取", func(t *testing.T) {
		os.Setenv(EnvDefaultFormat, "markdown")
		os.Setenv(EnvOutputDir, "/custom/output")
		os.Setenv(EnvFilenameTemplate, "custom_{{.timestamp}}.{{.extension}}")
		os.Setenv(EnvTimestampFormat, "2006-01-02")
		os.Setenv(EnvMaxFileSize, "15MB")
		os.Setenv(EnvExcludePatterns, "*.cache,*.temp")

		tests := []struct {
			name     string
			function func() string
			expected string
		}{
			{"GetDefaultFormat", GetDefaultFormat, "markdown"},
			{"GetOutputDir", GetOutputDir, "/custom/output"},
			{"GetFilenameTemplate", GetFilenameTemplate, "custom_{{.timestamp}}.{{.extension}}"},
			{"GetTimestampFormat", GetTimestampFormat, "2006-01-02"},
			{"GetMaxFileSize", GetMaxFileSize, "15MB"},
			{"GetExcludePatterns", GetExcludePatterns, "*.cache,*.temp"},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				result := tt.function()
				if result != tt.expected {
					t.Errorf("%s() = %v, 期望 %v", tt.name, result, tt.expected)
				}
			})
		}
	})

	// 测试整数配置获取函数
	t.Run("整数配置获取", func(t *testing.T) {
		os.Setenv(EnvMaxDepth, "10")

		result := GetMaxDepth()
		expected := 10
		if result != expected {
			t.Errorf("GetMaxDepth() = %v, 期望 %v", result, expected)
		}
	})

	// 测试布尔配置获取函数
	t.Run("布尔配置获取", func(t *testing.T) {
		os.Setenv(EnvRecursive, "true")
		os.Setenv(EnvIncludeHidden, "false")
		os.Setenv(EnvFollowSymlinks, "true")
		os.Setenv(EnvExcludeBinary, "false")

		tests := []struct {
			name     string
			function func() bool
			expected bool
		}{
			{"GetRecursive", GetRecursive, true},
			{"GetIncludeHidden", GetIncludeHidden, false},
			{"GetFollowSymlinks", GetFollowSymlinks, true},
			{"GetExcludeBinary", GetExcludeBinary, false},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				result := tt.function()
				if result != tt.expected {
					t.Errorf("%s() = %v, 期望 %v", tt.name, result, tt.expected)
				}
			})
		}
	})
}

// TestDefaultValues 测试默认值
func TestDefaultValues(t *testing.T) {
	// 清理所有相关的环境变量
	envKeys := []string{
		EnvDefaultFormat,
		EnvOutputDir,
		EnvFilenameTemplate,
		EnvTimestampFormat,
		EnvMaxFileSize,
		EnvMaxDepth,
		EnvRecursive,
		EnvIncludeHidden,
		EnvFollowSymlinks,
		EnvExcludeBinary,
		EnvExcludePatterns,
	}

	for _, key := range envKeys {
		os.Unsetenv(key)
	}

	// 测试默认值
	tests := []struct {
		name     string
		function interface{}
		expected interface{}
	}{
		{"GetDefaultFormat默认值", GetDefaultFormat(), "xml"},
		{"GetOutputDir默认值", GetOutputDir(), ""},
		{"GetFilenameTemplate默认值", GetFilenameTemplate(), ""},
		{"GetTimestampFormat默认值", GetTimestampFormat(), ""},
		{"GetMaxFileSize默认值", GetMaxFileSize(), "10MB"},
		{"GetMaxDepth默认值", GetMaxDepth(), 0},
		{"GetRecursive默认值", GetRecursive(), false},
		{"GetIncludeHidden默认值", GetIncludeHidden(), false},
		{"GetFollowSymlinks默认值", GetFollowSymlinks(), false},
		{"GetExcludeBinary默认值", GetExcludeBinary(), true},
		{"GetExcludePatterns默认值", GetExcludePatterns(), ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var result interface{}
			switch f := tt.function.(type) {
			case string:
				result = f
			case int:
				result = f
			case bool:
				result = f
			default:
				t.Fatalf("不支持的函数返回类型")
			}

			if result != tt.expected {
				t.Errorf("%s = %v, 期望 %v", tt.name, result, tt.expected)
			}
		})
	}
}

// TestEnvironmentVariableConstants 测试环境变量常量
func TestEnvironmentVariableConstants(t *testing.T) {
	expectedConstants := map[string]string{
		"EnvDefaultFormat":       "CODE_CONTEXT_DEFAULT_FORMAT",
		"EnvOutputDir":           "CODE_CONTEXT_OUTPUT_DIR",
		"EnvFilenameTemplate":    "CODE_CONTEXT_FILENAME_TEMPLATE",
		"EnvTimestampFormat":     "CODE_CONTEXT_TIMESTAMP_FORMAT",
		"EnvMaxFileSize":         "CODE_CONTEXT_MAX_FILE_SIZE",
		"EnvMaxDepth":            "CODE_CONTEXT_MAX_DEPTH",
		"EnvRecursive":           "CODE_CONTEXT_RECURSIVE",
		"EnvIncludeHidden":       "CODE_CONTEXT_INCLUDE_HIDDEN",
		"EnvFollowSymlinks":      "CODE_CONTEXT_FOLLOW_SYMLINKS",
		"EnvExcludeBinary":       "CODE_CONTEXT_EXCLUDE_BINARY",
		"EnvExcludePatterns":     "CODE_CONTEXT_EXCLUDE_PATTERNS",
		"EnvAutocompleteEnabled": "CODE_CONTEXT_AUTOCOMPLETE_ENABLED",
	}

	actualConstants := map[string]string{
		"EnvDefaultFormat":    EnvDefaultFormat,
		"EnvOutputDir":        EnvOutputDir,
		"EnvFilenameTemplate": EnvFilenameTemplate,
		"EnvTimestampFormat":  EnvTimestampFormat,
		"EnvMaxFileSize":      EnvMaxFileSize,
		"EnvMaxDepth":         EnvMaxDepth,
		"EnvRecursive":        EnvRecursive,
		"EnvIncludeHidden":    EnvIncludeHidden,
		"EnvFollowSymlinks":   EnvFollowSymlinks,
		"EnvExcludeBinary":    EnvExcludeBinary,
		"EnvExcludePatterns":  EnvExcludePatterns,
	}

	for name, expected := range expectedConstants {
		if actualConstants[name] != expected {
			t.Errorf("常量 %s = %v, 期望 %v", name, actualConstants[name], expected)
		}
	}
}

```

### env.go

- **路径**: `D:\ide\tool\code-context-generator\internal\env\env.go`
- **大小**: 5653 字节
- **修改时间**: 2025-10-02T17:25:47+08:00

```go
// Package env 提供.env文件加载和环境变量管理功能
package env

import (
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/joho/godotenv"
	"code-context-generator/pkg/constants"
)

// 环境变量常量定义
const (
	// 格式配置
	EnvDefaultFormat = constants.EnvPrefix + "DEFAULT_FORMAT"
	
	// 输出配置
	EnvOutputDir        = constants.EnvPrefix + "OUTPUT_DIR"
	EnvFilenameTemplate = constants.EnvPrefix + "FILENAME_TEMPLATE"
	EnvTimestampFormat  = constants.EnvPrefix + "TIMESTAMP_FORMAT"
	
	// 文件处理配置
	EnvMaxFileSize     = constants.EnvPrefix + "MAX_FILE_SIZE"
	EnvMaxDepth        = constants.EnvPrefix + "MAX_DEPTH"
	EnvRecursive       = constants.EnvPrefix + "RECURSIVE"
	EnvIncludeHidden   = constants.EnvPrefix + "INCLUDE_HIDDEN"
	EnvFollowSymlinks  = constants.EnvPrefix + "FOLLOW_SYMLINKS"
	EnvExcludeBinary   = constants.EnvPrefix + "EXCLUDE_BINARY"
	EnvExcludePatterns = constants.EnvPrefix + "EXCLUDE_PATTERNS"
)

// LoadEnv 加载.env文件到环境变量中
func LoadEnv(envPath string) error {
	// 如果没有指定路径，使用默认的.env文件
	if envPath == "" {
		envPath = ".env"
	}

	// 检查文件是否存在
	if _, err := os.Stat(envPath); os.IsNotExist(err) {
		// 如果文件不存在，不报错，直接返回
		return nil
	}

	// 加载.env文件
	if err := godotenv.Load(envPath); err != nil {
		return fmt.Errorf("加载.env文件失败: %w", err)
	}

	return nil
}

// GetEnvWithDefault 获取环境变量，如果不存在则返回默认值
func GetEnvWithDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// GetEnvBool 获取布尔类型的环境变量
func GetEnvBool(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}

// GetEnvInt 获取整数类型的环境变量
func GetEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

// GetEnvInt64 获取int64类型的环境变量
func GetEnvInt64(key string, defaultValue int64) int64 {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.ParseInt(value, 10, 64); err == nil {
			return intValue
		}
	}
	return defaultValue
}

// ParseFileSize 解析文件大小字符串 (例如: "10MB", "1KB")
func ParseFileSize(sizeStr string) int64 {
	sizeStr = strings.TrimSpace(strings.ToUpper(sizeStr))
	
	if sizeStr == "" {
		return 0
	}

	// 提取数字部分和单位部分
	var numStr string
	var unit string
	
	for i, char := range sizeStr {
		if char >= '0' && char <= '9' {
			numStr += string(char)
		} else {
			unit = strings.TrimSpace(sizeStr[i:])
			break
		}
	}

	if numStr == "" {
		return 0
	}

	size, err := strconv.ParseInt(numStr, 10, 64)
	if err != nil {
		return 0
	}

	// 根据单位转换
	switch unit {
	case "B", "":
		return size
	case "KB":
		return size * 1024
	case "MB":
		return size * 1024 * 1024
	case "GB":
		return size * 1024 * 1024 * 1024
	default:
		return size // 默认按字节处理
	}
}

// GetAllEnvVars 获取所有环境变量配置
func GetAllEnvVars() map[string]string {
	envVars := make(map[string]string)
	
	// 格式配置
	envVars[EnvDefaultFormat] = GetEnvWithDefault(EnvDefaultFormat, "xml")
	
	// 输出配置
	envVars[EnvOutputDir] = GetEnvWithDefault(EnvOutputDir, "")
	envVars[EnvFilenameTemplate] = GetEnvWithDefault(EnvFilenameTemplate, "")
	envVars[EnvTimestampFormat] = GetEnvWithDefault(EnvTimestampFormat, "")
	
	// 文件处理配置
	envVars[EnvMaxFileSize] = GetEnvWithDefault(EnvMaxFileSize, "")
	envVars[EnvMaxDepth] = GetEnvWithDefault(EnvMaxDepth, "")
	envVars[EnvRecursive] = strconv.FormatBool(GetEnvBool(EnvRecursive, false))
	envVars[EnvIncludeHidden] = strconv.FormatBool(GetEnvBool(EnvIncludeHidden, false))
	envVars[EnvFollowSymlinks] = strconv.FormatBool(GetEnvBool(EnvFollowSymlinks, false))
	envVars[EnvExcludeBinary] = strconv.FormatBool(GetEnvBool(EnvExcludeBinary, true))
	envVars[EnvExcludePatterns] = GetEnvWithDefault(EnvExcludePatterns, "")
	
	return envVars
}

// 获取默认格式配置
func GetDefaultFormat() string {
	return GetEnvWithDefault(EnvDefaultFormat, "xml")
}

// 获取输出目录配置
func GetOutputDir() string {
	return GetEnvWithDefault(EnvOutputDir, "")
}

// 获取文件名模板配置
func GetFilenameTemplate() string {
	return GetEnvWithDefault(EnvFilenameTemplate, "")
}

// 获取时间戳格式配置
func GetTimestampFormat() string {
	return GetEnvWithDefault(EnvTimestampFormat, "")
}

// 获取最大文件大小配置
func GetMaxFileSize() string {
	return GetEnvWithDefault(EnvMaxFileSize, "10MB")
}

// 获取最大深度配置
func GetMaxDepth() int {
	return GetEnvInt(EnvMaxDepth, 0)
}

// 获取是否递归配置
func GetRecursive() bool {
	return GetEnvBool(EnvRecursive, false)
}

// 获取是否包含隐藏文件配置
func GetIncludeHidden() bool {
	return GetEnvBool(EnvIncludeHidden, false)
}

// 获取是否跟随符号链接配置
func GetFollowSymlinks() bool {
	return GetEnvBool(EnvFollowSymlinks, false)
}

// 获取是否排除二进制文件配置
func GetExcludeBinary() bool {
	return GetEnvBool(EnvExcludeBinary, true)
}

// 获取排除模式配置
func GetExcludePatterns() string {
	return GetEnvWithDefault(EnvExcludePatterns, "")
}
func ApplyEnvOverrides(config map[string]interface{}) {
	envVars := GetAllEnvVars()
	
	for key, value := range envVars {
		if value != "" {
			config[key] = value
		}
	}
}
```

### filesystem.md

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\filesystem.md`
- **大小**: 539 字节
- **修改时间**: 2025-10-02T07:13:06+08:00

```md
// Package filesystem 提供文件系统遍历和过滤功能
package filesystem

// 文件系统功能已拆分到以下文件：
// - walker.go: 文件系统遍历器接口和主要遍历逻辑
// - fileinfo.go: 文件信息获取功能
// - filters.go: 文件过滤功能
// - utils.go: 通用文件系统工具函数
//
// 使用示例：
//   walker := filesystem.NewWalker()
//   contextData, err := walker.Walk(rootPath, options)
//
// 原有的所有功能仍然可用，只是按职责分离到了不同的文件中

```

### fileinfo.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\fileinfo.go`
- **大小**: 1763 字节
- **修改时间**: 2025-10-02T07:12:30+08:00

```go
// Package filesystem 提供文件系统遍历和过滤功能
package filesystem

import (
	"fmt"
	"os"
	"path/filepath"

	"code-context-generator/internal/utils"
	"code-context-generator/pkg/types"
)

// GetFileInfo 获取文件信息
func (w *FileSystemWalker) GetFileInfo(path string) (*types.FileInfo, error) {
	info, err := os.Stat(path)
	if err != nil {
		return nil, fmt.Errorf("获取文件状态失败: %w", err)
	}

	// 检查是否为二进制文件
	isBinary := !utils.IsTextFile(path)
	
	var content string
	if !isBinary {
		// 使用编码感知的文件读取
		fileContent, _, err := utils.ReadFileContent(path, 0) // 0表示无大小限制
		if err != nil {
			return nil, fmt.Errorf("读取文件内容失败: %w", err)
		}
		content = fileContent
	}

	return &types.FileInfo{
		Path:     path,
		Name:     info.Name(),
		Size:     info.Size(),
		ModTime:  info.ModTime(),
		IsDir:    info.IsDir(),
		Content:  content,
		IsBinary: isBinary,
	}, nil
}

// GetFolderInfo 获取文件夹信息
func (w *FileSystemWalker) GetFolderInfo(path string) (*types.FolderInfo, error) {
	info, err := os.Stat(path)
	if err != nil {
		return nil, fmt.Errorf("获取文件夹状态失败: %w", err)
	}

	// 读取文件夹内容
	entries, err := os.ReadDir(path)
	if err != nil {
		return nil, fmt.Errorf("读取文件夹内容失败: %w", err)
	}

	var files []types.FileInfo
	for _, entry := range entries {
		if !entry.IsDir() {
			filePath := filepath.Join(path, entry.Name())
			fileInfo, err := w.GetFileInfo(filePath)
			if err != nil {
				continue // 跳过无法读取的文件
			}
			files = append(files, *fileInfo)
		}
	}

	return &types.FolderInfo{
		Path:    path,
		Name:    info.Name(),
		ModTime: info.ModTime(),
		Files:   files,
	}, nil
}
```

### filters.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\filters.go`
- **大小**: 822 字节
- **修改时间**: 2025-10-02T07:13:11+08:00

```go
// Package filesystem 提供文件系统遍历和过滤功能
package filesystem

import (
	"os"
	"path/filepath"
)

// FilterFiles 根据模式过滤文件
func (w *FileSystemWalker) FilterFiles(files []string, patterns []string) []string {
	if len(patterns) == 0 {
		return files
	}

	var filtered []string
	for _, file := range files {
		for _, pattern := range patterns {
			matched, err := filepath.Match(pattern, filepath.Base(file))
			if err == nil && matched {
				filtered = append(filtered, file)
				break
			}
		}
	}

	return filtered
}

// FilterBySize 根据文件大小过滤
func (w *FileSystemWalker) FilterBySize(path string, maxSize int64) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}

	if maxSize <= 0 {
		return true // 没有大小限制
	}

	return info.Size() <= maxSize
}
```

### filesystem_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\filesystem_test.go`
- **大小**: 18866 字节
- **修改时间**: 2025-10-02T10:12:09+08:00

```go
package filesystem

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"code-context-generator/pkg/types"
)

func TestNewWalker(t *testing.T) {
	walker := NewWalker()
	if walker == nil {
		t.Fatal("NewWalker() returned nil")
	}

	// 检查类型
	if _, ok := walker.(*FileSystemWalker); !ok {
		t.Errorf("NewWalker() returned wrong type: %T", walker)
	}
}

func TestNewFileSystemWalker(t *testing.T) {
	options := types.WalkOptions{
		MaxDepth:        3,
		MaxFileSize:     1024 * 1024,
		ExcludePatterns: []string{"*.tmp"},
		IncludePatterns: []string{"*.go"},
		FollowSymlinks:  false,
	}

	walker := NewFileSystemWalker(options)
	if walker == nil {
		t.Fatal("NewFileSystemWalker() returned nil")
	}

	// 检查类型
	if _, ok := walker.(*FileSystemWalker); !ok {
		t.Errorf("NewFileSystemWalker() returned wrong type: %T", walker)
	}
}

func TestGetFileExtension(t *testing.T) {
	tests := []struct {
		filename string
		expected string
	}{
		{"test.go", ".go"},
		{"test.txt", ".txt"},
		{"test", ""},
		{"test.tar.gz", ".gz"},
		{"", ""},
		{".hidden", ""},
	}

	for _, tt := range tests {
		t.Run(tt.filename, func(t *testing.T) {
			result := GetFileExtension(tt.filename)
			if result != tt.expected {
				t.Errorf("GetFileExtension(%q) = %q, want %q", tt.filename, result, tt.expected)
			}
		})
	}
}

func TestIsHiddenFile(t *testing.T) {
	tests := []struct {
		filename string
		expected bool
	}{
		{".hidden", true},
		{"normal.txt", false},
		{"", false},
		{"..", true},
		{".git", true},
	}

	for _, tt := range tests {
		t.Run(tt.filename, func(t *testing.T) {
			result := IsHiddenFile(tt.filename)
			if result != tt.expected {
				t.Errorf("IsHiddenFile(%q) = %v, want %v", tt.filename, result, tt.expected)
			}
		})
	}
}

func TestIsDirectory(t *testing.T) {
	// 创建临时目录
	tempDir, err := os.MkdirTemp("", "test_dir")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// 创建临时文件
	tempFile, err := os.CreateTemp("", "test_file")
	if err != nil {
		t.Fatal(err)
	}
	tempFile.Close()
	defer os.Remove(tempFile.Name())

	tests := []struct {
		path     string
		expected bool
	}{
		{tempDir, true},
		{tempFile.Name(), false},
		{"nonexistent", false},
	}

	for _, tt := range tests {
		t.Run(tt.path, func(t *testing.T) {
			result := IsDirectory(tt.path)
			if result != tt.expected {
				t.Errorf("IsDirectory(%q) = %v, want %v", tt.path, result, tt.expected)
			}
		})
	}
}

func TestGetFileSize(t *testing.T) {
	// 创建临时文件
	tempFile, err := os.CreateTemp("", "test_file")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tempFile.Name())

	// 写入测试数据
	testData := []byte("Hello, World!")
	if _, err := tempFile.Write(testData); err != nil {
		t.Fatal(err)
	}
	tempFile.Close()

	size, err := GetFileSize(tempFile.Name())
	if err != nil {
		t.Fatalf("GetFileSize() error = %v", err)
	}

	if size != int64(len(testData)) {
		t.Errorf("GetFileSize() = %v, want %v", size, len(testData))
	}
}

func TestGetFileModTime(t *testing.T) {
	// 创建临时文件
	tempFile, err := os.CreateTemp("", "test_file")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tempFile.Name())
	tempFile.Close()

	modTime, err := GetFileModTime(tempFile.Name())
	if err != nil {
		t.Fatalf("GetFileModTime() error = %v", err)
	}

	// 检查时间是否合理（应该在过去1分钟内）
	now := time.Now()
	if modTime.After(now) || modTime.Before(now.Add(-time.Minute)) {
		t.Errorf("GetFileModTime() = %v, expected recent time", modTime)
	}
}

func TestCreateDirectory(t *testing.T) {
	tempDir, err := os.MkdirTemp("", "test_create")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	newDir := filepath.Join(tempDir, "new_directory")
	err = CreateDirectory(newDir)
	if err != nil {
		t.Fatalf("CreateDirectory() error = %v", err)
	}

	// 检查目录是否存在
	if _, err := os.Stat(newDir); os.IsNotExist(err) {
		t.Errorf("CreateDirectory() directory was not created")
	}

	// 测试创建已存在的目录（应该不报错）
	err = CreateDirectory(newDir)
	if err != nil {
		t.Errorf("CreateDirectory() failed for existing directory: %v", err)
	}
}

func TestRemoveDirectory(t *testing.T) {
	tempDir, err := os.MkdirTemp("", "test_remove")
	if err != nil {
		t.Fatal(err)
	}

	err = RemoveDirectory(tempDir)
	if err != nil {
		t.Fatalf("RemoveDirectory() error = %v", err)
	}

	// 检查目录是否被删除
	if _, err := os.Stat(tempDir); !os.IsNotExist(err) {
		t.Errorf("RemoveDirectory() directory still exists")
	}
}

func TestCopyFile(t *testing.T) {
	// 创建源文件
	srcFile, err := os.CreateTemp("", "src_file")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(srcFile.Name())

	// 写入测试数据
	testData := []byte("Hello, Copy Test!")
	if _, err := srcFile.Write(testData); err != nil {
		t.Fatal(err)
	}
	srcFile.Close()

	// 创建目标文件路径
	dstFile, err := os.CreateTemp("", "dst_file")
	if err != nil {
		t.Fatal(err)
	}
	dstPath := dstFile.Name()
	dstFile.Close()
	defer os.Remove(dstPath)

	// 复制文件
	err = CopyFile(srcFile.Name(), dstPath)
	if err != nil {
		t.Fatalf("CopyFile() error = %v", err)
	}

	// 验证内容
	dstContent, err := os.ReadFile(dstPath)
	if err != nil {
		t.Fatal(err)
	}

	if string(dstContent) != string(testData) {
		t.Errorf("CopyFile() content mismatch: got %q, want %q", string(dstContent), string(testData))
	}
}

func TestMoveFile(t *testing.T) {
	// 创建源文件
	srcFile, err := os.CreateTemp("", "src_file")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(srcFile.Name())

	// 写入测试数据
	testData := []byte("Hello, Move Test!")
	if _, err := srcFile.Write(testData); err != nil {
		t.Fatal(err)
	}
	srcFile.Close()

	// 创建目标目录
	tempDir, err := os.MkdirTemp("", "move_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	dstPath := filepath.Join(tempDir, "moved_file.txt")

	// 移动文件
	err = MoveFile(srcFile.Name(), dstPath)
	if err != nil {
		t.Fatalf("MoveFile() error = %v", err)
	}

	// 验证源文件不存在
	if _, err := os.Stat(srcFile.Name()); !os.IsNotExist(err) {
		t.Errorf("MoveFile() source file still exists")
	}

	// 验证目标文件存在且内容正确
	dstContent, err := os.ReadFile(dstPath)
	if err != nil {
		t.Fatal(err)
	}

	if string(dstContent) != string(testData) {
		t.Errorf("MoveFile() content mismatch: got %q, want %q", string(dstContent), string(testData))
	}
}

func TestGetDirectorySize(t *testing.T) {
	// 创建临时目录
	tempDir, err := os.MkdirTemp("", "size_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// 创建测试文件
	testFiles := []struct {
		name string
		size int
	}{
		{"file1.txt", 100},
		{"file2.txt", 200},
		{"subdir/file3.txt", 150},
	}

	totalSize := 0
	for _, tf := range testFiles {
		filePath := filepath.Join(tempDir, tf.name)
		dir := filepath.Dir(filePath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatal(err)
		}

		data := make([]byte, tf.size)
		if err := os.WriteFile(filePath, data, 0644); err != nil {
			t.Fatal(err)
		}
		totalSize += tf.size
	}

	size, err := GetDirectorySize(tempDir)
	if err != nil {
		t.Fatalf("GetDirectorySize() error = %v", err)
	}

	if size != int64(totalSize) {
		t.Errorf("GetDirectorySize() = %v, want %v", size, totalSize)
	}
}

func TestGetDirectoryFileCount(t *testing.T) {
	// 创建临时目录
	tempDir, err := os.MkdirTemp("", "count_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// 创建测试文件
	testFiles := []string{
		"file1.txt",
		"file2.txt",
		"subdir/file3.txt",
		"subdir/nested/file4.txt",
	}

	expectedCount := len(testFiles)
	for _, tf := range testFiles {
		filePath := filepath.Join(tempDir, tf)
		dir := filepath.Dir(filePath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatal(err)
		}

		if err := os.WriteFile(filePath, []byte("test"), 0644); err != nil {
			t.Fatal(err)
		}
	}

	count, err := GetDirectoryFileCount(tempDir)
	if err != nil {
		t.Fatalf("GetDirectoryFileCount() error = %v", err)
	}

	if count != expectedCount {
		t.Errorf("GetDirectoryFileCount() = %v, want %v", count, expectedCount)
	}
}

func TestFileSystemWalker_GetFileInfo(t *testing.T) {
	walker := &FileSystemWalker{}

	// 创建临时文件
	tempFile, err := os.CreateTemp("", "test_file")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tempFile.Name())

	// 写入测试数据
	testData := []byte("Test file content")
	if _, err := tempFile.Write(testData); err != nil {
		t.Fatal(err)
	}
	tempFile.Close()

	fileInfo, err := walker.GetFileInfo(tempFile.Name())
	if err != nil {
		t.Fatalf("GetFileInfo() error = %v", err)
	}

	// 验证文件信息
	if fileInfo.Path != tempFile.Name() {
		t.Errorf("GetFileInfo() Path = %v, want %v", fileInfo.Path, tempFile.Name())
	}

	if fileInfo.Size != int64(len(testData)) {
		t.Errorf("GetFileInfo() Size = %v, want %v", fileInfo.Size, len(testData))
	}

	if fileInfo.Content != string(testData) {
		t.Errorf("GetFileInfo() Content = %v, want %v", fileInfo.Content, string(testData))
	}

	if fileInfo.IsDir {
		t.Error("GetFileInfo() IsDir should be false for file")
	}
}

func TestFileSystemWalker_GetFolderInfo(t *testing.T) {
	walker := &FileSystemWalker{}

	// 创建临时目录
	tempDir, err := os.MkdirTemp("", "folder_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// 在目录中创建一些文件
	testFiles := []string{"file1.txt", "file2.go"}
	for _, filename := range testFiles {
		filePath := filepath.Join(tempDir, filename)
		if err := os.WriteFile(filePath, []byte("test content"), 0644); err != nil {
			t.Fatal(err)
		}
	}

	folderInfo, err := walker.GetFolderInfo(tempDir)
	if err != nil {
		t.Fatalf("GetFolderInfo() error = %v", err)
	}

	// 验证文件夹信息
	if folderInfo.Path != tempDir {
		t.Errorf("GetFolderInfo() Path = %v, want %v", folderInfo.Path, tempDir)
	}

	if len(folderInfo.Files) != len(testFiles) {
		t.Errorf("GetFolderInfo() Files count = %v, want %v", len(folderInfo.Files), len(testFiles))
	}
}

func TestFileSystemWalker_FilterFiles(t *testing.T) {
	walker := &FileSystemWalker{}

	files := []string{
		"/path/to/file1.txt",
		"/path/to/file2.go",
		"/path/to/test.log",
		"/path/to/config.yaml",
	}

	patterns := []string{"*.txt", "*.go"}

	filtered := walker.FilterFiles(files, patterns)

	expected := []string{
		"/path/to/file1.txt",
		"/path/to/file2.go",
	}

	if len(filtered) != len(expected) {
		t.Errorf("FilterFiles() returned %d files, want %d", len(filtered), len(expected))
	}

	for i, file := range filtered {
		if file != expected[i] {
			t.Errorf("FilterFiles()[%d] = %v, want %v", i, file, expected[i])
		}
	}
}

func TestFileSystemWalker_FilterBySize(t *testing.T) {
	walker := &FileSystemWalker{}

	// 创建临时文件
	tempFile, err := os.CreateTemp("", "size_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tempFile.Name())

	// 写入测试数据
	testData := []byte("Test data for size filtering")
	if _, err := tempFile.Write(testData); err != nil {
		t.Fatal(err)
	}
	tempFile.Close()

	tests := []struct {
		name     string
		maxSize  int64
		expected bool
	}{
		{"within limit", int64(len(testData) + 10), true},
		{"exact size", int64(len(testData)), true},
		{"exceeds limit", int64(len(testData) - 1), false},
		{"no limit", 0, true},
		{"negative limit", -1, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := walker.FilterBySize(tempFile.Name(), tt.maxSize)
			if result != tt.expected {
				t.Errorf("FilterBySize() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestFileSystemWalker_Walk(t *testing.T) {
	walker := &FileSystemWalker{}

	// 创建临时目录结构
	tempDir, err := os.MkdirTemp("", "walk_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// 创建测试文件结构
	testStructure := map[string]string{
		"file1.txt":              "content1",
		"file2.go":               "content2",
		"subdir/file3.txt":       "content3",
		"subdir/nested/file4.go": "content4",
	}

	for path, content := range testStructure {
		fullPath := filepath.Join(tempDir, path)
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			t.Fatal(err)
		}
	}

	// 测试基本遍历
	t.Run("basic walk", func(t *testing.T) {
		options := &types.WalkOptions{
			MaxDepth:        3,
			MaxFileSize:     1024 * 1024,
			ExcludePatterns: []string{},
			IncludePatterns: []string{},
			ShowHidden:      false,
		}

		contextData, err := walker.Walk(tempDir, options)
		if err != nil {
			t.Fatalf("Walk() error = %v", err)
		}

		// 验证文件数量
		if len(contextData.Files) != len(testStructure) {
			t.Errorf("Walk() found %d files, want %d", len(contextData.Files), len(testStructure))
		}

		// 验证文件夹数量
		if len(contextData.Folders) != 2 { // subdir 和 subdir/nested
			t.Errorf("Walk() found %d folders, want 2", len(contextData.Folders))
		}
	})

	// 测试深度限制
	t.Run("depth limit", func(t *testing.T) {
		options := &types.WalkOptions{
			MaxDepth:        1,
			MaxFileSize:     1024 * 1024,
			ExcludePatterns: []string{},
			IncludePatterns: []string{},
			ShowHidden:      false,
		}

		contextData, err := walker.Walk(tempDir, options)
		if err != nil {
			t.Fatalf("Walk() error = %v", err)
		}

		// 应该只找到根目录的文件
		expectedRootFiles := 2 // file1.txt 和 file2.go
		if len(contextData.Files) != expectedRootFiles {
			t.Errorf("Walk() with depth limit found %d files, want %d", len(contextData.Files), expectedRootFiles)
		}
	})

	// 测试包含模式
	t.Run("include patterns", func(t *testing.T) {
		options := &types.WalkOptions{
			MaxDepth:        3,
			MaxFileSize:     1024 * 1024,
			ExcludePatterns: []string{},
			IncludePatterns: []string{"*.txt"},
			ShowHidden:      false,
		}

		contextData, err := walker.Walk(tempDir, options)
		if err != nil {
			t.Fatalf("Walk() error = %v", err)
		}

		// 应该只找到.txt文件
		expectedTxtFiles := 2 // file1.txt 和 subdir/file3.txt
		if len(contextData.Files) != expectedTxtFiles {
			t.Errorf("Walk() with include patterns found %d files, want %d", len(contextData.Files), expectedTxtFiles)
		}
	})

	// 测试排除模式
	t.Run("exclude patterns", func(t *testing.T) {
		options := &types.WalkOptions{
			MaxDepth:        3,
			MaxFileSize:     1024 * 1024,
			ExcludePatterns: []string{"*.go"},
			IncludePatterns: []string{},
			ShowHidden:      false,
		}

		contextData, err := walker.Walk(tempDir, options)
		if err != nil {
			t.Fatalf("Walk() error = %v", err)
		}

		// 应该只找到非.go文件
		expectedNonGoFiles := 2 // file1.txt 和 subdir/file3.txt
		if len(contextData.Files) != expectedNonGoFiles {
			t.Errorf("Walk() with exclude patterns found %d files, want %d", len(contextData.Files), expectedNonGoFiles)
		}
	})

	// 测试大小限制
	t.Run("size limit", func(t *testing.T) {
		options := &types.WalkOptions{
			MaxDepth:        3,
			MaxFileSize:     5, // 很小的限制（小于8字节）
			ExcludePatterns: []string{},
			IncludePatterns: []string{},
			ShowHidden:      false,
		}

		contextData, err := walker.Walk(tempDir, options)
		if err != nil {
			t.Fatalf("Walk() error = %v", err)
		}

		// 应该没有找到文件（所有文件都超过5字节）
		if len(contextData.Files) != 0 {
			t.Errorf("Walk() with size limit found %d files, want 0", len(contextData.Files))
		}
	})
}

func TestFileSystemWalker_shouldIncludeFile(t *testing.T) {
	walker := &FileSystemWalker{}

	// 创建临时文件
	tempFile, err := os.CreateTemp("", "include_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tempFile.Name())

	// 写入测试数据
	testData := []byte("Test inclusion")
	if _, err := tempFile.Write(testData); err != nil {
		t.Fatal(err)
	}
	tempFile.Close()

	tests := []struct {
		name     string
		options  *types.WalkOptions
		expected bool
	}{
		{
			name: "include all",
			options: &types.WalkOptions{
				MaxFileSize:     1024 * 1024,
				IncludePatterns: []string{},
				ExcludePatterns: []string{},
				ShowHidden:      false,
			},
			expected: true,
		},
		{
			name: "exclude by pattern",
			options: &types.WalkOptions{
				MaxFileSize:     1024 * 1024,
				IncludePatterns: []string{},
				ExcludePatterns: []string{"*.tmp"},
				ShowHidden:      false,
			},
			expected: true, // 我们的测试文件不是.tmp
		},
		{
			name: "include by pattern",
			options: &types.WalkOptions{
				MaxFileSize:     1024 * 1024,
				IncludePatterns: []string{"*.tmp"},
				ExcludePatterns: []string{},
				ShowHidden:      false,
			},
			expected: false, // 我们的测试文件不是.tmp
		},
		{
			name: "size exceeded",
			options: &types.WalkOptions{
				MaxFileSize:     5, // 小于文件大小
				IncludePatterns: []string{},
				ExcludePatterns: []string{},
				ShowHidden:      false,
			},
			expected: false,
		},
		{
			name: "hidden file",
			options: &types.WalkOptions{
				MaxFileSize:     1024 * 1024,
				IncludePatterns: []string{},
				ExcludePatterns: []string{},
				ShowHidden:      false,
			},
			expected: true, // 我们的测试文件不是隐藏文件
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := walker.shouldIncludeFile(tempFile.Name(), "", tt.options)
			if result != tt.expected {
				t.Errorf("shouldIncludeFile() = %v, want %v", result, tt.expected)
			}
		})
	}
}

// 基准测试
func BenchmarkGetFileExtension(b *testing.B) {
	for i := 0; i < b.N; i++ {
		GetFileExtension("test.file.extension.txt")
	}
}

func BenchmarkIsHiddenFile(b *testing.B) {
	for i := 0; i < b.N; i++ {
		IsHiddenFile(".hidden_file")
	}
}

func BenchmarkFilterFiles(b *testing.B) {
	walker := &FileSystemWalker{}
	files := []string{
		"file1.txt", "file2.go", "file3.log", "file4.yaml",
		"file5.json", "file6.md", "file7.py", "file8.rs",
	}
	patterns := []string{"*.txt", "*.go", "*.md"}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		walker.FilterFiles(files, patterns)
	}
}

```

### utils.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\utils.go`
- **大小**: 2919 字节
- **修改时间**: 2025-10-02T07:13:00+08:00

```go
// Package filesystem 提供文件系统遍历和过滤功能
package filesystem

import (
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"code-context-generator/internal/utils"
)

// GetFileExtension 获取文件扩展名
func GetFileExtension(filename string) string {
	// 隐藏文件（以.开头）没有扩展名
	if strings.HasPrefix(filename, ".") && len(filename) > 1 {
		// 检查是否包含另一个点（如.gitignore）
		lastDotIndex := strings.LastIndex(filename, ".")
		if lastDotIndex == 0 {
			// 只有开头的点，没有扩展名
			return ""
		}
	}
	return filepath.Ext(filename)
}

// IsHiddenFile 检查是否为隐藏文件
func IsHiddenFile(filename string) bool {
	return strings.HasPrefix(filename, ".")
}

// GetFileSize 获取文件大小
func GetFileSize(path string) (int64, error) {
	return utils.GetFileSize(path)
}

// GetFileModTime 获取文件修改时间
func GetFileModTime(path string) (time.Time, error) {
	return utils.GetFileModTime(path)
}

// IsDirectory 检查是否为目录
func IsDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}

// IsSymlink 检查是否为符号链接
func IsSymlink(path string) bool {
	info, err := os.Lstat(path)
	if err != nil {
		return false
	}
	return info.Mode()&os.ModeSymlink != 0
}

// GetSymlinkTarget 获取符号链接目标
func GetSymlinkTarget(path string) (string, error) {
	target, err := os.Readlink(path)
	if err != nil {
		return "", err
	}

	// 如果是相对路径，转换为绝对路径
	if !filepath.IsAbs(target) {
		dir := filepath.Dir(path)
		target = filepath.Join(dir, target)
	}

	return filepath.Abs(target)
}

// CreateDirectory 创建目录
func CreateDirectory(path string) error {
	return os.MkdirAll(path, 0755)
}

// RemoveDirectory 删除目录
func RemoveDirectory(path string) error {
	return os.RemoveAll(path)
}

// CopyFile 复制文件
func CopyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

// MoveFile 移动文件
func MoveFile(src, dst string) error {
	return os.Rename(src, dst)
}

// GetDirectorySize 获取目录大小
func GetDirectorySize(path string) (int64, error) {
	var size int64
	err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			size += info.Size()
		}
		return nil
	})
	return size, err
}

// GetDirectoryFileCount 获取目录中的文件数量
func GetDirectoryFileCount(path string) (int, error) {
	count := 0
	err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			count++
		}
		return nil
	})
	return count, err
}
```

### walker.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\walker.go`
- **大小**: 8418 字节
- **修改时间**: 2025-10-02T16:35:35+08:00

```go
// Package filesystem 提供文件系统遍历和过滤功能
package filesystem

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"code-context-generator/internal/utils"
	"code-context-generator/pkg/constants"
	"code-context-generator/pkg/types"
)

// Walker 文件系统遍历器接口
type Walker interface {
	Walk(rootPath string, options *types.WalkOptions) (*types.ContextData, error)
	WalkWithProgress(rootPath string, options *types.WalkOptions, progressCallback func(processed, total int, currentFile string)) (*types.ContextData, error)
	GetFileInfo(path string) (*types.FileInfo, error)
	GetFolderInfo(path string) (*types.FolderInfo, error)
	FilterFiles(files []string, patterns []string) []string
	FilterBySize(path string, maxSize int64) bool
}

// FileSystemWalker 文件系统遍历器实现
type FileSystemWalker struct {
	mu           sync.RWMutex
	maxWorkers   int
	maxFileCount int
	maxDepth     int
	timeout      time.Duration
}

// NewWalker 创建遍历器
func NewWalker() Walker {
	return &FileSystemWalker{
		maxWorkers:   10,              // 限制并发worker数量
		maxFileCount: 10000,           // 限制最大文件数量
		maxDepth:     20,              // 限制最大深度
		timeout:      30 * time.Second, // 30秒超时
	}
}

// NewFileSystemWalker 创建新的文件系统遍历器（别名）
func NewFileSystemWalker(options types.WalkOptions) Walker {
	return &FileSystemWalker{}
}

// Walk 遍历文件系统
func (w *FileSystemWalker) Walk(rootPath string, options *types.WalkOptions) (*types.ContextData, error) {
	return w.WalkWithProgress(rootPath, options, nil)
}

// WalkWithProgress 带进度回调的遍历文件系统
func (w *FileSystemWalker) WalkWithProgress(rootPath string, options *types.WalkOptions, progressCallback func(processed, total int, currentFile string)) (*types.ContextData, error) {
	if options == nil {
		options = &types.WalkOptions{
			MaxDepth:        constants.DefaultMaxDepth,
			MaxFileSize:     10 * 1024 * 1024,
			ExcludePatterns: constants.DefaultExcludePatterns,
			IncludePatterns: []string{},
			FollowSymlinks:  false,
		}
	}

	// 验证根路径
	if _, err := os.Stat(rootPath); err != nil {
		return nil, fmt.Errorf("根路径不存在: %w", err)
	}

	var contextData types.ContextData
	var wg sync.WaitGroup
	var mu sync.Mutex
	var walkErrors []error
	
	// 初始化contextData的统计信息
	contextData.Files = []types.FileInfo{}
	contextData.Folders = []types.FolderInfo{}
	contextData.Metadata = make(map[string]interface{})

	// 首先统计总文件数
	totalFiles := 0
	processedFiles := 0
	filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}
		if w.shouldIncludeFile(path, rootPath, options) {
			totalFiles++
		}
		return nil
	})

	// 限制文件数量
	if totalFiles > w.maxFileCount {
		return nil, fmt.Errorf("文件数量超过限制: %d > %d", totalFiles, w.maxFileCount)
	}

	semaphore := make(chan struct{}, w.maxWorkers) // 限制并发数量
	progressMu := sync.Mutex{} // 保护进度更新

	// 遍历文件系统
	err := filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			walkErrors = append(walkErrors, err)
			return nil // 继续遍历
		}

		// 检查深度限制
		relPath, err := filepath.Rel(rootPath, path)
		if err != nil {
			return err
		}

		depth := strings.Count(relPath, string(os.PathSeparator))
		if options.MaxDepth > 0 && depth >= options.MaxDepth {
			if info.IsDir() {
				return filepath.SkipDir
			}
			// 跳过深度超过限制的文件
			return nil
		}

		// 处理文件
		if !info.IsDir() && w.shouldIncludeFile(path, rootPath, options) {
			semaphore <- struct{}{} // 获取信号量
			wg.Add(1)
			go func(filePath string, rootPath string) {
				defer func() {
					<-semaphore // 释放信号量
					wg.Done()
				}()

				// 获取文件信息
				fileInfo, err := w.GetFileInfo(filePath)
				if err != nil {
					mu.Lock()
					walkErrors = append(walkErrors, fmt.Errorf("获取文件信息失败 %s: %w", filePath, err))
					mu.Unlock()
					return
				}

				mu.Lock()
				contextData.Files = append(contextData.Files, *fileInfo)
				contextData.FileCount++
				contextData.TotalSize += fileInfo.Size
				mu.Unlock()

				// 更新进度
				progressMu.Lock()
				processedFiles++
				currentProcessed := processedFiles
				progressMu.Unlock()
				
				if progressCallback != nil && currentProcessed%10 == 0 { // 每10个文件更新一次进度
					progressCallback(currentProcessed, totalFiles, filepath.Base(filePath))
				}
			}(path, rootPath)
		} else if info.IsDir() {
			// 处理文件夹
			if path != rootPath { // 跳过根路径
				folderInfo, err := w.GetFolderInfo(path)
				if err != nil {
					mu.Lock()
					walkErrors = append(walkErrors, fmt.Errorf("获取文件夹信息失败 %s: %w", path, err))
					mu.Unlock()
					return nil
				}

				mu.Lock()
				contextData.Folders = append(contextData.Folders, *folderInfo)
				contextData.FolderCount++
				mu.Unlock()
			}
		}

		return nil
	})

	wg.Wait()

	// 最终进度更新
	if progressCallback != nil {
		progressCallback(totalFiles, totalFiles, "完成")
	}

	if err != nil {
		return nil, fmt.Errorf("遍历文件系统失败: %w", err)
	}

	if len(walkErrors) > 0 {
		// 记录错误但不中断流程
		fmt.Printf("遍历过程中遇到 %d 个错误\n", len(walkErrors))
		for _, e := range walkErrors {
			fmt.Printf("  - %v\n", e)
		}
	}

	return &contextData, nil
}

// shouldIncludeFile 检查是否应该包含文件
func (w *FileSystemWalker) shouldIncludeFile(path string, rootPath string, options *types.WalkOptions) bool {
	// 如果指定了选中的文件，只包含这些文件
	if len(options.SelectedFiles) > 0 {
		// 将路径转换为绝对路径进行比较
		absPath, err := filepath.Abs(path)
		if err != nil {
			return false
		}
		
		for _, selectedFile := range options.SelectedFiles {
			absSelectedFile, err := filepath.Abs(selectedFile)
			if err != nil {
				continue
			}
			if absPath == absSelectedFile {
				return true
			}
		}
		return false
	}

	// 检查文件大小
	if !w.FilterBySize(path, options.MaxFileSize) {
		return false
	}

	// 检查是否为二进制文件（如果启用了二进制文件排除）
	if options.ExcludeBinary && utils.IsBinaryFile(path) {
		return false
	}

	// 检查包含模式
	if len(options.IncludePatterns) > 0 {
		matched := false
		filename := filepath.Base(path)
		for _, pattern := range options.IncludePatterns {
			if matchedPattern, _ := filepath.Match(pattern, filename); matchedPattern {
				matched = true
				break
			}
			// 尝试匹配相对路径（用于目录模式如 *.go）
			if strings.Contains(pattern, "/") {
				rel, _ := filepath.Rel(rootPath, path)
				// 将Windows路径分隔符转换为正斜杠以匹配模式
				rel = filepath.ToSlash(rel)
				if matchedPattern, _ := filepath.Match(pattern, rel); matchedPattern {
					matched = true
					break
				}
			}
		}
		if !matched {
			return false
		}
	}

	// 检查排除模式
	if len(options.ExcludePatterns) > 0 {
		filename := filepath.Base(path)
		for _, pattern := range options.ExcludePatterns {
			// 尝试匹配文件名
			if matchedPattern, _ := filepath.Match(pattern, filename); matchedPattern {
				return false
			}
			// 尝试匹配相对路径（用于目录模式如 .git/）
			if strings.Contains(pattern, "/") {
				rel, _ := filepath.Rel(rootPath, path)
				// 将Windows路径分隔符转换为正斜杠以匹配模式
				rel = filepath.ToSlash(rel)

				if matchedPattern, _ := filepath.Match(pattern, rel); matchedPattern {
					return false
				}
				// 对于目录模式（以/结尾），检查文件是否在匹配目录下
				if strings.HasSuffix(pattern, "/") {
					dirPattern := strings.TrimSuffix(pattern, "/")
					// 检查相对路径是否以目录模式开头
					if strings.HasPrefix(rel, dirPattern+"/") {
						return false
					}
					// 检查路径中的任何目录部分是否匹配
					pathDirs := strings.Split(rel, "/")
					for i, dir := range pathDirs {
						if matchedDir, _ := filepath.Match(dirPattern, dir); matchedDir {
							// 确保这是完整目录名匹配，而不是部分匹配
							if i < len(pathDirs)-1 || rel == dirPattern {
								return false
							}
						}
					}
				}
			}
		}
	}
	
	return true
}
```

### walker_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\walker_test.go`
- **大小**: 9812 字节
- **修改时间**: 2025-10-02T10:19:04+08:00

```go
package filesystem

import (
	"os"
	"path/filepath"
	"testing"

	"code-context-generator/pkg/types"
)

// TestShouldIncludeFile 测试文件包含/排除逻辑
func TestShouldIncludeFile(t *testing.T) {
	// 创建临时测试目录结构
	tempDir := t.TempDir()
	
	// 创建测试文件结构
	testFiles := []string{
		"file1.go",
		"file2.txt", 
		"file3.md",
		"test.log",
		".hidden.txt",
		"subdir/file4.go",
		"subdir/file5.txt",
		"subdir/nested/file6.go",
		".git/config",
		".git/HEAD",
		".git/hooks/pre-commit",
		"node_modules/package/index.js",
		"build/output.exe",
		"build/temp.obj",
		"docs/readme.md",
		"docs/guide/install.md",
		"vendor/lib/file.go",
		"coverage.out",
		"file.swp",
	}

	// 创建目录和文件
	for _, file := range testFiles {
		fullPath := filepath.Join(tempDir, file)
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("创建目录失败 %s: %v", dir, err)
		}
		if err := os.WriteFile(fullPath, []byte("test content"), 0644); err != nil {
			t.Fatalf("创建文件失败 %s: %v", file, err)
		}
	}

	walker := &FileSystemWalker{}

	tests := []struct {
		name     string
		filePath string
		options  *types.WalkOptions
		expected bool
		desc     string
	}{
		{
			name:     "包含所有文件",
			filePath: filepath.Join(tempDir, "file1.go"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{},
				IncludePatterns: []string{},
			},
			expected: true,
			desc:     "没有排除模式时应该包含文件",
		},
		{
			name:     "排除.git目录文件",
			filePath: filepath.Join(tempDir, ".git/config"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{".git/"},
			},
			expected: false,
			desc:     "应该排除.git/目录下的文件",
		},
		{
			name:     "排除.git目录文件-HEAD",
			filePath: filepath.Join(tempDir, ".git/HEAD"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{".git/"},
			},
			expected: false,
			desc:     "应该排除.git/目录下的HEAD文件",
		},
		{
			name:     "排除node_modules目录",
			filePath: filepath.Join(tempDir, "node_modules/package/index.js"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{"node_modules/"},
			},
			expected: false,
			desc:     "应该排除node_modules/目录下的文件",
		},
		{
			name:     "排除build目录",
			filePath: filepath.Join(tempDir, "build/output.exe"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{"build/"},
			},
			expected: false,
			desc:     "应该排除build/目录下的文件",
		},
		{
			name:     "排除vendor目录",
			filePath: filepath.Join(tempDir, "vendor/lib/file.go"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{"vendor/"},
			},
			expected: false,
			desc:     "应该排除vendor/目录下的文件",
		},
		{
			name:     "按扩展名排除",
			filePath: filepath.Join(tempDir, "test.log"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{"*.log"},
			},
			expected: false,
			desc:     "应该排除.log文件",
		},
		{
			name:     "按扩展名排除.swp",
			filePath: filepath.Join(tempDir, "file.swp"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{"*.swp"},
			},
			expected: false,
			desc:     "应该排除.swp文件",
		},
		{
			name:     "包含模式匹配",
			filePath: filepath.Join(tempDir, "file1.go"),
			options: &types.WalkOptions{
				IncludePatterns: []string{"*.go"},
			},
			expected: true,
			desc:     "应该包含匹配包含模式的.go文件",
		},
		{
			name:     "包含模式不匹配",
			filePath: filepath.Join(tempDir, "file2.txt"),
			options: &types.WalkOptions{
				IncludePatterns: []string{"*.go"},
			},
			expected: false,
			desc:     "应该排除不匹配包含模式的.txt文件",
		},
		{
			name:     "目录包含模式",
			filePath: filepath.Join(tempDir, "docs/readme.md"),
			options: &types.WalkOptions{
				IncludePatterns: []string{"docs/*.md"},
			},
			expected: true,
			desc:     "应该包含匹配目录模式的docs/readme.md文件",
		},
		{
			name:     "目录包含模式不匹配",
			filePath: filepath.Join(tempDir, "file3.md"),
			options: &types.WalkOptions{
				IncludePatterns: []string{"docs/*.md"},
			},
			expected: false,
			desc:     "应该排除不匹配目录模式的根目录.md文件",
		},
		{
			name:     "多级目录包含模式",
			filePath: filepath.Join(tempDir, "docs/guide/install.md"),
			options: &types.WalkOptions{
				IncludePatterns: []string{"docs/**/*.md"},
			},
			expected: true,
			desc:     "应该包含匹配多级目录模式的文件",
		},
		{
			name:     "排除和包含模式组合",
			filePath: filepath.Join(tempDir, "subdir/file4.go"),
			options: &types.WalkOptions{
				ExcludePatterns: []string{"*.txt"},
				IncludePatterns: []string{"*.go"},
			},
			expected: true,
			desc:     "应该包含.go文件即使.txt被排除",
		},
		{
			name:     "Windows路径分隔符测试",
			filePath: filepath.Join(tempDir, "subdir\\file4.go"),
			options: &types.WalkOptions{
				IncludePatterns: []string{"subdir/*.go"},
			},
			expected: true,
			desc:     "应该正确处理Windows路径分隔符",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := walker.shouldIncludeFile(tt.filePath, tempDir, tt.options)
			if result != tt.expected {
				t.Errorf("%s: shouldIncludeFile() = %v, want %v\n描述: %s\n文件: %s\n选项: %+v", 
					tt.name, result, tt.expected, tt.desc, tt.filePath, tt.options)
			}
		})
	}
}

// TestWalkWithExcludePatterns 测试实际的Walk函数与排除模式
func TestWalkWithExcludePatterns(t *testing.T) {
	// 创建临时测试目录结构
	tempDir := t.TempDir()
	
	// 创建测试文件结构
	testFiles := []string{
		"main.go",
		"readme.md", 
		".git/config",
		".git/HEAD",
		"node_modules/lib/index.js",
		"build/output.exe",
		"vendor/lib/helper.go",
		"test.log",
		"coverage.out",
	}

	// 创建目录和文件
	for _, file := range testFiles {
		fullPath := filepath.Join(tempDir, file)
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("创建目录失败 %s: %v", dir, err)
		}
		if err := os.WriteFile(fullPath, []byte("test content"), 0644); err != nil {
			t.Fatalf("创建文件失败 %s: %v", file, err)
		}
	}

	walker := NewWalker()
	
	options := &types.WalkOptions{
		ExcludePatterns: []string{
			".git/",
			"node_modules/", 
			"build/",
			"vendor/",
			"*.log",
			"*.out",
		},
		MaxDepth: 10,
	}

	result, err := walker.Walk(tempDir, options)
	if err != nil {
		t.Fatalf("Walk() error = %v", err)
	}

	// 验证结果
	if result == nil {
		t.Fatal("Walk() returned nil result")
	}

	// 检查应该包含的文件
	expectedFiles := []string{"main.go", "readme.md"}
	for _, expectedFile := range expectedFiles {
		found := false
		for _, file := range result.Files {
			if filepath.Base(file.Path) == expectedFile {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("应该包含文件 %s", expectedFile)
		}
	}

	// 检查应该排除的文件
	excludedFiles := []string{"config", "HEAD", "index.js", "output.exe", "helper.go", "test.log", "coverage.out"}
	for _, excludedFile := range excludedFiles {
		found := false
		for _, file := range result.Files {
			if filepath.Base(file.Path) == excludedFile {
				found = true
				break
			}
		}
		if found {
			t.Errorf("应该排除文件 %s", excludedFile)
		}
	}

	// 验证文件数量
	expectedFileCount := len(expectedFiles)
	if result.FileCount != expectedFileCount {
		t.Errorf("文件数量不匹配: got %d, want %d", result.FileCount, expectedFileCount)
	}

	t.Logf("测试通过: 找到 %d 个文件, 期望 %d 个文件", result.FileCount, expectedFileCount)
	for _, file := range result.Files {
		t.Logf("包含文件: %s", file.Path)
	}
}

// TestWalkWithIncludePatterns 测试实际的Walk函数与包含模式
func TestWalkWithIncludePatterns(t *testing.T) {
	// 创建临时测试目录结构
	tempDir := t.TempDir()
	
	// 创建测试文件结构
	testFiles := []string{
		"main.go",
		"helper.go", 
		"readme.md",
		"config.json",
		"test.txt",
		"docs/guide.md",
		"docs/api.txt",
		"src/utils.js",
		"src/styles.css",
	}

	// 创建目录和文件
	for _, file := range testFiles {
		fullPath := filepath.Join(tempDir, file)
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("创建目录失败 %s: %v", dir, err)
		}
		if err := os.WriteFile(fullPath, []byte("test content"), 0644); err != nil {
			t.Fatalf("创建文件失败 %s: %v", file, err)
		}
	}

	walker := NewWalker()
	
	options := &types.WalkOptions{
		IncludePatterns: []string{
			"*.go",
			"docs/*.md",
		},
		MaxDepth: 10,
	}

	result, err := walker.Walk(tempDir, options)
	if err != nil {
		t.Fatalf("Walk() error = %v", err)
	}

	// 验证结果
	if result == nil {
		t.Fatal("Walk() returned nil result")
	}

	// 检查应该包含的文件
	expectedFiles := []string{"main.go", "helper.go", "guide.md"}
	for _, expectedFile := range expectedFiles {
		found := false
		for _, file := range result.Files {
			if filepath.Base(file.Path) == expectedFile {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("应该包含文件 %s", expectedFile)
		}
	}

	// 检查应该排除的文件
	excludedFiles := []string{"readme.md", "config.json", "test.txt", "api.txt", "utils.js", "styles.css"}
	for _, excludedFile := range excludedFiles {
		found := false
		for _, file := range result.Files {
			if filepath.Base(file.Path) == excludedFile {
				found = true
				break
			}
		}
		if found {
			t.Errorf("应该排除文件 %s", excludedFile)
		}
	}

	t.Logf("测试通过: 找到 %d 个文件", result.FileCount)
	for _, file := range result.Files {
		t.Logf("包含文件: %s", file.Path)
	}
}
```

### walker_debug_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem\walker_debug_test.go`
- **大小**: 2015 字节
- **修改时间**: 2025-10-02T10:19:49+08:00

```go
package filesystem

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"code-context-generator/pkg/types"
)

// TestShouldIncludeFileDebug 测试文件包含/排除逻辑（带调试输出）
func TestShouldIncludeFileDebug(t *testing.T) {
	// 创建临时测试目录结构
	tempDir := t.TempDir()
	
	// 创建测试文件结构
	testFiles := []string{
		"node_modules/package/index.js",
		"vendor/lib/file.go",
	}

	// 创建目录和文件
	for _, file := range testFiles {
		fullPath := filepath.Join(tempDir, file)
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("创建目录失败 %s: %v", dir, err)
		}
		if err := os.WriteFile(fullPath, []byte("test content"), 0644); err != nil {
			t.Fatalf("创建文件失败 %s: %v", file, err)
		}
	}

	walker := &FileSystemWalker{}

	// 测试 node_modules 排除
	nodeModulesPath := filepath.Join(tempDir, "node_modules/package/index.js")
	options := &types.WalkOptions{
		ExcludePatterns: []string{"node_modules/"},
	}
	
	fmt.Printf("\n=== 测试 node_modules 排除 ===\n")
	fmt.Printf("文件路径: %s\n", nodeModulesPath)
	fmt.Printf("根路径: %s\n", tempDir)
	fmt.Printf("排除模式: %v\n", options.ExcludePatterns)
	
	result := walker.shouldIncludeFile(nodeModulesPath, tempDir, options)
	fmt.Printf("结果: %v (期望: false)\n", result)
	
	if result != false {
		t.Errorf("node_modules 排除失败: got %v, want false", result)
	}

	// 测试 vendor 排除
	vendorPath := filepath.Join(tempDir, "vendor/lib/file.go")
	options2 := &types.WalkOptions{
		ExcludePatterns: []string{"vendor/"},
	}
	
	fmt.Printf("\n=== 测试 vendor 排除 ===\n")
	fmt.Printf("文件路径: %s\n", vendorPath)
	fmt.Printf("根路径: %s\n", tempDir)
	fmt.Printf("排除模式: %v\n", options2.ExcludePatterns)
	
	result2 := walker.shouldIncludeFile(vendorPath, tempDir, options2)
	fmt.Printf("结果: %v (期望: false)\n", result2)
	
	if result2 != false {
		t.Errorf("vendor 排除失败: got %v, want false", result2)
	}
}
```

### formatter.go

- **路径**: `D:\ide\tool\code-context-generator\internal\formatter\formatter.go`
- **大小**: 22731 字节
- **修改时间**: 2025-10-02T12:47:51+08:00

```go
// Package formatter 提供多种格式的输出转换功能
package formatter

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"path/filepath"
	"strings"
	"time"


	"code-context-generator/pkg/constants"
	"code-context-generator/pkg/types"
)

// CDATAText 包装CDATA文本的类型
type CDATAText struct {
	Text string `xml:",cdata"`
}

// RawText 包装原始文本的类型（最小转义）
type RawText struct {
	Text string `xml:",innerxml"`
}

// MarshalXML 自定义CDATA文本的XML序列化
func (c CDATAText) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	// 直接输出CDATA包装的内容
	return e.EncodeElement(struct {
		Text string `xml:",innerxml"`
	}{Text: "<![CDATA[" + c.Text + "]]>"}, start)
}

// MarshalXML 自定义原始文本的XML序列化
func (r RawText) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	// 使用innerxml来避免转义，但需要确保内容是有效的XML
	// 这里我们只转义最基本的XML字符
	safeContent := r.Text
	safeContent = strings.ReplaceAll(safeContent, "&", "&amp;")
	safeContent = strings.ReplaceAll(safeContent, "<", "&lt;")
	safeContent = strings.ReplaceAll(safeContent, ">", "&gt;")
	
	return e.EncodeElement(struct {
		Text string `xml:",innerxml"`
	}{Text: safeContent}, start)
}

// Formatter 格式转换器接口
type Formatter interface {
	Format(data types.ContextData) (string, error)
	FormatFile(file types.FileInfo) (string, error)
	FormatFolder(folder types.FolderInfo) (string, error)
	GetName() string
	GetDescription() string
}

// BaseFormatter 基础格式转换器
type BaseFormatter struct {
	name        string
	description string
	config      interface{}
}

// GetName 获取格式名称
func (f *BaseFormatter) GetName() string {
	return f.name
}

// GetDescription 获取格式描述
func (f *BaseFormatter) GetDescription() string {
	return f.description
}

// applyCustomStructure 应用自定义结构
func (f *BaseFormatter) applyCustomStructure(data types.ContextData) interface{} {
	// 根据配置应用自定义结构
	if f.config != nil {
		// 尝试将配置转换为FormatConfig
		if formatConfig, ok := f.config.(*types.FormatConfig); ok && formatConfig.Structure != nil {
			// 创建基于实际数据的自定义结构
			result := make(map[string]interface{})
			
			// 首先复制所有自定义字段（除了已知的结构字段）
			for key, value := range formatConfig.Structure {
				switch key {
				case "root", "files", "folders":
					// 这些字段稍后单独处理
				default:
					// 复制自定义字段
					result[key] = value
				}
			}
			
			// 应用结构映射
			if rootTag, ok := formatConfig.Structure["root"].(string); ok && rootTag != "" {
				result["XMLName"] = xml.Name{Local: rootTag}
			} else {
				result["XMLName"] = xml.Name{Local: "context"}
			}
			
			// 映射文件和文件夹数据
			if filesTag, ok := formatConfig.Structure["files"].(string); ok && filesTag != "" {
				result[filesTag] = map[string]interface{}{
					"file": data.Files,
				}
			} else {
				result["files"] = map[string]interface{}{
					"file": data.Files,
				}
			}
			
			if foldersTag, ok := formatConfig.Structure["folders"].(string); ok && foldersTag != "" {
				result[foldersTag] = map[string]interface{}{
					"folder": data.Folders,
				}
			} else {
				result["folders"] = map[string]interface{}{
					"folder": data.Folders,
				}
			}
			
			// 添加统计信息
			result["file_count"] = data.FileCount
			result["folder_count"] = data.FolderCount
			result["total_size"] = data.TotalSize
			
			return result
		}
	}
	
	// 返回可序列化的结构，避免map[string]interface{}
	return struct {
		Files       []types.FileInfo       `json:"files"`
		Folders     []types.FolderInfo     `json:"folders"`
		FileCount   int                    `json:"file_count"`
		FolderCount int                    `json:"folder_count"`
		TotalSize   int64                  `json:"total_size"`
		Metadata    map[string]interface{} `json:"metadata"`
	}{
		Files:       data.Files,
		Folders:     data.Folders,
		FileCount:   data.FileCount,
		FolderCount: data.FolderCount,
		TotalSize:   data.TotalSize,
		Metadata:    data.Metadata,
	}
}

// formatFileWithContentHandling 根据内容处理选项格式化文件
func formatFileWithContentHandling(file types.FileInfo, contentHandling types.XMLContentHandling) (string, error) {
	// 如果是二进制文件，不显示内容
	if file.IsBinary {
		file.Content = "[二进制文件 - 内容未显示]"
	}
	
	switch contentHandling {
	case types.XMLContentCDATA:
		// 使用CDATA包装内容
		type FileWithCDATA struct {
			XMLName xml.Name `xml:"file"`
			Path    string   `xml:"path"`
			Name    string   `xml:"name"`
			Size    int64    `xml:"size"`
			Content string   `xml:",cdata"`
			ModTime string   `xml:"mod_time"`
			IsDir   bool     `xml:"is_dir"`
			IsHidden bool    `xml:"is_hidden"`
			IsBinary bool    `xml:"is_binary"`
		}
		
		fileWithCDATA := FileWithCDATA{
			Path:     file.Path,
			Name:     file.Name,
			Size:     file.Size,
			Content:  file.Content,
			ModTime:  file.ModTime.Format(time.RFC3339),
			IsDir:    file.IsDir,
			IsHidden: file.IsHidden,
			IsBinary: file.IsBinary,
		}
		
		output, err := xml.MarshalIndent(fileWithCDATA, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML文件格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
		
	case types.XMLContentRaw:
		// 使用最小转义
		type FileWithRaw struct {
			XMLName xml.Name `xml:"file"`
			Path    string   `xml:"path"`
			Name    string   `xml:"name"`
			Size    int64    `xml:"size"`
			Content RawText  `xml:"content"`
			ModTime string   `xml:"mod_time"`
			IsDir   bool     `xml:"is_dir"`
			IsHidden bool    `xml:"is_hidden"`
			IsBinary bool    `xml:"is_binary"`
		}
		
		fileWithRaw := FileWithRaw{
			Path:     file.Path,
			Name:     file.Name,
			Size:     file.Size,
			Content:  RawText{Text: file.Content},
			ModTime:  file.ModTime.Format(time.RFC3339),
			IsDir:    file.IsDir,
			IsHidden: file.IsHidden,
			IsBinary: file.IsBinary,
		}
		
		output, err := xml.MarshalIndent(fileWithRaw, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML文件格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
		
	default:
		// 默认使用标准XML序列化（转义）
		output, err := xml.MarshalIndent(file, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML文件格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
	}
}

// formatFolderWithContentHandling 根据内容处理选项格式化文件夹
func formatFolderWithContentHandling(folder types.FolderInfo, contentHandling types.XMLContentHandling) (string, error) {
	switch contentHandling {
	case types.XMLContentCDATA:
		// 使用CDATA包装内容（主要用于文件内容，文件夹较少使用）
		// 这里仍然使用标准序列化，因为文件夹主要包含元数据
		output, err := xml.MarshalIndent(folder, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML文件夹格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
		
	case types.XMLContentRaw:
		// 使用最小转义
		type FolderWithRaw struct {
			XMLName xml.Name   `xml:"folder"`
			Path    string     `xml:"path"`
			Name    string     `xml:"name"`
			Files   []types.FileInfo `xml:"files"`
			Folders []types.FolderInfo `xml:"folders"`
			ModTime string     `xml:"mod_time"`
			IsHidden bool      `xml:"is_hidden"`
			Size    int64      `xml:"size"`
			Count   int        `xml:"count"`
		}
		
		folderWithRaw := FolderWithRaw{
			Path:     folder.Path,
			Name:     folder.Name,
			Files:    folder.Files,
			Folders:  folder.Folders,
			ModTime:  folder.ModTime.Format(time.RFC3339),
			IsHidden: folder.IsHidden,
			Size:     folder.Size,
			Count:    folder.Count,
		}
		
		output, err := xml.MarshalIndent(folderWithRaw, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML文件夹格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
		
	default:
		// 默认使用标准XML序列化（转义）
		output, err := xml.MarshalIndent(folder, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML文件夹格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
	}
}

// applyCustomFields 应用自定义字段映射
func (f *BaseFormatter) applyCustomFields(file types.FileInfo) interface{} {
	// 根据配置应用自定义字段映射
	if f.config != nil {
		// 尝试将配置转换为FormatConfig
		if formatConfig, ok := f.config.(*types.FormatConfig); ok && formatConfig.Fields != nil {
			// 这里可以实现字段映射逻辑
			return formatConfig.Fields
		}
	}
	return file
}

// JSONFormatter JSON格式转换器
type JSONFormatter struct {
	BaseFormatter
}

// NewJSONFormatter 创建JSON格式转换器
func NewJSONFormatter(config *types.FormatConfig) Formatter {
	return &JSONFormatter{
		BaseFormatter: BaseFormatter{
			name:        "JSON",
			description: "JavaScript Object Notation format",
			config:      config,
		},
	}
}

// Format 格式化上下文数据
func (f *JSONFormatter) Format(data types.ContextData) (string, error) {
	// 尝试将配置转换为FormatConfig
	if f.config != nil {
		if formatConfig, ok := f.config.(*types.FormatConfig); ok && formatConfig != nil && formatConfig.Structure != nil {
			// 使用自定义结构
			customData := f.applyCustomStructure(data)
			output, err := json.MarshalIndent(customData, "", "  ")
			if err != nil {
				return "", fmt.Errorf("JSON格式化失败: %w", err)
			}
			return string(output), nil
		}
	}

	// 默认结构 - 创建安全的数据副本避免nil引用
	safeData := struct {
		Files       []types.FileInfo   `json:"files"`
		Folders     []types.FolderInfo `json:"folders"`
		FileCount   int                `json:"file_count"`
		FolderCount int                `json:"folder_count"`
		TotalSize   int64              `json:"total_size"`
		Metadata    map[string]interface{} `json:"metadata"`
	}{
		Files:       data.Files,
		Folders:     data.Folders,
		FileCount:   data.FileCount,
		FolderCount: data.FolderCount,
		TotalSize:   data.TotalSize,
		Metadata:    data.Metadata,
	}
	
	output, err := json.MarshalIndent(safeData, "", "  ")
	if err != nil {
		return "", fmt.Errorf("JSON格式化失败: %w", err)
	}
	return string(output), nil
}

// FormatFile 格式化单个文件
func (f *JSONFormatter) FormatFile(file types.FileInfo) (string, error) {
	// 如果是二进制文件，不显示内容
	if file.IsBinary {
		file.Content = "[二进制文件 - 内容未显示]"
	}
	
	// 尝试将配置转换为FormatConfig
	if f.config != nil {
		if formatConfig, ok := f.config.(*types.FormatConfig); ok && formatConfig != nil && formatConfig.Fields != nil {
			// 使用自定义字段映射
			customFile := f.applyCustomFields(file)
			output, err := json.MarshalIndent(customFile, "", "  ")
			if err != nil {
				return "", fmt.Errorf("JSON文件格式化失败: %w", err)
			}
			return string(output), nil
		}
	}

	output, err := json.MarshalIndent(file, "", "  ")
	if err != nil {
		return "", fmt.Errorf("JSON文件格式化失败: %w", err)
	}
	return string(output), nil
}

// FormatFolder 格式化文件夹
func (f *JSONFormatter) FormatFolder(folder types.FolderInfo) (string, error) {
	output, err := json.MarshalIndent(folder, "", "  ")
	if err != nil {
		return "", fmt.Errorf("JSON文件夹格式化失败: %w", err)
	}
	return string(output), nil
}

// XMLFormatter XML格式转换器
type XMLFormatter struct {
	BaseFormatter
	config *types.Config
}

// NewXMLFormatter 创建XML格式转换器
func NewXMLFormatter(config *types.Config) Formatter {
	var formatConfig *types.FormatConfig
	if config != nil {
		formatConfig = &config.Formats.XML.FormatConfig
	}
	return &XMLFormatter{
		BaseFormatter: BaseFormatter{
			name:        "XML",
			description: "Extensible Markup Language format",
			config:      formatConfig,
		},
		config: config,
	}
}

// Format 格式化上下文数据
func (f *XMLFormatter) Format(data types.ContextData) (string, error) {
	// 创建可序列化的结构，避免map[string]interface{}
	type SerializableContextData struct {
		XMLName     xml.Name           `xml:"context"`
		Files       []types.FileInfo   `xml:"files>file"`
		Folders     []types.FolderInfo `xml:"folders>folder"`
		FileCount   int                `xml:"file_count"`
		FolderCount int                `xml:"folder_count"`
		TotalSize   int64              `xml:"total_size"`
	}

	serializableData := SerializableContextData{
		Files:       data.Files,
		Folders:     data.Folders,
		FileCount:   data.FileCount,
		FolderCount: data.FolderCount,
		TotalSize:   data.TotalSize,
	}

	if f.config != nil && f.config.Formats.XML.Structure != nil {
		// 使用自定义结构
		customData := f.applyCustomStructure(data)
		output, err := xml.MarshalIndent(customData, "", "  ")
		if err != nil {
			return "", fmt.Errorf("XML格式化失败: %w", err)
		}
		return xml.Header + string(output), nil
	}

	// 默认结构
	output, err := xml.MarshalIndent(serializableData, "", "  ")
	if err != nil {
		return "", fmt.Errorf("XML格式化失败: %w", err)
	}
	return xml.Header + string(output), nil
}

// FormatFile 格式化单个文件
func (f *XMLFormatter) FormatFile(file types.FileInfo) (string, error) {
	// 如果是二进制文件，不显示内容
	if file.IsBinary {
		file.Content = "[二进制文件 - 内容未显示]"
	}
	
	// 根据内容处理选项处理文件内容
	if f.config != nil && f.config.Formats.XML.Formatting.ContentHandling != "" {
		return formatFileWithContentHandling(file, f.config.Formats.XML.Formatting.ContentHandling)
	}
	
	// 默认使用标准XML序列化
	output, err := xml.MarshalIndent(file, "", "  ")
	if err != nil {
		return "", fmt.Errorf("XML文件格式化失败: %w", err)
	}
	return xml.Header + string(output), nil
}

// FormatFolder 格式化文件夹
func (f *XMLFormatter) FormatFolder(folder types.FolderInfo) (string, error) {
	// 如果配置了内容处理选项，使用相应的处理方式
	if f.config != nil && f.config.Formats.XML.Formatting.ContentHandling != "" {
		return formatFolderWithContentHandling(folder, f.config.Formats.XML.Formatting.ContentHandling)
	}

	// 默认使用标准XML序列化
	output, err := xml.MarshalIndent(folder, "", "  ")
	if err != nil {
		return "", fmt.Errorf("XML文件夹格式化失败: %w", err)
	}
	return xml.Header + string(output), nil
}

// TOMLFormatter TOML格式转换器
type TOMLFormatter struct {
	BaseFormatter
}

// NewTOMLFormatter 创建TOML格式转换器
func NewTOMLFormatter(config *types.FormatConfig) Formatter {
	return &TOMLFormatter{
		BaseFormatter: BaseFormatter{
			name:        "TOML",
			description: "Tom's Obvious, Minimal Language format",
			config:      config,
		},
	}
}

// Format 格式化上下文数据
func (f *TOMLFormatter) Format(data types.ContextData) (string, error) {
	var buf strings.Builder

	// 写入文件部分
	if len(data.Files) > 0 {
		buf.WriteString("[files]\n")
		for i, file := range data.Files {
			buf.WriteString("  [[files.file]]\n")
			buf.WriteString(fmt.Sprintf("    path = \"%s\"\n", file.Path))
			buf.WriteString(fmt.Sprintf("    name = \"%s\"\n", file.Name))
			buf.WriteString(fmt.Sprintf("    size = %d\n", file.Size))
			buf.WriteString(fmt.Sprintf("    content = \"%s\"\n", escapeTOMLString(file.Content)))
			if i < len(data.Files)-1 {
				buf.WriteString("\n")
			}
		}
	}

	// 写入文件夹部分
	if len(data.Folders) > 0 {
		buf.WriteString("\n[folders]\n")
		for i, folder := range data.Folders {
			buf.WriteString("  [[folders.folder]]\n")
			buf.WriteString(fmt.Sprintf("    path = \"%s\"\n", folder.Path))
			buf.WriteString(fmt.Sprintf("    name = \"%s\"\n", folder.Name))
			buf.WriteString(fmt.Sprintf("    file_count = %d\n", len(folder.Files)))
			if i < len(data.Folders)-1 {
				buf.WriteString("\n")
			}
		}
	}

	return buf.String(), nil
}

// FormatFile 格式化单个文件
func (f *TOMLFormatter) FormatFile(file types.FileInfo) (string, error) {
	var buf strings.Builder

	buf.WriteString(fmt.Sprintf("path = \"%s\"\n", file.Path))
	buf.WriteString(fmt.Sprintf("name = \"%s\"\n", file.Name))
	buf.WriteString(fmt.Sprintf("size = %d\n", file.Size))
	
	// 如果是二进制文件，不显示内容
	if file.IsBinary {
		buf.WriteString("content = \"[二进制文件 - 内容未显示]\"\n")
	} else {
		buf.WriteString(fmt.Sprintf("content = \"%s\"\n", escapeTOMLString(file.Content)))
	}
	
	buf.WriteString(fmt.Sprintf("mod_time = \"%s\"\n", file.ModTime.Format(time.RFC3339)))

	return buf.String(), nil
}

// FormatFolder 格式化文件夹
func (f *TOMLFormatter) FormatFolder(folder types.FolderInfo) (string, error) {
	var buf strings.Builder

	buf.WriteString(fmt.Sprintf("path = \"%s\"\n", folder.Path))
	buf.WriteString(fmt.Sprintf("name = \"%s\"\n", folder.Name))
	buf.WriteString(fmt.Sprintf("file_count = %d\n", len(folder.Files)))
	buf.WriteString(fmt.Sprintf("mod_time = \"%s\"\n", folder.ModTime.Format(time.RFC3339)))

	return buf.String(), nil
}

// MarkdownFormatter Markdown格式转换器
type MarkdownFormatter struct {
	BaseFormatter
}

// NewMarkdownFormatter 创建Markdown格式转换器
func NewMarkdownFormatter(config *types.FormatConfig) Formatter {
	return &MarkdownFormatter{
		BaseFormatter: BaseFormatter{
			name:        "Markdown",
			description: "Markdown format with code blocks",
			config:      config,
		},
	}
}

// Format 格式化上下文数据
func (f *MarkdownFormatter) Format(data types.ContextData) (string, error) {
	var sb strings.Builder

	// 添加标题
	sb.WriteString("# 代码上下文\n\n")
	sb.WriteString(fmt.Sprintf("生成时间: %s\n\n", time.Now().Format(time.RFC3339)))

	// 添加文件部分
	if len(data.Files) > 0 {
		sb.WriteString("## 文件\n\n")
		for _, file := range data.Files {
			sb.WriteString(fmt.Sprintf("### %s\n\n", file.Name))
			sb.WriteString(fmt.Sprintf("- **路径**: `%s`\n", file.Path))
			sb.WriteString(fmt.Sprintf("- **大小**: %d 字节\n", file.Size))
			sb.WriteString(fmt.Sprintf("- **修改时间**: %s\n\n", file.ModTime.Format(time.RFC3339)))

			// 添加代码块（只针对文本文件）
			if !file.IsBinary {
				sb.WriteString("```")
				if ext := filepath.Ext(file.Path); ext != "" {
					sb.WriteString(strings.TrimPrefix(ext, "."))
				}
				sb.WriteString("\n")
				sb.WriteString(file.Content)
				sb.WriteString("\n```\n\n")
			} else {
				sb.WriteString("**[二进制文件 - 内容未显示]**\n\n")
			}
		}
	}

	// 添加文件夹部分
	if len(data.Folders) > 0 {
		sb.WriteString("## 文件夹\n\n")
		for _, folder := range data.Folders {
			sb.WriteString(fmt.Sprintf("### %s\n\n", folder.Name))
			sb.WriteString(fmt.Sprintf("- **路径**: `%s`\n", folder.Path))
			sb.WriteString(fmt.Sprintf("- **文件数**: %d\n", len(folder.Files)))
			sb.WriteString(fmt.Sprintf("- **文件数**: %d\n\n", len(folder.Files)))

			// 添加文件夹中的文件
			if len(folder.Files) > 0 {
				sb.WriteString("#### 文件列表\n\n")
				for _, file := range folder.Files {
					sb.WriteString(fmt.Sprintf("- `%s` (%d 字节)\n", file.Name, file.Size))
				}
				sb.WriteString("\n")
			}
		}
	}

	return sb.String(), nil
}

// FormatFile 格式化单个文件
func (f *MarkdownFormatter) FormatFile(file types.FileInfo) (string, error) {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("## %s\n\n", file.Name))
	sb.WriteString(fmt.Sprintf("- **路径**: `%s`\n", file.Path))
	sb.WriteString(fmt.Sprintf("- **大小**: %d 字节\n", file.Size))
	sb.WriteString(fmt.Sprintf("- **修改时间**: %s\n\n", file.ModTime.Format(time.RFC3339)))

	// 添加代码块（只针对文本文件）
	if !file.IsBinary {
		sb.WriteString("```")
		if ext := filepath.Ext(file.Path); ext != "" {
			sb.WriteString(strings.TrimPrefix(ext, "."))
		}
		sb.WriteString("\n")
		sb.WriteString(file.Content)
		sb.WriteString("\n```\n")
	} else {
		sb.WriteString("**[二进制文件 - 内容未显示]**\n")
	}

	return sb.String(), nil
}

// FormatFolder 格式化文件夹
func (f *MarkdownFormatter) FormatFolder(folder types.FolderInfo) (string, error) {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("## %s\n\n", folder.Name))
	sb.WriteString(fmt.Sprintf("- **路径**: `%s`\n", folder.Path))
	sb.WriteString(fmt.Sprintf("- **文件数**: %d\n", len(folder.Files)))
	sb.WriteString(fmt.Sprintf("- **文件数**: %d\n\n", len(folder.Files)))

	// 添加文件列表
	if len(folder.Files) > 0 {
		sb.WriteString("### 文件列表\n\n")
		for _, file := range folder.Files {
			sb.WriteString(fmt.Sprintf("- `%s` (%d 字节)\n", file.Name, file.Size))
		}
		sb.WriteString("\n")
	}

	return sb.String(), nil
}

// FormatterFactory 格式转换器工厂
type FormatterFactory struct {
	formatters map[string]Formatter
}

// NewFormatterFactory 创建格式转换器工厂
func NewFormatterFactory() *FormatterFactory {
	return &FormatterFactory{
		formatters: make(map[string]Formatter),
	}
}

// Register 注册格式转换器
func (ff *FormatterFactory) Register(format string, formatter Formatter) {
	ff.formatters[strings.ToLower(format)] = formatter
}

// Get 获取格式转换器
func (ff *FormatterFactory) Get(format string) (Formatter, error) {
	formatter, exists := ff.formatters[strings.ToLower(format)]
	if !exists {
		return nil, fmt.Errorf("不支持的格式: %s", format)
	}
	return formatter, nil
}

// GetSupportedFormats 获取支持的格式列表
func (ff *FormatterFactory) GetSupportedFormats() []string {
	formats := make([]string, 0, len(ff.formatters))
	for format := range ff.formatters {
		formats = append(formats, format)
	}
	return formats
}

// NewFormatter 创建格式转换器
func NewFormatter(format string, config *types.Config) (Formatter, error) {
	factory := CreateDefaultFactory(config)
	return factory.Get(format)
}

// CreateDefaultFactory 创建默认的格式转换器工厂
func CreateDefaultFactory(config *types.Config) *FormatterFactory {
	factory := NewFormatterFactory()

	// 注册所有支持的格式
	factory.Register(constants.FormatJSON, NewJSONFormatter(&config.Formats.JSON))
	factory.Register(constants.FormatXML, NewXMLFormatter(config))
	factory.Register(constants.FormatTOML, NewTOMLFormatter(&config.Formats.TOML))
	factory.Register(constants.FormatMarkdown, NewMarkdownFormatter(&config.Formats.Markdown))

	return factory
}

// 辅助方法

func escapeTOMLString(s string) string {
	// 简单的TOML字符串转义
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\t", "\\t")
	return s
}

```

### formatter_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\formatter\formatter_test.go`
- **大小**: 19414 字节
- **修改时间**: 2025-10-02T12:14:22+08:00

```go
package formatter

import (
	"encoding/json"
	"encoding/xml"
	"strings"
	"testing"
	"time"

	"code-context-generator/pkg/types"
)

// 测试辅助函数
func createTestFileInfo() types.FileInfo {
	return types.FileInfo{
		Path:     "test/file.go",
		Name:     "file.go",
		Size:     1024,
		ModTime:  time.Now(),
		Content:  "package main\n\nfunc main() {\n\tprintln(\"Hello World\")\n}",
		IsDir:    false,
		IsHidden: false,
		IsBinary: false,
	}
}

func createTestFolderInfo() types.FolderInfo {
	return types.FolderInfo{
		Path:     "test/folder",
		Name:     "folder",
		ModTime:  time.Now(),
		Files:    []types.FileInfo{createTestFileInfo()},
		Folders:  []types.FolderInfo{}, // 初始化为空切片而不是nil
		Size:     1024, // 设置文件夹大小
		Count:    1,    // 设置文件计数
	}
}

func createTestContextData() types.ContextData {
	return types.ContextData{
		Files:       []types.FileInfo{createTestFileInfo()},
		Folders:     []types.FolderInfo{createTestFolderInfo()},
		FileCount:   1,
		FolderCount: 1,
		TotalSize:   1024,
		Metadata:    make(map[string]interface{}),
	}
}

// JSONFormatter 测试
func TestJSONFormatter_Format(t *testing.T) {
	formatter := NewJSONFormatter(nil)
	data := createTestContextData()

	result, err := formatter.Format(data)
	if err != nil {
		t.Fatalf("Format failed: %v", err)
	}

	// 验证结果是有效的JSON
	var parsed map[string]interface{}
	if err := json.Unmarshal([]byte(result), &parsed); err != nil {
		t.Fatalf("Result is not valid JSON: %v", err)
	}

	// 验证基本字段存在
	if _, exists := parsed["files"]; !exists {
		t.Error("Missing 'files' field in JSON output")
	}
	if _, exists := parsed["folders"]; !exists {
		t.Error("Missing 'folders' field in JSON output")
	}
}

func TestJSONFormatter_FormatFile(t *testing.T) {
	formatter := NewJSONFormatter(nil)
	file := createTestFileInfo()

	result, err := formatter.FormatFile(file)
	if err != nil {
		t.Fatalf("FormatFile failed: %v", err)
	}

	// 验证结果是有效的JSON
	var parsed types.FileInfo
	if err := json.Unmarshal([]byte(result), &parsed); err != nil {
		t.Fatalf("Result is not valid JSON: %v", err)
	}

	// 验证字段
	if parsed.Name != file.Name {
		t.Errorf("Expected name %s, got %s", file.Name, parsed.Name)
	}
	if parsed.Size != file.Size {
		t.Errorf("Expected size %d, got %d", file.Size, parsed.Size)
	}
}

func TestJSONFormatter_FormatFolder(t *testing.T) {
	formatter := NewJSONFormatter(nil)
	folder := createTestFolderInfo()

	result, err := formatter.FormatFolder(folder)
	if err != nil {
		t.Fatalf("FormatFolder failed: %v", err)
	}

	// 验证结果是有效的JSON
	var parsed types.FolderInfo
	if err := json.Unmarshal([]byte(result), &parsed); err != nil {
		t.Fatalf("Result is not valid JSON: %v", err)
	}

	// 验证字段
	if parsed.Name != folder.Name {
		t.Errorf("Expected name %s, got %s", folder.Name, parsed.Name)
	}
	if len(parsed.Files) != len(folder.Files) {
		t.Errorf("Expected %d files, got %d", len(folder.Files), len(parsed.Files))
	}
}

// XMLFormatter 测试
func TestXMLFormatter_Format(t *testing.T) {
	formatter := NewXMLFormatter(nil)
	data := createTestContextData()

	result, err := formatter.Format(data)
	if err != nil {
		t.Fatalf("Format failed: %v", err)
	}

	// 验证结果包含XML头
	if !strings.HasPrefix(result, xml.Header) {
		t.Error("XML result should start with XML header")
	}

	// 验证包含基本元素
	if !strings.Contains(result, "<context>") {
		t.Error("Missing <context> element in XML output")
	}
	if !strings.Contains(result, "<files>") {
		t.Error("Missing <files> element in XML output")
	}
	if !strings.Contains(result, "<folders>") {
		t.Error("Missing <folders> element in XML output")
	}
}

func TestXMLFormatter_FormatFile(t *testing.T) {
	formatter := NewXMLFormatter(nil)
	file := createTestFileInfo()

	result, err := formatter.FormatFile(file)
	if err != nil {
		t.Fatalf("FormatFile failed: %v", err)
	}

	// 验证结果包含XML头
	if !strings.HasPrefix(result, xml.Header) {
		t.Error("XML result should start with XML header")
	}

	// 验证包含文件元素
	if !strings.Contains(result, "<Path>") {
		t.Error("Missing <Path> element in XML output")
	}
	if !strings.Contains(result, "<Name>") {
		t.Error("Missing <Name> element in XML output")
	}
}

func TestXMLFormatter_FormatFolder(t *testing.T) {
	formatter := NewXMLFormatter(nil)
	folder := createTestFolderInfo()

	result, err := formatter.FormatFolder(folder)
	if err != nil {
		t.Fatalf("FormatFolder failed: %v", err)
	}

	// 验证结果包含XML头
	if !strings.HasPrefix(result, xml.Header) {
		t.Error("XML result should start with XML header")
	}

	// 验证包含文件夹元素
	if !strings.Contains(result, "<Path>") {
		t.Error("Missing <Path> element in XML output")
	}
	if !strings.Contains(result, "<Name>") {
		t.Error("Missing <Name> element in XML output")
	}
}

// TOMLFormatter 测试
func TestTOMLFormatter_Format(t *testing.T) {
	formatter := NewTOMLFormatter(nil)
	data := createTestContextData()

	result, err := formatter.Format(data)
	if err != nil {
		t.Fatalf("Format failed: %v", err)
	}

	// 验证包含基本结构
	if !strings.Contains(result, "[files]") {
		t.Error("Missing [files] section in TOML output")
	}
	if !strings.Contains(result, "[[files.file]]") {
		t.Error("Missing [[files.file]] section in TOML output")
	}
	if !strings.Contains(result, "[folders]") {
		t.Error("Missing [folders] section in TOML output")
	}
	if !strings.Contains(result, "[[folders.folder]]") {
		t.Error("Missing [[folders.folder]] section in TOML output")
	}
}

func TestTOMLFormatter_FormatFile(t *testing.T) {
	formatter := NewTOMLFormatter(nil)
	file := createTestFileInfo()

	result, err := formatter.FormatFile(file)
	if err != nil {
		t.Fatalf("FormatFile failed: %v", err)
	}

	// 验证包含文件字段
	if !strings.Contains(result, "path = \"test/file.go\"") {
		t.Error("Missing or incorrect path field in TOML output")
	}
	if !strings.Contains(result, "name = \"file.go\"") {
		t.Error("Missing or incorrect name field in TOML output")
	}
	if !strings.Contains(result, "size = 1024") {
		t.Error("Missing or incorrect size field in TOML output")
	}
}

func TestTOMLFormatter_FormatFolder(t *testing.T) {
	formatter := NewTOMLFormatter(nil)
	folder := createTestFolderInfo()

	result, err := formatter.FormatFolder(folder)
	if err != nil {
		t.Fatalf("FormatFolder failed: %v", err)
	}

	// 验证包含文件夹字段
	if !strings.Contains(result, "path = \"test/folder\"") {
		t.Error("Missing or incorrect path field in TOML output")
	}
	if !strings.Contains(result, "name = \"folder\"") {
		t.Error("Missing or incorrect name field in TOML output")
	}
	if !strings.Contains(result, "file_count = 1") {
		t.Error("Missing or incorrect file_count field in TOML output")
	}
}

// MarkdownFormatter 测试
func TestMarkdownFormatter_Format(t *testing.T) {
	formatter := NewMarkdownFormatter(nil)
	data := createTestContextData()

	result, err := formatter.Format(data)
	if err != nil {
		t.Fatalf("Format failed: %v", err)
	}

	// 验证包含Markdown标题
	if !strings.Contains(result, "# 代码上下文") {
		t.Error("Missing main title in Markdown output")
	}
	if !strings.Contains(result, "## 文件") {
		t.Error("Missing files section title in Markdown output")
	}
	if !strings.Contains(result, "## 文件夹") {
		t.Error("Missing folders section title in Markdown output")
	}

	// 验证包含代码块
	if !strings.Contains(result, "```go") {
		t.Error("Missing code block in Markdown output")
	}
	if !strings.Contains(result, "package main") {
		t.Error("Missing file content in Markdown output")
	}
}

func TestMarkdownFormatter_FormatFile(t *testing.T) {
	formatter := NewMarkdownFormatter(nil)
	file := createTestFileInfo()

	result, err := formatter.FormatFile(file)
	if err != nil {
		t.Fatalf("FormatFile failed: %v", err)
	}

	// 验证包含文件标题
	if !strings.Contains(result, "## file.go") {
		t.Error("Missing file title in Markdown output")
	}

	// 验证包含文件信息
	if !strings.Contains(result, "**路径**") {
		t.Error("Missing path information in Markdown output")
	}
	if !strings.Contains(result, "**大小**") {
		t.Error("Missing size information in Markdown output")
	}

	// 验证包含代码块
	if !strings.Contains(result, "```go") {
		t.Error("Missing code block in Markdown output")
	}
}

func TestMarkdownFormatter_FormatFolder(t *testing.T) {
	formatter := NewMarkdownFormatter(nil)
	folder := createTestFolderInfo()

	result, err := formatter.FormatFolder(folder)
	if err != nil {
		t.Fatalf("FormatFolder failed: %v", err)
	}

	// 验证包含文件夹标题
	if !strings.Contains(result, "## folder") {
		t.Error("Missing folder title in Markdown output")
	}

	// 验证包含文件夹信息
	if !strings.Contains(result, "**路径**") {
		t.Error("Missing path information in Markdown output")
	}
	if !strings.Contains(result, "**文件数**") {
		t.Error("Missing file count information in Markdown output")
	}

	// 验证包含文件列表
	if !strings.Contains(result, "### 文件列表") {
		t.Error("Missing file list title in Markdown output")
	}
}

// FormatterFactory 测试
func TestFormatterFactory(t *testing.T) {
	factory := NewFormatterFactory()

	// 注册格式
	jsonFormatter := NewJSONFormatter(nil)
	factory.Register("json", jsonFormatter)
	factory.Register("JSON", jsonFormatter) // 测试大小写不敏感

	// 测试获取格式
	formatter, err := factory.Get("json")
	if err != nil {
		t.Fatalf("Get formatter failed: %v", err)
	}
	if formatter == nil {
		t.Error("Formatter should not be nil")
	}
	if formatter.GetName() != "JSON" {
		t.Errorf("Expected formatter name 'JSON', got '%s'", formatter.GetName())
	}

	// 测试不存在的格式
	_, err = factory.Get("nonexistent")
	if err == nil {
		t.Error("Expected error for nonexistent format")
	}

	// 测试获取支持的格式
	supportedFormats := factory.GetSupportedFormats()
	if len(supportedFormats) != 1 { // json 和 JSON 应该被视为同一个
		t.Errorf("Expected 1 supported format, got %d", len(supportedFormats))
	}
}

func TestNewFormatter(t *testing.T) {
	// 创建测试配置
	testConfig := &types.Config{
		Formats: types.FormatsConfig{
			JSON: types.FormatConfig{Enabled: true},
			XML:  types.XMLFormatConfig{FormatConfig: types.FormatConfig{Enabled: true}},
			TOML: types.FormatConfig{Enabled: true},
			Markdown: types.FormatConfig{Enabled: true},
		},
	}

	// 测试创建JSON格式
	formatter, err := NewFormatter("json", testConfig)
	if err != nil {
		t.Fatalf("NewFormatter failed: %v", err)
	}
	if formatter.GetName() != "JSON" {
		t.Errorf("Expected formatter name 'JSON', got '%s'", formatter.GetName())
	}

	// 测试创建XML格式
	formatter, err = NewFormatter("xml", testConfig)
	if err != nil {
		t.Fatalf("NewFormatter failed: %v", err)
	}
	if formatter.GetName() != "XML" {
		t.Errorf("Expected formatter name 'XML', got '%s'", formatter.GetName())
	}

	// 测试创建TOML格式
	formatter, err = NewFormatter("toml", testConfig)
	if err != nil {
		t.Fatalf("NewFormatter failed: %v", err)
	}
	if formatter.GetName() != "TOML" {
		t.Errorf("Expected formatter name 'TOML', got '%s'", formatter.GetName())
	}

	// 测试创建Markdown格式
	formatter, err = NewFormatter("markdown", testConfig)
	if err != nil {
		t.Fatalf("NewFormatter failed: %v", err)
	}
	if formatter.GetName() != "Markdown" {
		t.Errorf("Expected formatter name 'Markdown', got '%s'", formatter.GetName())
	}

	// 测试不存在的格式
	_, err = NewFormatter("nonexistent", testConfig)
	if err == nil {
		t.Error("Expected error for nonexistent format")
	}
}

// 测试自定义配置的情况
func TestJSONFormatter_WithCustomConfig(t *testing.T) {
	customConfig := &types.FormatConfig{
		Structure: map[string]interface{}{
			"custom_field": "custom_value",
			"files":        []interface{}{},
		},
	}
	
	formatter := NewJSONFormatter(customConfig)
	data := createTestContextData()

	result, err := formatter.Format(data)
	if err != nil {
		t.Fatalf("Format with custom config failed: %v", err)
	}

	// 验证结果是有效的JSON
	var parsed map[string]interface{}
	if err := json.Unmarshal([]byte(result), &parsed); err != nil {
		t.Fatalf("Result is not valid JSON: %v", err)
	}

	// 验证自定义字段存在
	if _, exists := parsed["custom_field"]; !exists {
		t.Error("Missing 'custom_field' in custom config output")
	}
}

func TestJSONFormatter_WithCustomFields(t *testing.T) {
	customConfig := &types.FormatConfig{
		Fields: map[string]string{
			"custom_file_field": "custom_value",
		},
	}
	
	formatter := NewJSONFormatter(customConfig)
	file := createTestFileInfo()

	result, err := formatter.FormatFile(file)
	if err != nil {
		t.Fatalf("FormatFile with custom config failed: %v", err)
	}

	// 验证结果是有效的JSON
	var parsed map[string]interface{}
	if err := json.Unmarshal([]byte(result), &parsed); err != nil {
		t.Fatalf("Result is not valid JSON: %v", err)
	}

	// 验证自定义字段存在
	if _, exists := parsed["custom_file_field"]; !exists {
		t.Error("Missing 'custom_file_field' in custom config output")
	}
}

// 测试XMLFormatter的自定义配置
func TestXMLFormatter_WithCustomConfig(t *testing.T) {
	// XMLFormatter现在使用完整的Config结构
	config := &types.Config{
		Formats: types.FormatsConfig{
			XML: types.XMLFormatConfig{
				FormatConfig: types.FormatConfig{
					Fields: map[string]string{
						"version": "1.0",
					},
				},
			},
		},
	}
	
	formatter := NewXMLFormatter(config)
	data := createTestContextData()

	result, err := formatter.Format(data)
	if err != nil {
		t.Fatalf("Format with custom config failed: %v", err)
	}

	// 验证结果包含XML头
	if !strings.HasPrefix(result, xml.Header) {
		t.Error("XML result should start with XML header")
	}

	// 验证基本的XML结构存在
	if !strings.Contains(result, "<context>") {
		t.Error("XML result should contain context element")
	}
}

// 测试错误处理
func TestFormatters_ErrorHandling(t *testing.T) {
	// 测试XMLFormatter处理不可序列化的数据
	t.Run("XMLFormatter_InvalidCustomConfig", func(t *testing.T) {
		config := &types.Config{
			Formats: types.FormatsConfig{
				XML: types.XMLFormatConfig{
					FormatConfig: types.FormatConfig{
						Structure: map[string]interface{}{
							"invalid": make(chan int), // channel不能被XML序列化
						},
					},
				},
			},
		}
		
		formatter := NewXMLFormatter(config)
		data := createTestContextData()

		_, err := formatter.Format(data)
		if err == nil {
			t.Error("Expected error for invalid XML custom config")
		}
		if !strings.Contains(err.Error(), "XML格式化失败") {
			t.Errorf("Expected XML formatting error, got: %v", err)
		}
	})

	// 测试JSONFormatter处理循环引用（虽然不太可能，但测试错误处理）
	t.Run("JSONFormatter_InvalidData", func(t *testing.T) {
		// 这里我们模拟一个不能被JSON序列化的ContextData
		// 由于实际类型是ContextData，我们测试自定义配置的情况
		customConfig := &types.FormatConfig{
			Structure: map[string]interface{}{
				"invalid": func() {},
			},
		}
		
		formatterWithInvalidConfig := NewJSONFormatter(customConfig)
		data := createTestContextData()
		
		_, err := formatterWithInvalidConfig.Format(data)
		if err == nil {
			t.Error("Expected error for invalid JSON custom config")
		}
		if !strings.Contains(err.Error(), "JSON格式化失败") {
			t.Errorf("Expected JSON formatting error, got: %v", err)
		}
	})
}

// 测试空数据和边界情况
func TestFormatters_EmptyData(t *testing.T) {
	emptyData := types.ContextData{
		Files:       []types.FileInfo{},
		Folders:     []types.FolderInfo{},
		FileCount:   0,
		FolderCount: 0,
		TotalSize:   0,
	}

	// 测试JSONFormatter
	jsonFormatter := NewJSONFormatter(nil)
	result, err := jsonFormatter.Format(emptyData)
	if err != nil {
		t.Fatalf("JSON format empty data failed: %v", err)
	}
	if !strings.Contains(result, `"files": null`) && !strings.Contains(result, `"files": []`) {
		t.Error("JSON empty data should contain empty files array")
	}

	// 测试XMLFormatter
	xmlConfig := &types.Config{
		Formats: types.FormatsConfig{
			XML: types.XMLFormatConfig{
				FormatConfig: types.FormatConfig{},
			},
		},
	}
	xmlFormatter := NewXMLFormatter(xmlConfig)
	result, err = xmlFormatter.Format(emptyData)
	if err != nil {
		t.Fatalf("XML format empty data failed: %v", err)
	}
	if !strings.Contains(result, "<files>") {
		t.Error("XML empty data should contain files element")
	}

	// 测试TOMLFormatter
	tomlFormatter := NewTOMLFormatter(nil)
	result, err = tomlFormatter.Format(emptyData)
	if err != nil {
		t.Fatalf("TOML format empty data failed: %v", err)
	}
	// TOML空数据不应该包含文件部分
	if strings.Contains(result, "[files]") {
		t.Error("TOML empty data should not contain files section")
	}

	// 测试MarkdownFormatter
	markdownFormatter := NewMarkdownFormatter(nil)
	result, err = markdownFormatter.Format(emptyData)
	if err != nil {
		t.Fatalf("Markdown format empty data failed: %v", err)
	}
	// Markdown空数据不应该包含文件部分
	if strings.Contains(result, "## 文件") {
		t.Error("Markdown empty data should not contain files section")
	}
}

// 测试FormatterFactory的大小写不敏感
func TestFormatterFactory_CaseInsensitive(t *testing.T) {
	config := &types.Config{
		Formats: types.FormatsConfig{
			JSON: types.FormatConfig{},
			XML:  types.XMLFormatConfig{FormatConfig: types.FormatConfig{}},
			TOML: types.FormatConfig{},
			Markdown: types.FormatConfig{},
		},
	}
	factory := CreateDefaultFactory(config)

	// 测试各种大小写变体
	testCases := []string{"json", "JSON", "Json", "jSoN"}
	
	for _, format := range testCases {
		formatter, err := factory.Get(format)
		if err != nil {
			t.Errorf("Get formatter for %s failed: %v", format, err)
		}
		if formatter == nil {
			t.Errorf("Formatter for %s should not be nil", format)
		}
		if formatter.GetName() != "JSON" {
			t.Errorf("Expected formatter name 'JSON' for %s, got '%s'", format, formatter.GetName())
		}
	}
}

// 辅助函数测试
func TestEscapeTOMLString(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"simple text", "simple text"},
		{"text with \"quotes\"", "text with \\\"quotes\\\""},
		{"text with \\ backslash", "text with \\\\ backslash"},
		{"text with\nnewline", "text with\\nnewline"},
		{"text with\ttab", "text with\\ttab"},
		{"text with\rcarriage return", "text with\\rcarriage return"},
	}

	for _, test := range tests {
		result := escapeTOMLString(test.input)
		if result != test.expected {
			t.Errorf("escapeTOMLString(%q) = %q, expected %q", test.input, result, test.expected)
		}
	}
}
```

### color.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\color.go`
- **大小**: 958 字节
- **修改时间**: 2025-10-01T20:49:28+08:00

```go
// Package utils 提供通用工具函数
package utils

// ColorCode 颜色代码
type ColorCode string

const (
	ColorReset  ColorCode = "\033[0m"
	ColorRed    ColorCode = "\033[31m"
	ColorGreen  ColorCode = "\033[32m"
	ColorYellow ColorCode = "\033[33m"
	ColorBlue   ColorCode = "\033[34m"
	ColorPurple ColorCode = "\033[35m"
	ColorCyan   ColorCode = "\033[36m"
	ColorWhite  ColorCode = "\033[37m"
)

// Colorize 给文本添加颜色
func Colorize(text string, color ColorCode) string {
	return string(color) + text + string(ColorReset)
}

// ErrorColor 错误颜色
func ErrorColor(text string) string {
	return Colorize(text, ColorRed)
}

// SuccessColor 成功颜色
func SuccessColor(text string) string {
	return Colorize(text, ColorGreen)
}

// WarningColor 警告颜色
func WarningColor(text string) string {
	return Colorize(text, ColorYellow)
}

// InfoColor 信息颜色
func InfoColor(text string) string {
	return Colorize(text, ColorBlue)
}
```

### encoding.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\encoding.go`
- **大小**: 5835 字节
- **修改时间**: 2025-10-01T20:49:23+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"fmt"
	"golang.org/x/text/encoding"
	"golang.org/x/text/encoding/charmap"
	"golang.org/x/text/encoding/simplifiedchinese"
	"golang.org/x/text/transform"
	"io/ioutil"
	"strings"
	
	"golang.org/x/text/encoding/unicode"
)

// DetectEncoding 检测文件编码
func DetectEncoding(data []byte) (string, []byte) {
	if len(data) == 0 {
		return "utf-8", data
	}

	// 检查BOM头
	if len(data) >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF {
		return "utf-8", data[3:] // 跳过BOM
	}
	
	if len(data) >= 2 {
		// UTF-16 LE BOM
		if data[0] == 0xFF && data[1] == 0xFE {
			return "utf-16le", data[2:]
		}
		// UTF-16 BE BOM
		if data[0] == 0xFE && data[1] == 0xFF {
			return "utf-16be", data[2:]
		}
	}

	// 检查是否为UTF-8
	if isValidUTF8(data) {
		return "utf-8", data
	}

	// 检查是否为UTF-16
	if isValidUTF16(data) {
		return "utf-16le", data // 默认小端
	}

	// 检查是否为GBK
	if isValidGBK(data) {
		return "gbk", data
	}

	// 检查是否为ANSI (Windows-1252)
	if isValidANSI(data) {
		return "ansi", data
	}

	// 默认按UTF-8处理
	return "utf-8", data
}

// isValidUTF8 检查数据是否为有效的UTF-8编码
func isValidUTF8(data []byte) bool {
	for i := 0; i < len(data); {
		r := rune(data[i])
		if r < 0x80 {
			i++
			continue
		}

		// 多字节UTF-8序列
		if i+1 >= len(data) {
			return false
		}

		if r < 0xE0 {
			// 2字节序列: 110xxxxx 10xxxxxx
			if data[i+1]&0xC0 != 0x80 {
				return false
			}
			i += 2
		} else if r < 0xF0 {
			// 3字节序列: 1110xxxx 10xxxxxx 10xxxxxx
			if i+2 >= len(data) || data[i+1]&0xC0 != 0x80 || data[i+2]&0xC0 != 0x80 {
				return false
			}
			i += 3
		} else if r < 0xF8 {
			// 4字节序列: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
			if i+3 >= len(data) || data[i+1]&0xC0 != 0x80 || data[i+2]&0xC0 != 0x80 || data[i+3]&0xC0 != 0x80 {
				return false
			}
			i += 4
		} else {
			return false
		}
	}
	return true
}

// isValidUTF16 检查数据是否为有效的UTF-16编码
func isValidUTF16(data []byte) bool {
	if len(data)%2 != 0 {
		return false
	}

	// 简单检查：查看是否有大量0字节
	zeroCount := 0
	for _, b := range data {
		if b == 0 {
			zeroCount++
		}
	}

	// 如果超过25%的字符是0，可能是UTF-16
	return float64(zeroCount)/float64(len(data)) > 0.25
}

// isValidGBK 检查数据是否为有效的GBK编码
func isValidGBK(data []byte) bool {
	for i := 0; i < len(data); {
		b := data[i]
		if b < 0x80 {
			i++
			continue
		}

		// GBK双字节字符
		if i+1 < len(data) {
			b2 := data[i+1]
			// GBK范围: 0x8140-0xFEFE
			if (b >= 0x81 && b <= 0xFE) && (b2 >= 0x40 && b2 <= 0xFE && b2 != 0x7F) {
				i += 2
				continue
			}
		}
		return false
	}
	return true
}

// isValidANSI 检查数据是否为有效的ANSI (Windows-1252) 编码
func isValidANSI(data []byte) bool {
	// ANSI (Windows-1252) 是单字节编码，所有字节值都有效
	// 这里我们检查是否主要是可打印字符
	printableCount := 0
	for _, b := range data {
		// 可打印字符和控制字符
		if (b >= 32 && b <= 126) || (b >= 160 && b <= 255) || b == 9 || b == 10 || b == 13 {
			printableCount++
		}
	}
	
	// 如果大部分字符都是可打印的，认为是ANSI编码
	return float64(printableCount)/float64(len(data)) > 0.8
}

// ConvertToUTF8 将数据转换为UTF-8编码
func ConvertToUTF8(data []byte, encoding string) (string, error) {
	switch strings.ToLower(encoding) {
	case "utf-8":
		return string(data), nil
	case "utf-16le":
		return utf16ToUTF8(data, true), nil
	case "utf-16be":
		return utf16ToUTF8(data, false), nil
	case "gbk":
		return gbkToUTF8(data)
	case "ansi", "windows-1252", "cp1252":
		return ansiToUTF8(data)
	default:
		return string(data), nil // 默认按UTF-8处理
	}
}

// utf16ToUTF8 将UTF-16转换为UTF-8
func utf16ToUTF8(data []byte, littleEndian bool) string {
	if len(data)%2 != 0 {
		return string(data) // 如果不是偶数长度，直接返回
	}

	var result strings.Builder
	for i := 0; i < len(data); i += 2 {
		var r rune
		if littleEndian {
			r = rune(data[i]) | rune(data[i+1])<<8
		} else {
			r = rune(data[i])<<8 | rune(data[i+1])
		}

		if r == 0 {
			break // 遇到null字符停止
		}

		if r < 0x80 {
			result.WriteByte(byte(r))
		} else if r < 0x800 {
			result.WriteByte(0xC0 | byte(r>>6))
			result.WriteByte(0x80 | byte(r&0x3F))
		} else {
			result.WriteByte(0xE0 | byte(r>>12))
			result.WriteByte(0x80 | byte((r>>6)&0x3F))
			result.WriteByte(0x80 | byte(r&0x3F))
		}
	}

	return result.String()
}

// gbkToUTF8 将GBK转换为UTF-8
func gbkToUTF8(data []byte) (string, error) {
	decoder := simplifiedchinese.GBK.NewDecoder()
	reader := transform.NewReader(strings.NewReader(string(data)), decoder)
	result, err := ioutil.ReadAll(reader)
	if err != nil {
		return "", fmt.Errorf("GBK解码失败: %w", err)
	}
	return string(result), nil
}

// ansiToUTF8 将ANSI (Windows-1252) 转换为UTF-8
func ansiToUTF8(data []byte) (string, error) {
	decoder := charmap.Windows1252.NewDecoder()
	reader := transform.NewReader(strings.NewReader(string(data)), decoder)
	result, err := ioutil.ReadAll(reader)
	if err != nil {
		return "", fmt.Errorf("ANSI解码失败: %w", err)
	}
	return string(result), nil
}

// GetEncodingDecoder 获取指定编码的解码器
func GetEncodingDecoder(enc string) (encoding.Encoding, error) {
	switch strings.ToLower(enc) {
	case "gbk", "gb2312":
		return simplifiedchinese.GBK, nil
	case "ansi", "windows-1252", "cp1252":
		return charmap.Windows1252, nil
	case "utf-16le":
		return unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM), nil
	case "utf-16be":
		return unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM), nil
	case "utf-8":
		return encoding.Nop, nil
	default:
		return nil, fmt.Errorf("不支持的编码: %s", enc)
	}
}
```

### file.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\file.go`
- **大小**: 3982 字节
- **修改时间**: 2025-10-01T20:42:48+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// FileExists 检查文件是否存在
func FileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// DirectoryExists 检查目录是否存在
func DirectoryExists(path string) bool {
	info, err := os.Stat(path)
	if os.IsNotExist(err) {
		return false
	}
	return info.IsDir()
}

// GetFileHash 获取文件哈希值
func GetFileHash(path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

// GetFileSize 获取文件大小
func GetFileSize(path string) (int64, error) {
	info, err := os.Stat(path)
	if err != nil {
		return 0, err
	}
	return info.Size(), nil
}

// GetFileModTime 获取文件修改时间
func GetFileModTime(path string) (time.Time, error) {
	info, err := os.Stat(path)
	if err != nil {
		return time.Time{}, err
	}
	return info.ModTime(), nil
}

// IsTextFile 检查是否为文本文件
func IsTextFile(path string) bool {
	// 首先检查文件扩展名
	ext := strings.ToLower(filepath.Ext(path))
	textExtensions := []string{
		".txt", ".md", ".json", ".xml", ".yaml", ".yml", ".toml",
		".go", ".py", ".js", ".ts", ".java", ".cpp", ".c", ".h",
		".html", ".css", ".scss", ".sass", ".sql", ".sh", ".bat",
		".ps1", ".rb", ".php", ".rs", ".swift", ".kt", ".scala",
	}

	for _, textExt := range textExtensions {
		if ext == textExt {
			return true
		}
	}

	// 如果没有扩展名，尝试读取文件内容来判断
	if ext == "" {
		file, err := os.Open(path)
		if err != nil {
			return false // 无法打开文件，假设为二进制文件
		}
		defer file.Close()

		// 读取前512字节来判断是否为文本文件
		buffer := make([]byte, 512)
		n, err := file.Read(buffer)
		if err != nil && err != io.EOF {
			return false // 读取错误，假设为二进制文件
		}

		// 检查是否包含null字节（二进制文件的标志）
		for i := 0; i < n; i++ {
			if buffer[i] == 0 {
				return false // 包含null字节，是二进制文件
			}
		}

		// 检查是否包含可打印字符
		printableCount := 0
		for i := 0; i < n; i++ {
			b := buffer[i]
			if b >= 32 && b <= 126 { // 可打印ASCII字符
				printableCount++
			} else if b == 9 || b == 10 || b == 13 { // tab, newline, carriage return
				printableCount++
			}
		}

		// 如果大部分字符都是可打印的，认为是文本文件
		if n > 0 && float64(printableCount)/float64(n) > 0.8 {
			return true
		}
	}

	return false
}

// IsBinaryFile 检查是否为二进制文件
func IsBinaryFile(path string) bool {
	return !IsTextFile(path)
}

// ReadFileContent 读取文件内容（带大小限制）
func ReadFileContent(path string, maxSize int64) (string, bool, error) {
	// 使用新的编码感知函数
	return ReadFileContentWithEncoding(path, maxSize)
}

// ReadFileContentWithEncoding 智能编码读取文件内容
func ReadFileContentWithEncoding(path string, maxSize int64) (string, bool, error) {
	// 获取文件信息
	info, err := os.Stat(path)
	if err != nil {
		return "", false, err
	}

	// 检查文件大小
	if maxSize > 0 && info.Size() > maxSize {
		return "", false, fmt.Errorf("文件大小超过限制: %d > %d", info.Size(), maxSize)
	}

	// 读取文件内容
	content, err := os.ReadFile(path)
	if err != nil {
		return "", false, fmt.Errorf("读取文件失败: %w", err)
	}

	// 检测是否为二进制文件
	isBinary := !IsTextFile(path)
	if isBinary {
		return "[二进制文件]", isBinary, nil
	}

	// 检测编码并转换
	encoding, cleanData := DetectEncoding(content)
	utf8Content, err := ConvertToUTF8(cleanData, encoding)
	if err != nil {
		return "", false, fmt.Errorf("编码转换失败: %w", err)
	}

	return utf8Content, isBinary, nil
}
```

### string.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\string.go`
- **大小**: 1687 字节
- **修改时间**: 2025-10-01T20:43:09+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"strings"
)

// TruncateString 截断字符串
func TruncateString(s string, maxLength int) string {
	if len(s) <= maxLength {
		return s
	}
	if maxLength <= 3 {
		return s[:maxLength]
	}
	return s[:maxLength-3] + "..."
}

// PadString 填充字符串
func PadString(s string, length int, padChar rune) string {
	if len(s) >= length {
		return s
	}
	padding := strings.Repeat(string(padChar), length-len(s))
	return s + padding
}

// PadLeft 左填充
func PadLeft(s string, length int, padChar rune) string {
	if len(s) >= length {
		return s
	}
	padding := strings.Repeat(string(padChar), length-len(s))
	return padding + s
}

// PadCenter 居中填充
func PadCenter(s string, length int, padChar rune) string {
	if len(s) >= length {
		return s
	}
	totalPadding := length - len(s)
	leftPadding := totalPadding / 2
	rightPadding := totalPadding - leftPadding
	return strings.Repeat(string(padChar), leftPadding) + s + strings.Repeat(string(padChar), rightPadding)
}

// RemoveDuplicates 移除字符串切片中的重复项
func RemoveDuplicates(strings []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0, len(strings))
	
	for _, s := range strings {
		if !seen[s] {
			seen[s] = true
			result = append(result, s)
		}
	}
	
	return result
}

// SplitLines 分割字符串为多行
func SplitLines(s string) []string {
	return strings.Split(strings.ReplaceAll(s, "\r\n", "\n"), "\n")
}

// JoinLines 连接多行为字符串
func JoinLines(lines []string) string {
	return strings.Join(lines, "\n")
}

// CountLines 计算行数
func CountLines(s string) int {
	return len(SplitLines(s))
}
```

### text.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\text.go`
- **大小**: 975 字节
- **修改时间**: 2025-10-02T09:32:09+08:00

```go
package utils

import (
	"runtime"
	"strings"
)

// NormalizeLineEndings 将文本中的换行符标准化为当前操作系统的换行符
// 支持 Windows (\r\n) 和 Linux (\n) 系统
func NormalizeLineEndings(text string) string {
	if runtime.GOOS == "windows" {
		// Windows 系统：将所有换行符转换为 \r\n
		// 首先将 \r\n 转换为 \n，避免重复转换
		text = strings.ReplaceAll(text, "\r\n", "\n")
		// 然后将所有 \n 转换为 \r\n
		text = strings.ReplaceAll(text, "\n", "\r\n")
	} else {
		// Linux/Unix 系统：将所有换行符转换为 \n
		// 将 \r\n 转换为 \n
		text = strings.ReplaceAll(text, "\r\n", "\n")
		// 移除单独的 \r
		text = strings.ReplaceAll(text, "\r", "")
	}
	return text
}

// NormalizeLineEndingsBytes 将字节数组中的换行符标准化为当前操作系统的换行符
func NormalizeLineEndingsBytes(data []byte) []byte {
	return []byte(NormalizeLineEndings(string(data)))
}
```

### path.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\path.go`
- **大小**: 1827 字节
- **修改时间**: 2025-10-01T20:43:28+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"path/filepath"
	"strings"
)

// NormalizePath 规范化路径
func NormalizePath(path string) string {
	return filepath.Clean(path)
}

// GetRelativePath 获取相对路径
func GetRelativePath(base, target string) (string, error) {
	return filepath.Rel(base, target)
}

// GetAbsolutePath 获取绝对路径
func GetAbsolutePath(path string) (string, error) {
	return filepath.Abs(path)
}

// IsSubPath 检查是否为子路径
func IsSubPath(parent, child string) bool {
	rel, err := filepath.Rel(parent, child)
	if err != nil {
		return false
	}
	// 如果相对路径是 "." 或空字符串，说明是同一个路径，不算子路径
	if rel == "." || rel == "" {
		return false
	}
	return !strings.HasPrefix(rel, "..")
}

// GetCommonPath 获取共同路径
func GetCommonPath(paths []string) string {
	if len(paths) == 0 {
		return ""
	}
	
	if len(paths) == 1 {
		return filepath.Dir(paths[0])
	}

	// 转换为绝对路径并清理
	absPaths := make([]string, 0, len(paths))
	for _, path := range paths {
		absPath, err := filepath.Abs(path)
		if err != nil {
			continue // 跳过无效路径
		}
		absPaths = append(absPaths, filepath.Clean(absPath))
	}
	
	if len(absPaths) == 0 {
		return ""
	}

	// 找到最短的路径
	minPath := absPaths[0]
	for _, path := range absPaths {
		if len(path) < len(minPath) {
			minPath = path
		}
	}

	// 从最短路径开始，逐步向上查找共同路径
	for {
		common := true
		for _, path := range absPaths {
			// 使用 filepath.HasPrefix 来处理路径分隔符问题
			if !filepath.HasPrefix(path, minPath) {
				common = false
				break
			}
		}
		
		if common {
			return minPath
		}
		
		parent := filepath.Dir(minPath)
		if parent == minPath {
			break
		}
		minPath = parent
	}

	return ""
}
```

### regex.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\regex.go`
- **大小**: 867 字节
- **修改时间**: 2025-10-01T20:43:45+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"fmt"
	"regexp"
)

// MatchPattern 匹配模式
func MatchPattern(pattern, text string) (bool, error) {
	matched, err := regexp.MatchString(pattern, text)
	if err != nil {
		return false, fmt.Errorf("正则表达式匹配失败: %w", err)
	}
	return matched, nil
}

// FindMatches 查找所有匹配
func FindMatches(pattern, text string) ([]string, error) {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return nil, fmt.Errorf("编译正则表达式失败: %w", err)
	}
	return re.FindAllString(text, -1), nil
}

// ReplacePattern 替换模式
func ReplacePattern(pattern, replacement, text string) (string, error) {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return "", fmt.Errorf("编译正则表达式失败: %w", err)
	}
	return re.ReplaceAllString(text, replacement), nil
}
```

### utils.md

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\utils.md`
- **大小**: 571 字节
- **修改时间**: 2025-10-01T20:48:41+08:00

```md
// Package utils 提供通用工具函数
// 本包中的函数已按功能分类到单独的文件中：
// - file.go: 文件工具函数
// - string.go: 字符串工具函数  
// - path.go: 路径工具函数
// - regex.go: 正则表达式工具函数
// - time.go: 时间工具函数
// - validation.go: 验证工具函数
// - encoding.go: 编码工具函数（支持UTF-8、UTF-16、GBK、ANSI）
// - color.go: 颜色工具函数
package utils

// 注意：所有工具函数已迁移到对应的分类文件中
// 请根据需要导入相应的函数
```

### utils_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\utils_test.go`
- **大小**: 20659 字节
- **修改时间**: 2025-10-02T10:25:01+08:00

```go
// Package utils 单元测试
package utils

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

// TestFileUtils 文件工具函数测试
func TestFileExists(t *testing.T) {
	// 测试存在的文件
	if !FileExists("utils_test.go") {
		t.Error("FileExists 应该返回 true 对于存在的文件")
	}

	// 测试不存在的文件
	if FileExists("nonexistent.go") {
		t.Error("FileExists 应该返回 false 对于不存在的文件")
	}
}

func TestDirectoryExists(t *testing.T) {
	// 测试存在的目录
	if !DirectoryExists(".") {
		t.Error("DirectoryExists 应该返回 true 对于存在的目录")
	}

	// 测试不存在的目录
	if DirectoryExists("nonexistent_dir") {
		t.Error("DirectoryExists 应该返回 false 对于不存在的目录")
	}

	// 测试文件而不是目录
	if DirectoryExists("utils.go") {
		t.Error("DirectoryExists 应该返回 false 对于文件")
	}
}

func TestGetFileHash(t *testing.T) {
	// 创建测试文件
	testFile := "test_hash.txt"
	content := "test content"
	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	defer os.Remove(testFile)

	// 测试获取文件哈希
	hash, err := GetFileHash(testFile)
	if err != nil {
		t.Errorf("GetFileHash 返回错误: %v", err)
	}
	if hash == "" {
		t.Error("GetFileHash 应该返回非空哈希值")
	}

	// 测试不存在的文件
	_, err = GetFileHash("nonexistent.txt")
	if err == nil {
		t.Error("GetFileHash 应该对不存在的文件返回错误")
	}
}

func TestGetFileSize(t *testing.T) {
	// 创建测试文件
	testFile := "test_size.txt"
	content := "test content"
	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	defer os.Remove(testFile)

	// 测试获取文件大小
	size, err := GetFileSize(testFile)
	if err != nil {
		t.Errorf("GetFileSize 返回错误: %v", err)
	}
	if size != int64(len(content)) {
		t.Errorf("GetFileSize 返回的大小不正确: 期望 %d, 实际 %d", len(content), size)
	}

	// 测试不存在的文件
	_, err = GetFileSize("nonexistent.txt")
	if err == nil {
		t.Error("GetFileSize 应该对不存在的文件返回错误")
	}
}

func TestGetFileModTime(t *testing.T) {
	// 创建测试文件
	testFile := "test_modtime.txt"
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	defer os.Remove(testFile)

	// 测试获取文件修改时间
	modTime, err := GetFileModTime(testFile)
	if err != nil {
		t.Errorf("GetFileModTime 返回错误: %v", err)
	}
	if modTime.IsZero() {
		t.Error("GetFileModTime 应该返回非零时间")
	}

	// 测试不存在的文件
	_, err = GetFileModTime("nonexistent.txt")
	if err == nil {
		t.Error("GetFileModTime 应该对不存在的文件返回错误")
	}
}

func TestIsTextFile(t *testing.T) {
	testCases := []struct {
		filename string
		expected bool
	}{
		{"test.txt", true},
		{"test.md", true},
		{"test.json", true},
		{"test.go", true},
		{"test.py", true},
		{"test.js", true},
		{"test.html", true},
		{"test.css", true},
		{"test.exe", false},
		{"test.bin", false},
		{"test.jpg", false},
		{"test.png", false},
		{"test.pdf", false},
		{"test", false},
		{"", false},
	}

	for _, tc := range testCases {
		result := IsTextFile(tc.filename)
		if result != tc.expected {
			t.Errorf("IsTextFile(%s) = %v, 期望 %v", tc.filename, result, tc.expected)
		}
	}
}

func TestIsBinaryFile(t *testing.T) {
	// IsBinaryFile 应该返回与 IsTextFile 相反的结果
	testFiles := []string{"test.txt", "test.exe", "test.jpg"}
	
	for _, filename := range testFiles {
		textResult := IsTextFile(filename)
		binaryResult := IsBinaryFile(filename)
		if textResult == binaryResult {
			t.Errorf("IsBinaryFile(%s) = %v, 应该与 IsTextFile 相反", filename, binaryResult)
		}
	}
}

// TestStringUtils 字符串工具函数测试
func TestTruncateString(t *testing.T) {
	testCases := []struct {
		input     string
		maxLength int
		expected  string
	}{
		{"hello", 10, "hello"},
		{"hello world", 5, "he..."},
		{"hello", 3, "hel"},
		{"hello", 0, ""},
		{"", 5, ""},
	}

	for _, tc := range testCases {
		result := TruncateString(tc.input, tc.maxLength)
		if result != tc.expected {
			t.Errorf("TruncateString(%q, %d) = %q, 期望 %q", tc.input, tc.maxLength, result, tc.expected)
		}
	}
}

func TestPadString(t *testing.T) {
	testCases := []struct {
		input    string
		length   int
		padChar  rune
		expected string
	}{
		{"hello", 10, '-', "hello-----"},
		{"hello", 5, '-', "hello"},
		{"hello", 3, '-', "hello"},
		{"", 5, '-', "-----"},
	}

	for _, tc := range testCases {
		result := PadString(tc.input, tc.length, tc.padChar)
		if result != tc.expected {
			t.Errorf("PadString(%q, %d, %q) = %q, 期望 %q", tc.input, tc.length, tc.padChar, result, tc.expected)
		}
	}
}

func TestPadLeft(t *testing.T) {
	testCases := []struct {
		input    string
		length   int
		padChar  rune
		expected string
	}{
		{"hello", 10, '-', "-----hello"},
		{"hello", 5, '-', "hello"},
		{"hello", 3, '-', "hello"},
		{"", 5, '-', "-----"},
	}

	for _, tc := range testCases {
		result := PadLeft(tc.input, tc.length, tc.padChar)
		if result != tc.expected {
			t.Errorf("PadLeft(%q, %d, %q) = %q, 期望 %q", tc.input, tc.length, tc.padChar, result, tc.expected)
		}
	}
}

func TestPadCenter(t *testing.T) {
	testCases := []struct {
		input    string
		length   int
		padChar  rune
		expected string
	}{
		{"hello", 10, '-', "--hello---"},
		{"hello", 9, '-', "--hello--"},
		{"hello", 5, '-', "hello"},
		{"hello", 3, '-', "hello"},
		{"", 5, '-', "-----"},
	}

	for _, tc := range testCases {
		result := PadCenter(tc.input, tc.length, tc.padChar)
		if result != tc.expected {
			t.Errorf("PadCenter(%q, %d, %q) = %q, 期望 %q", tc.input, tc.length, tc.padChar, result, tc.expected)
		}
	}
}

func TestRemoveDuplicates(t *testing.T) {
	testCases := []struct {
		input    []string
		expected []string
	}{
		{[]string{"a", "b", "c", "b", "a"}, []string{"a", "b", "c"}},
		{[]string{"a", "a", "a"}, []string{"a"}},
		{[]string{"a", "b", "c"}, []string{"a", "b", "c"}},
		{[]string{}, []string{}},
		{[]string{""}, []string{""}},
	}

	for _, tc := range testCases {
		result := RemoveDuplicates(tc.input)
		if len(result) != len(tc.expected) {
			t.Errorf("RemoveDuplicates 返回的长度不正确: 期望 %d, 实际 %d", len(tc.expected), len(result))
			continue
		}
		for i := range result {
			if result[i] != tc.expected[i] {
				t.Errorf("RemoveDuplicates 返回的结果不匹配: 期望 %v, 实际 %v", tc.expected, result)
				break
			}
		}
	}
}

func TestSplitLines(t *testing.T) {
	testCases := []struct {
		input    string
		expected []string
	}{
		{"line1\nline2\nline3", []string{"line1", "line2", "line3"}},
		{"line1\r\nline2\r\nline3", []string{"line1", "line2", "line3"}},
		{"single", []string{"single"}},
		{"", []string{""}},
		{"line1\n", []string{"line1", ""}},
	}

	for _, tc := range testCases {
		result := SplitLines(tc.input)
		if len(result) != len(tc.expected) {
			t.Errorf("SplitLines 返回的长度不正确: 期望 %d, 实际 %d", len(tc.expected), len(result))
			continue
		}
		for i := range result {
			if result[i] != tc.expected[i] {
				t.Errorf("SplitLines 返回的结果不匹配: 期望 %v, 实际 %v", tc.expected, result)
				break
			}
		}
	}
}

func TestJoinLines(t *testing.T) {
	testCases := []struct {
		input    []string
		expected string
	}{
		{[]string{"line1", "line2", "line3"}, "line1\nline2\nline3"},
		{[]string{"single"}, "single"},
		{[]string{}, ""},
		{[]string{"line1", "", "line3"}, "line1\n\nline3"},
	}

	for _, tc := range testCases {
		result := JoinLines(tc.input)
		if result != tc.expected {
			t.Errorf("JoinLines(%v) = %q, 期望 %q", tc.input, result, tc.expected)
		}
	}
}

func TestCountLines(t *testing.T) {
	testCases := []struct {
		input    string
		expected int
	}{
		{"line1\nline2\nline3", 3},
		{"line1\r\nline2\r\nline3", 3},
		{"single", 1},
		{"", 1},
		{"line1\n", 2},
	}

	for _, tc := range testCases {
		result := CountLines(tc.input)
		if result != tc.expected {
			t.Errorf("CountLines(%q) = %d, 期望 %d", tc.input, result, tc.expected)
		}
	}
}

// TestPathUtils 路径工具函数测试
func TestNormalizePath(t *testing.T) {
	testCases := []struct {
		input    string
		expected string
	}{
		{"path/to/file", filepath.Join("path", "to", "file")},
		{"path/../file", "file"},
		{"./path/to/file", filepath.Join("path", "to", "file")},
		{"/absolute/path", filepath.Join("/", "absolute", "path")},
	}

	for _, tc := range testCases {
		result := NormalizePath(tc.input)
		if result != tc.expected {
			t.Errorf("NormalizePath(%q) = %q, 期望 %q", tc.input, result, tc.expected)
		}
	}
}

func TestGetRelativePath(t *testing.T) {
	// 创建临时目录结构
	tempDir := t.TempDir()
	subDir := filepath.Join(tempDir, "subdir")
	if err := os.MkdirAll(subDir, 0755); err != nil {
		t.Fatalf("创建测试目录失败: %v", err)
	}

	testFile := filepath.Join(subDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	// 测试获取相对路径
	relPath, err := GetRelativePath(tempDir, testFile)
	if err != nil {
		t.Errorf("GetRelativePath 返回错误: %v", err)
	}
	expected := filepath.Join("subdir", "test.txt")
	if filepath.ToSlash(relPath) != filepath.ToSlash(expected) {
		t.Errorf("GetRelativePath 返回的路径不正确: 期望 %q, 实际 %q", expected, relPath)
	}

	// 测试无效路径
	_, err = GetRelativePath("/nonexistent", testFile)
	if err == nil {
		t.Error("GetRelativePath 应该对无效路径返回错误")
	}
}

func TestGetAbsolutePath(t *testing.T) {
	// 测试相对路径
	relPath := "utils.go"
	absPath, err := GetAbsolutePath(relPath)
	if err != nil {
		t.Errorf("GetAbsolutePath 返回错误: %v", err)
	}
	if !filepath.IsAbs(absPath) {
		t.Error("GetAbsolutePath 应该返回绝对路径")
	}

	// 测试已经存在的绝对路径
	if _, err := GetAbsolutePath(absPath); err != nil {
		t.Errorf("GetAbsolutePath 对绝对路径返回错误: %v", err)
	}
}

func TestIsSubPath(t *testing.T) {
	// 创建临时目录用于测试
	tempDir := t.TempDir()
	subDir := filepath.Join(tempDir, "subdir")
	if err := os.MkdirAll(subDir, 0755); err != nil {
		t.Fatalf("创建测试目录失败: %v", err)
	}

	testCases := []struct {
		parent   string
		child    string
		expected bool
	}{
		{tempDir, subDir, true},
		{tempDir, tempDir, false}, // 相同路径不算子路径
		{tempDir, "/other", false},
		{tempDir, filepath.Join(tempDir, "..", "other"), false},
	}

	for _, tc := range testCases {
		result := IsSubPath(tc.parent, tc.child)
		if result != tc.expected {
			t.Errorf("IsSubPath(%q, %q) = %v, 期望 %v", tc.parent, tc.child, result, tc.expected)
		}
	}
}

func TestGetCommonPath(t *testing.T) {
	// 创建临时目录结构用于测试
	tempDir := t.TempDir()
	dir1 := filepath.Join(tempDir, "a", "b", "c")
	dir2 := filepath.Join(tempDir, "a", "b", "d")
	dir3 := filepath.Join(tempDir, "a", "b", "e")
	dir4 := filepath.Join(tempDir, "a", "d", "e")
	
	// 创建目录
	for _, dir := range []string{dir1, dir2, dir3, dir4} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("创建测试目录失败: %v", err)
		}
	}

	testCases := []struct {
		paths    []string
		expected string
	}{
		{[]string{dir1, dir2, dir3}, filepath.Join(tempDir, "a", "b")},
		{[]string{dir1, dir4}, filepath.Join(tempDir, "a")},
		{[]string{dir1}, filepath.Join(tempDir, "a", "b")},
		{[]string{}, ""},
	}

	for _, tc := range testCases {
		result := GetCommonPath(tc.paths)
		if result != tc.expected {
			t.Errorf("GetCommonPath(%v) = %q, 期望 %q", tc.paths, result, tc.expected)
		}
	}
}

// TestRegexUtils 正则表达式工具函数测试
func TestMatchPattern(t *testing.T) {
	testCases := []struct {
		pattern  string
		text     string
		expected bool
		hasError bool
	}{
		{"hello", "hello world", true, false},
		{"world", "hello world", true, false},
		{"^hello", "hello world", true, false},
		{"world$", "hello world", true, false},
		{"xyz", "hello world", false, false},
		{"[", "hello", false, true}, // 无效的正则表达式
	}

	for _, tc := range testCases {
		result, err := MatchPattern(tc.pattern, tc.text)
		if tc.hasError {
			if err == nil {
				t.Errorf("MatchPattern(%q, %q) 应该返回错误", tc.pattern, tc.text)
			}
		} else {
			if err != nil {
				t.Errorf("MatchPattern(%q, %q) 返回意外错误: %v", tc.pattern, tc.text, err)
			}
			if result != tc.expected {
				t.Errorf("MatchPattern(%q, %q) = %v, 期望 %v", tc.pattern, tc.text, result, tc.expected)
			}
		}
	}
}

func TestFindMatches(t *testing.T) {
	testCases := []struct {
		pattern  string
		text     string
		expected []string
		hasError bool
	}{
		{"l", "hello world", []string{"l", "l", "l"}, false},
		{"o", "hello world", []string{"o", "o"}, false},
		{"xyz", "hello world", []string{}, false},
		{"[", "hello", nil, true}, // 无效的正则表达式
	}

	for _, tc := range testCases {
		result, err := FindMatches(tc.pattern, tc.text)
		if tc.hasError {
			if err == nil {
				t.Errorf("FindMatches(%q, %q) 应该返回错误", tc.pattern, tc.text)
			}
		} else {
			if err != nil {
				t.Errorf("FindMatches(%q, %q) 返回意外错误: %v", tc.pattern, tc.text, err)
			}
			if len(result) != len(tc.expected) {
				t.Errorf("FindMatches(%q, %q) 返回的匹配数量不正确: 期望 %d, 实际 %d", tc.pattern, tc.text, len(tc.expected), len(result))
				continue
			}
			for i := range result {
				if result[i] != tc.expected[i] {
					t.Errorf("FindMatches(%q, %q) 返回的结果不匹配: 期望 %v, 实际 %v", tc.pattern, tc.text, tc.expected, result)
					break
				}
			}
		}
	}
}

func TestReplacePattern(t *testing.T) {
	testCases := []struct {
		pattern     string
		replacement string
		text        string
		expected    string
		hasError    bool
	}{
		{"world", "Go", "hello world", "hello Go", false},
		{"l", "L", "hello", "heLLo", false},
		{"xyz", "ABC", "hello world", "hello world", false},
		{"[", "X", "hello", "", true}, // 无效的正则表达式
	}

	for _, tc := range testCases {
		result, err := ReplacePattern(tc.pattern, tc.replacement, tc.text)
		if tc.hasError {
			if err == nil {
				t.Errorf("ReplacePattern(%q, %q, %q) 应该返回错误", tc.pattern, tc.replacement, tc.text)
			}
		} else {
			if err != nil {
				t.Errorf("ReplacePattern(%q, %q, %q) 返回意外错误: %v", tc.pattern, tc.replacement, tc.text, err)
			}
			if result != tc.expected {
				t.Errorf("ReplacePattern(%q, %q, %q) = %q, 期望 %q", tc.pattern, tc.replacement, tc.text, result, tc.expected)
			}
		}
	}
}

// TestTimeUtils 时间工具函数测试
func TestFormatDuration(t *testing.T) {
	testCases := []struct {
		duration time.Duration
		expected string
	}{
		{500 * time.Millisecond, "0.5s"},
		{1500 * time.Millisecond, "1.5s"},
		{30 * time.Second, "30.0s"},
		{90 * time.Second, "1.5m"},
		{2 * time.Minute, "2.0m"},
		{90 * time.Minute, "1.5h"},
		{3 * time.Hour, "3.0h"},
	}

	for _, tc := range testCases {
		result := FormatDuration(tc.duration)
		if result != tc.expected {
			t.Errorf("FormatDuration(%v) = %q, 期望 %q", tc.duration, result, tc.expected)
		}
	}
}

func TestParseTime(t *testing.T) {
	testCases := []struct {
		timeStr  string
		hasError bool
	}{
		{"2023-01-01T12:00:00Z", false},     // RFC3339
		{"2023-01-01 12:00:00", false},     // 2006-01-02 15:04:05
		{"2023-01-01", false},              // 2006-01-02
		{"12:00:00", false},                // 15:04:05
		{"2023/01/01", false},              // 2006/01/02
		{"invalid", true},                  // 无效格式
		{"2023-13-01", true},               // 无效日期
	}

	for _, tc := range testCases {
		result, err := ParseTime(tc.timeStr)
		if tc.hasError {
			if err == nil {
				t.Errorf("ParseTime(%q) 应该返回错误", tc.timeStr)
			}
		} else {
			if err != nil {
				t.Errorf("ParseTime(%q) 返回意外错误: %v", tc.timeStr, err)
			}
			if result.IsZero() {
				t.Errorf("ParseTime(%q) 返回零时间", tc.timeStr)
			}
		}
	}
}

func TestFormatFileSize(t *testing.T) {
	testCases := []struct {
		bytes    int64
		expected string
	}{
		{0, "0 B"},
		{512, "512 B"},
		{1024, "1.0 KB"},
		{1536, "1.5 KB"},
		{1048576, "1.0 MB"},
		{1073741824, "1.0 GB"},
		{1099511627776, "1.0 TB"},
	}

	for _, tc := range testCases {
		result := FormatFileSize(tc.bytes)
		if result != tc.expected {
			t.Errorf("FormatFileSize(%d) = %q, 期望 %q", tc.bytes, result, tc.expected)
		}
	}
}

// TestValidationUtils 验证工具函数测试
func TestIsValidFilename(t *testing.T) {
	testCases := []struct {
		filename string
		expected bool
	}{
		{"valid.txt", true},
		{"file-name_123.go", true},
		{"", false},
		{"file/name.txt", false},
		{"file\\name.txt", false},
		{"file:name.txt", false},
		{"file*name.txt", false},
		{"file?name.txt", false},
		{"file\"name.txt", false},
		{"file<name.txt", false},
		{"file>name.txt", false},
		{"file|name.txt", false},
		{".hidden", false},
		{"file.", false},
		{" file.txt", false},
		{"file.txt ", false},
	}

	for _, tc := range testCases {
		result := IsValidFilename(tc.filename)
		if result != tc.expected {
			t.Errorf("IsValidFilename(%q) = %v, 期望 %v", tc.filename, result, tc.expected)
		}
	}
}

func TestIsValidPath(t *testing.T) {
	testCases := []struct {
		path     string
		expected bool
	}{
		{"/valid/path", true},
		{"relative/path", true},
		{"", false},
		{strings.Repeat("a", 300), false}, // 超过Windows路径长度限制
		{"path\x00withnull", false},     // 包含空字符
	}

	for _, tc := range testCases {
		result := IsValidPath(tc.path)
		if result != tc.expected {
			t.Errorf("IsValidPath(%q) = %v, 期望 %v", tc.path, result, tc.expected)
		}
	}
}

func TestSafePathJoin(t *testing.T) {
	testCases := []struct {
		base     string
		elem     string
		expected string
		hasError bool
	}{
		{"/base", "file.txt", filepath.Join("/base", "file.txt"), false},
		{"/base", "subdir/file.txt", filepath.Join("/base", "subdir", "file.txt"), false},
		{"/base", "../file.txt", "", true}, // 路径遍历攻击
		{"/base", "subdir/../file.txt", "", true}, // 路径遍历攻击
		{"/base", "", filepath.Join("/base", ""), false},
	}

	for _, tc := range testCases {
		result, err := SafePathJoin(tc.base, tc.elem)
		if tc.hasError {
			if err == nil {
				t.Errorf("SafePathJoin(%q, %q) 应该返回错误", tc.base, tc.elem)
			}
		} else {
			if err != nil {
				t.Errorf("SafePathJoin(%q, %q) 返回意外错误: %v", tc.base, tc.elem, err)
			}
			if result != tc.expected {
				t.Errorf("SafePathJoin(%q, %q) = %q, 期望 %q", tc.base, tc.elem, result, tc.expected)
			}
		}
	}
}

// TestColorUtils 颜色工具函数测试
func TestColorize(t *testing.T) {
	text := "test"
	colored := Colorize(text, ColorRed)
	
	if !strings.Contains(colored, string(ColorRed)) {
		t.Error("Colorize 应该包含颜色代码")
	}
	if !strings.Contains(colored, string(ColorReset)) {
		t.Error("Colorize 应该包含重置代码")
	}
	if !strings.Contains(colored, text) {
		t.Error("Colorize 应该包含原始文本")
	}
}

func TestErrorColor(t *testing.T) {
	result := ErrorColor("error")
	if !strings.Contains(result, string(ColorRed)) {
		t.Error("ErrorColor 应该使用红色")
	}
}

func TestSuccessColor(t *testing.T) {
	result := SuccessColor("success")
	if !strings.Contains(result, string(ColorGreen)) {
		t.Error("SuccessColor 应该使用绿色")
	}
}

func TestWarningColor(t *testing.T) {
	result := WarningColor("warning")
	if !strings.Contains(result, string(ColorYellow)) {
		t.Error("WarningColor 应该使用黄色")
	}
}

func TestInfoColor(t *testing.T) {
	result := InfoColor("info")
	if !strings.Contains(result, string(ColorBlue)) {
		t.Error("InfoColor 应该使用蓝色")
	}
}
```

### validation.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\validation.go`
- **大小**: 1514 字节
- **修改时间**: 2025-10-01T20:44:56+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"fmt"
	"path/filepath"
	"strings"
)

// IsValidFilename 检查文件名是否有效
func IsValidFilename(filename string) bool {
	if filename == "" {
		return false
	}
	
	// 检查是否包含非法字符
	invalidChars := []string{"/", "\\", ":", "*", "?", "\"", "<", ">", "|"}
	for _, char := range invalidChars {
		if strings.Contains(filename, char) {
			return false
		}
	}
	
	// 检查是否以点或空格开头/结尾
	if strings.HasPrefix(filename, ".") || strings.HasSuffix(filename, ".") ||
	   strings.HasPrefix(filename, " ") || strings.HasSuffix(filename, " ") {
		return false
	}
	
	return true
}

// IsValidPath 检查路径是否有效
func IsValidPath(path string) bool {
	if path == "" {
		return false
	}
	
	// 检查路径长度
	if len(path) > 260 { // Windows路径长度限制
		return false
	}
	
	// 检查是否包含空字符
	if strings.Contains(path, "\x00") {
		return false
	}
	
	return true
}

// SafePathJoin 安全地连接路径
func SafePathJoin(base, elem string) (string, error) {
	// 检查路径遍历攻击
	if strings.Contains(elem, "..") {
		return "", fmt.Errorf("路径包含非法字符: %s", elem)
	}
	
	joined := filepath.Join(base, elem)
	
	// 确保结果仍在基础路径内
	if !strings.HasPrefix(filepath.Clean(joined), filepath.Clean(base)) {
		return "", fmt.Errorf("路径超出基础目录范围")
	}
	
	return joined, nil
}
```

### time.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\time.go`
- **大小**: 1128 字节
- **修改时间**: 2025-10-01T20:44:17+08:00

```go
// Package utils 提供通用工具函数
package utils

import (
	"fmt"
	"time"
)

// FormatDuration 格式化持续时间
func FormatDuration(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%.1fs", d.Seconds())
	}
	if d < time.Hour {
		return fmt.Sprintf("%.1fm", d.Minutes())
	}
	return fmt.Sprintf("%.1fh", d.Hours())
}

// ParseTime 解析时间字符串
func ParseTime(timeStr string) (time.Time, error) {
	formats := []string{
		time.RFC3339,
		"2006-01-02 15:04:05",
		"2006-01-02",
		"15:04:05",
		"2006/01/02",
	}

	for _, format := range formats {
		t, err := time.Parse(format, timeStr)
		if err == nil {
			return t, nil
		}
	}

	return time.Time{}, fmt.Errorf("无法解析时间字符串: %s", timeStr)
}

// FormatFileSize 格式化文件大小
func FormatFileSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	
	units := []string{"KB", "MB", "GB", "TB", "PB"}
	return fmt.Sprintf("%.1f %s", float64(bytes)/float64(div), units[exp])
}
```

### main.go

- **路径**: `D:\ide\tool\code-context-generator\main.go`
- **大小**: 4606 字节
- **修改时间**: 2025-10-02T17:35:29+08:00

```go
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"code-context-generator/internal/config"
	"code-context-generator/internal/env"
	"code-context-generator/internal/filesystem"
	"code-context-generator/internal/formatter"
	"code-context-generator/pkg/types"
)

func main() {
	// 手动解析命令行参数
	var format, outputFile string
	var showHelp bool

	args := os.Args[1:]
	for i := 0; i < len(args); i++ {
		arg := args[i]
		switch arg {
		case "-f", "--format":
			if i+1 < len(args) {
				format = args[i+1]
				i++
			}
		case "-o", "--output":
			if i+1 < len(args) {
				outputFile = args[i+1]
				i++
			}
		case "-h", "--help":
			showHelp = true
		case "generate":
			// 忽略generate参数，兼容用户的命令格式
		}
	}

	// 显示帮助信息
	if showHelp {
		fmt.Println("=== 代码上下文生成器 ===")
		fmt.Println("使用方式: go run main.go [generate] [选项]")
		fmt.Println()
		fmt.Println("选项:")
		fmt.Println("  -f string    输出格式 (json, xml, markdown)")
		fmt.Println("  -o string    输出文件路径")
		fmt.Println("  -h           显示帮助信息")
		fmt.Println()
		fmt.Println("示例:")
		fmt.Println("  go run main.go -f markdown -o output.md")
		fmt.Println("  go run main.go generate -f markdown -o output.md")
		fmt.Println("  go run main.go -f json")
		fmt.Println()
		fmt.Println("如果不指定格式，将使用默认格式 (markdown)")
		return
	}

	// 首先加载.env文件（如果存在）
	if err := env.LoadEnv(""); err != nil {
		log.Printf("警告: 加载.env文件失败: %v", err)
	}

	// 创建配置管理器
	cm := config.NewManager()

	// 获取当前目录
	currentDir, err := os.Getwd()
	if err != nil {
		log.Fatalf("获取当前目录失败: %v", err)
	}

	fmt.Println("=== 代码上下文生成器 ===")
	fmt.Printf("当前目录: %s\n", currentDir)
	fmt.Println()

	// 创建文件系统遍历器
	walker := filesystem.NewWalker()

	// 设置遍历选项
	walkOptions := &types.WalkOptions{
		MaxDepth:        3,       // 限制子目录深度
		MaxFileSize:     1048576, // 1MB
		ExcludePatterns: []string{".git", "node_modules", "*.exe", "*.dll"},
		ExcludeBinary:   false,
		ShowHidden:      false,
	}

	// 遍历当前目录
	contextData, err := walker.Walk(currentDir, walkOptions)
	if err != nil {
		log.Fatalf("遍历目录失败: %v", err)
	}

	if len(contextData.Files) == 0 {
		fmt.Println("未找到任何文件")
		return
	}

	fmt.Printf("找到 %d 个文件, %d 个目录\n", contextData.FileCount, contextData.FolderCount)

	// 转换为上下文数据
	contextData.Metadata = map[string]interface{}{
		"root_path":    currentDir,
		"generated_at": "现在",
	}

	// 确定输出格式
	var selectedFormat string
	if format != "" {
		// 使用命令行指定的格式
		selectedFormat = format
		// 验证格式是否有效
		validFormats := map[string]bool{
			"json": true, "xml": true, "markdown": true, "md": true,
		}
		if !validFormats[selectedFormat] {
			log.Fatalf("无效的输出格式: %s，支持的格式: json, xml, markdown", selectedFormat)
		}
		if selectedFormat == "md" {
			selectedFormat = "markdown" // 统一处理
		}
		fmt.Printf("使用指定的输出格式: %s\n", selectedFormat)
	} else {
		// 默认格式
		fmt.Println("\n选择输出格式:")
		fmt.Println("1. JSON")
		fmt.Println("2. XML")
		fmt.Println("3. Markdown")
		fmt.Print("请选择 (1-3): ")

		var choice int
		fmt.Scanln(&choice)

		switch choice {
		case 1:
			selectedFormat = "json"
		case 2:
			selectedFormat = "xml"
		case 3:
			selectedFormat = "markdown"
		default:
			selectedFormat = "json"
		}
	}

	// 创建格式化器
	formatter, err := formatter.NewFormatter(selectedFormat, cm.Get())
	if err != nil {
		log.Fatalf("创建格式化器失败: %v", err)
	}

	// 格式化输出
	outputData, err := formatter.Format(*contextData)
	if err != nil {
		log.Fatalf("格式化输出失败: %v", err)
	}

	// 确定输出文件路径
	var finalOutputFile string
	if outputFile != "" {
		finalOutputFile = outputFile
	} else {
		// 生成默认输出文件名
		finalOutputFile = fmt.Sprintf("context_%s.%s",
			filepath.Base(currentDir), selectedFormat)
	}

	// 保存到文件
	if err := os.WriteFile(finalOutputFile, []byte(outputData), 0644); err != nil {
		log.Fatalf("写入输出文件失败: %v", err)
	}

	fmt.Printf("\n✅ 成功生成代码上下文文件: %s\n", finalOutputFile)
	fmt.Printf("📊 包含 %d 个文件，%d 个文件夹\n", contextData.FileCount, contextData.FolderCount)
	fmt.Printf("💾 总大小: %.2f MB\n", float64(contextData.TotalSize)/(1024*1024))
}

```

### text_test.go

- **路径**: `D:\ide\tool\code-context-generator\internal\utils\text_test.go`
- **大小**: 1725 字节
- **修改时间**: 2025-10-02T09:34:37+08:00

```go
package utils

import (
	"runtime"
	"testing"
)

func TestNormalizeLineEndings(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Unix 换行符",
			input:    "第一行\n第二行\n第三行",
			expected: "第一行\n第二行\n第三行",
		},
		{
			name:     "Windows 换行符",
			input:    "第一行\r\n第二行\r\n第三行",
			expected: "第一行\n第二行\n第三行",
		},
		{
			name:     "混合换行符",
			input:    "第一行\n第二行\r\n第三行",
			expected: "第一行\n第二行\n第三行",
		},
		{
			name:     "无换行符",
			input:    "单行文本",
			expected: "单行文本",
		},
		{
			name:     "空字符串",
			input:    "",
			expected: "",
		},
	}

	if runtime.GOOS == "windows" {
		// Windows 系统下，预期结果是 \r\n
		for i := range tests {
			tests[i].expected = normalizeToWindows(tests[i].expected)
		}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := NormalizeLineEndings(tt.input)
			if result != tt.expected {
				t.Errorf("NormalizeLineEndings() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestNormalizeLineEndingsBytes(t *testing.T) {
	input := []byte("第一行\n第二行\r\n第三行")
	result := NormalizeLineEndingsBytes(input)
	
	expected := "第一行\n第二行\n第三行"
	if runtime.GOOS == "windows" {
		expected = "第一行\r\n第二行\r\n第三行"
	}
	
	if string(result) != expected {
		t.Errorf("NormalizeLineEndingsBytes() = %q, want %q", string(result), expected)
	}
}

// 辅助函数：将字符串中的 \n 转换为 \r\n
func normalizeToWindows(s string) string {
	return string(NormalizeLineEndingsBytes([]byte(s)))
}
```

### constants.go

- **路径**: `D:\ide\tool\code-context-generator\pkg\constants\constants.go`
- **大小**: 2239 字节
- **修改时间**: 2025-09-30T22:38:25+08:00

```go
// Package constants 定义项目的常量
package constants

import "time"

// 应用常量
const (
	AppName        = "code-context-generator"
	AppVersion     = "1.0.0"
	AppDescription = "High-Performance Code Context Generation Tool"
)

// 配置常量
const (
	DefaultConfigFile       = "config.yaml"
	DefaultFormat           = "xml"
	DefaultOutputDir        = ""
	DefaultFilenameTemplate = "context_{{.timestamp}}.{{.extension}}"
	DefaultTimestampFormat  = "20060102_150405"
	MaxFileSizeDefault      = 10 * 1024 * 1024 // 10MB
)

// 文件处理常量
const (
	MaxFileSizeLimit  = 100 * 1024 * 1024 // 100MB
	DefaultMaxDepth   = 0                 // 无限制
	BufferSize        = 32 * 1024         // 32KB
	MaxConcurrency    = 10
	ChannelBufferSize = 100
)

// UI常量
const (
	DefaultMinChars       = 1
	DefaultMaxSuggestions = 10
	DefaultShowHidden     = false
	DefaultShowSize       = true
	DefaultShowModified   = false
)

// 格式常量
const (
	FormatXML      = "xml"
	FormatJSON     = "json"
	FormatTOML     = "toml"
	FormatMarkdown = "markdown"
)

// 错误消息常量
const (
	ErrMsgConfigLoad       = "配置文件加载失败"
	ErrMsgConfigValidate   = "配置验证失败"
	ErrMsgFileRead         = "文件读取失败"
	ErrMsgFileWrite        = "文件写入失败"
	ErrMsgFormatGenerate   = "格式生成失败"
	ErrMsgPathInvalid      = "路径无效"
	ErrMsgPermissionDenied = "权限不足"
	ErrMsgFileTooLarge     = "文件过大"
)

// 时间常量
const (
	DefaultTimeout         = 30 * time.Second
	FileWatchInterval      = 1 * time.Second
	ProgressUpdateInterval = 100 * time.Millisecond
)

// 正则表达式模式
const (
	PatternHiddenFile  = `^\.`
	PatternGitignore   = `^\.gitignore$`
	PatternConfigFile  = `^config\.(yaml|yml|json|toml)$`
	PatternTemplateVar = `\{\{\.(\w+)\}\}`
)

// 环境变量前缀
const (
	EnvPrefix = "CODE_CONTEXT_"
)

// 默认排除模式
var DefaultExcludePatterns = []string{
	"*.tmp",
	"*.log",
	"*.swp",
	".*",
	"node_modules/",
	"target/",
	"dist/",
	"build/",
	".env",
	".git/",
	".vscode/",
	".idea/",
	"__pycache__/",
	"*.pyc",
	".venv",
	"*.class",
}

// 支持的格式列表
var SupportedFormats = []string{
	FormatXML,
	FormatJSON,
	FormatTOML,
	FormatMarkdown,
}

```

### types.go

- **路径**: `D:\ide\tool\code-context-generator\pkg\types\types.go`
- **大小**: 10853 字节
- **修改时间**: 2025-10-02T17:34:54+08:00

```go
// Package types 定义项目的核心类型和接口
package types

import (
	"fmt"
	"time"
)

// FileInfo 文件信息结构体
type FileInfo struct {
	Name     string    `yaml:"name" json:"name" toml:"name"`
	Path     string    `yaml:"path" json:"path" toml:"path"`
	Content  string    `yaml:"content" json:"content" toml:"content"`
	Size     int64     `yaml:"size" json:"size" toml:"size"`
	ModTime  time.Time `yaml:"mod_time" json:"mod_time" toml:"mod_time"`
	IsDir    bool      `yaml:"is_dir" json:"is_dir" toml:"is_dir"`
	IsHidden bool      `yaml:"is_hidden" json:"is_hidden" toml:"is_hidden"`
	IsBinary bool      `yaml:"is_binary" json:"is_binary" toml:"is_binary"`
}

// FolderInfo 文件夹信息结构体
type FolderInfo struct {
	Name     string       `yaml:"name" json:"name" toml:"name"`
	Path     string       `yaml:"path" json:"path" toml:"path"`
	Files    []FileInfo   `yaml:"files" json:"files" toml:"files"`
	Folders  []FolderInfo `yaml:"folders" json:"folders" toml:"folders"`
	ModTime  time.Time    `yaml:"mod_time" json:"mod_time" toml:"mod_time"`
	IsHidden bool         `yaml:"is_hidden" json:"is_hidden" toml:"is_hidden"`
	Size     int64        `yaml:"size" json:"size" toml:"size"`
	Count    int          `yaml:"count" json:"count" toml:"count"`
}

// ContextData 上下文数据结构
type ContextData struct {
	Files       []FileInfo             `yaml:"files" json:"files" toml:"files"`
	Folders     []FolderInfo           `yaml:"folders" json:"folders" toml:"folders"`
	FileCount   int                    `yaml:"file_count" json:"file_count" toml:"file_count"`
	FolderCount int                    `yaml:"folder_count" json:"folder_count" toml:"folder_count"`
	TotalSize   int64                  `yaml:"total_size" json:"total_size" toml:"total_size"`
	Metadata    map[string]interface{} `yaml:"metadata" json:"metadata" toml:"metadata"`
}

// WalkResult 遍历结果
type WalkResult struct {
	Files       []FileInfo   `yaml:"files" json:"files" toml:"files"`
	Folders     []FolderInfo `yaml:"folders" json:"folders" toml:"folders"`
	FileCount   int          `yaml:"file_count" json:"file_count" toml:"file_count"`
	FolderCount int          `yaml:"folder_count" json:"folder_count" toml:"folder_count"`
	TotalSize   int64        `yaml:"total_size" json:"total_size" toml:"total_size"`
	RootPath    string       `yaml:"root_path" json:"root_path" toml:"root_path"`
	ScanDuration string      `yaml:"scan_duration" json:"scan_duration" toml:"scan_duration"`
}

// Config 统一配置结构体
type Config struct {
	Formats       FormatsConfig       `yaml:"formats" json:"formats" toml:"formats"`
	Fields        FieldsConfig        `yaml:"fields" json:"fields" toml:"fields"`
	Filters       FiltersConfig       `yaml:"filters" json:"filters" toml:"filters"`
	Output        OutputConfig        `yaml:"output" json:"output" toml:"output"`
	UI            UIConfig            `yaml:"ui" json:"ui" toml:"ui"`
	FileProcessing FileProcessingConfig `yaml:"file_processing" json:"file_processing" toml:"file_processing"`
	Performance   PerformanceConfig   `yaml:"performance" json:"performance" toml:"performance"`
	Logging       LoggingConfig       `yaml:"logging" json:"logging" toml:"logging"`
}

// FormatsConfig 输出格式配置
type FormatsConfig struct {
	XML      XMLFormatConfig `yaml:"xml" json:"xml" toml:"xml"`
	JSON     FormatConfig `yaml:"json" json:"json" toml:"json"`
	TOML     FormatConfig `yaml:"toml" json:"toml" toml:"toml"`
	Markdown FormatConfig `yaml:"markdown" json:"markdown" toml:"markdown"`
}

// FormatConfig 单个格式配置
type FormatConfig struct {
	Enabled    bool                   `yaml:"enabled" json:"enabled" toml:"enabled"`
	Structure  map[string]interface{} `yaml:"structure" json:"structure" toml:"structure"`
	Fields     map[string]string      `yaml:"fields" json:"fields" toml:"fields"`
	Template   string                 `yaml:"template" json:"template" toml:"template"`
	Formatting map[string]interface{} `yaml:"formatting" json:"formatting" toml:"formatting"`
}

// XMLFormatConfig XML格式专用配置
type XMLFormatConfig struct {
	FormatConfig `yaml:",inline" json:",inline" toml:",inline"`
	RootTag      string            `yaml:"root_tag" json:"root_tag" toml:"root_tag"`
	FileTag      string            `yaml:"file_tag" json:"file_tag" toml:"file_tag"`
	FolderTag    string            `yaml:"folder_tag" json:"folder_tag" toml:"folder_tag"`
	FilesTag     string            `yaml:"files_tag" json:"files_tag" toml:"files_tag"`
	Formatting   XMLFormattingConfig `yaml:"formatting" json:"formatting" toml:"formatting"`
}

// XMLFormattingConfig XML格式化配置
type XMLFormattingConfig struct {
	Indent      string           `yaml:"indent" json:"indent" toml:"indent"`
	Declaration bool             `yaml:"declaration" json:"declaration" toml:"declaration"`
	Encoding    string           `yaml:"encoding" json:"encoding" toml:"encoding"`
	ContentHandling XMLContentHandling `yaml:"content_handling" json:"content_handling" toml:"content_handling"`
}

// XMLContentHandling XML内容处理方式
type XMLContentHandling string

const (
	// XMLContentEscaped 使用XML实体转义（默认）
	XMLContentEscaped XMLContentHandling = "escaped"
	// XMLContentCDATA 使用CDATA包装
	XMLContentCDATA XMLContentHandling = "cdata"
	// XMLContentRaw 保留原始格式（最小转义）
	XMLContentRaw XMLContentHandling = "raw"
)

// FieldsConfig 字段配置
type FieldsConfig struct {
	CustomNames map[string]string `yaml:"custom_names" json:"custom_names" toml:"custom_names"`
	Filter      struct {
		Include []string `yaml:"include" json:"include" toml:"include"`
		Exclude []string `yaml:"exclude" json:"exclude" toml:"exclude"`
	} `yaml:"filter" json:"filter" toml:"filter"`
	Processing struct {
		MaxLength      int  `yaml:"max_length" json:"max_length" toml:"max_length"`
		AddLineNumbers bool `yaml:"add_line_numbers" json:"add_line_numbers" toml:"add_line_numbers"`
		TrimWhitespace bool `yaml:"trim_whitespace" json:"trim_whitespace" toml:"trim_whitespace"`
		CodeHighlight  bool `yaml:"code_highlight" json:"code_highlight" toml:"code_highlight"`
	} `yaml:"processing" json:"processing" toml:"processing"`
}

// FiltersConfig 文件过滤配置
type FiltersConfig struct {
	MaxFileSize     string   `yaml:"max_file_size" json:"max_file_size" toml:"max_file_size"`
	ExcludePatterns []string `yaml:"exclude_patterns" json:"exclude_patterns" toml:"exclude_patterns"`
	IncludePatterns []string `yaml:"include_patterns" json:"include_patterns" toml:"include_patterns"`
	MaxDepth        int      `yaml:"max_depth" json:"max_depth" toml:"max_depth"`
	FollowSymlinks  bool     `yaml:"follow_symlinks" json:"follow_symlinks" toml:"follow_symlinks"`
	ExcludeBinary   bool     `yaml:"exclude_binary" json:"exclude_binary" toml:"exclude_binary"`
}

// OutputConfig 输出配置
type OutputConfig struct {
	Format       string `yaml:"format" json:"format" toml:"format"`
	FilePath     string `yaml:"file_path" json:"file_path" toml:"file_path"`
	Encoding     string `yaml:"encoding" json:"encoding" toml:"encoding"`
	DefaultFormat    string `yaml:"default_format" json:"default_format" toml:"default_format"`
	OutputDir        string `yaml:"output_dir" json:"output_dir" toml:"output_dir"`
	FilenameTemplate string `yaml:"filename_template" json:"filename_template" toml:"filename_template"`
	TimestampFormat  string `yaml:"timestamp_format" json:"timestamp_format" toml:"timestamp_format"`
}

// UIConfig 界面配置
type UIConfig struct {
	Theme         string `yaml:"theme" json:"theme" toml:"theme"`
	ShowProgress  bool   `yaml:"show_progress" json:"show_progress" toml:"show_progress"`
	ShowSize      bool   `yaml:"show_size" json:"show_size" toml:"show_size"`
	ShowDate      bool   `yaml:"show_date" json:"show_date" toml:"show_date"`
	ShowPreview   bool   `yaml:"show_preview" json:"show_preview" toml:"show_preview"`
	Selector struct {
		ShowHidden   bool `yaml:"show_hidden" json:"show_hidden" toml:"show_hidden"`
		ShowSize     bool `yaml:"show_size" json:"show_size" toml:"show_size"`
		ShowModified bool `yaml:"show_modified" json:"show_modified" toml:"show_modified"`
	} `yaml:"selector" json:"selector" toml:"selector"`
}

// SelectOptions 选择选项
type SelectOptions struct {
	Recursive       bool
	IncludePatterns []string
	ExcludePatterns []string
	MaxDepth        int
	ShowHidden      bool
	SortBy          string
}

// WalkOptions 文件遍历选项
type WalkOptions struct {
	MaxDepth        int
	MaxFileSize     int64
	ExcludePatterns []string
	IncludePatterns []string
	FollowSymlinks  bool
	ShowHidden      bool
	ExcludeBinary   bool
	SelectedFiles   []string // 选中的具体文件路径，如果为空则使用模式匹配
}

// FileProcessingConfig 文件处理配置
type FileProcessingConfig struct {
	IncludeHidden   bool
	MaxFileSize   int64
	MaxDepth      int
	ExcludePatterns []string
	IncludePatterns []string
	IncludeContent  bool
	IncludeHash     bool
}

// PerformanceConfig 性能配置
type PerformanceConfig struct {
	MaxWorkers   int
	BufferSize   int
	CacheEnabled bool
	CacheSize    int
}

// LoggingConfig 日志配置
type LoggingConfig struct {
	Level      string
	FilePath   string
	MaxSize    int
	MaxBackups int
	MaxAge     int
}

// CLIOptions 命令行选项
type CLIOptions struct {
	Format           string
	Output           string
	Config           string
	Exclude          []string
	Include          []string
	MaxDepth         int
	FollowSymlinks   bool
	OutputDir        string
	FilenameTemplate string
	ValidateConfig   bool
}

// AppError 应用错误类型
type AppError struct {
	Type    ErrorType
	Message string
	Cause   error
	Context map[string]interface{}
}

// ErrorType 错误类型枚举
type ErrorType int

const (
	ErrConfig ErrorType = iota
	ErrFileSystem
	ErrFormat
	ErrValidation
	ErrPermission
	ErrNetwork
	ErrUnknown
)

// String 返回错误类型的字符串表示
func (et ErrorType) String() string {
	switch et {
	case ErrConfig:
		return "ConfigError"
	case ErrFileSystem:
		return "FileSystemError"
	case ErrFormat:
		return "FormatError"
	case ErrValidation:
		return "ValidationError"
	case ErrPermission:
		return "PermissionError"
	case ErrNetwork:
		return "NetworkError"
	default:
		return "UnknownError"
	}
}

// Error 实现error接口
func (ae *AppError) Error() string {
	if ae.Cause != nil {
		return fmt.Sprintf("%s: %s (caused by: %v)", ae.Type, ae.Message, ae.Cause)
	}
	return fmt.Sprintf("%s: %s", ae.Type, ae.Message)
}

// Unwrap 返回底层错误
func (ae *AppError) Unwrap() error {
	return ae.Cause
}

```

### test.txt

- **路径**: `D:\ide\tool\code-context-generator\test.txt`
- **大小**: 68 字节
- **修改时间**: 2025-10-02T11:59:28+08:00

```txt
这是一个测试文件。
用于测试文件内容打包功能。
```

### data.csv

- **路径**: `D:\ide\tool\code-context-generator\test_files\data.csv`
- **大小**: 26 字节
- **修改时间**: 2025-10-01T12:32:08+08:00

**[二进制文件 - 内容未显示]**

### config.toml

- **路径**: `D:\ide\tool\code-context-generator\test_files\config.toml`
- **大小**: 34 字节
- **修改时间**: 2025-10-01T12:32:08+08:00

```toml
title = "test"

```

### config.json

- **路径**: `D:\ide\tool\code-context-generator\test_files\config.json`
- **大小**: 38 字节
- **修改时间**: 2025-10-01T12:32:08+08:00

```json
{"key": "value"}

```

### readme.md

- **路径**: `D:\ide\tool\code-context-generator\test_files\readme.md`
- **大小**: 18 字节
- **修改时间**: 2025-10-01T12:32:08+08:00

```md
# Test

```

### data.txt

- **路径**: `D:\ide\tool\code-context-generator\test_files\data.txt`
- **大小**: 30 字节
- **修改时间**: 2025-10-01T12:32:08+08:00

```txt
test content

```

### config.xml

- **路径**: `D:\ide\tool\code-context-generator\test_files\config.xml`
- **大小**: 32 字节
- **修改时间**: 2025-10-01T12:32:08+08:00

```xml
<root></root>

```

## 文件夹

### .git

- **路径**: `D:\ide\tool\code-context-generator\.git`
- **文件数**: 7
- **文件数**: 7

#### 文件列表

- `COMMIT_EDITMSG` (7 字节)
- `FETCH_HEAD` (111 字节)
- `HEAD` (21 字节)
- `ORIG_HEAD` (41 字节)
- `config` (296 字节)
- `description` (73 字节)
- `index` (7178 字节)

### hooks

- **路径**: `D:\ide\tool\code-context-generator\.git\hooks`
- **文件数**: 14
- **文件数**: 14

#### 文件列表

- `applypatch-msg.sample` (478 字节)
- `commit-msg.sample` (896 字节)
- `fsmonitor-watchman.sample` (4726 字节)
- `post-update.sample` (189 字节)
- `pre-applypatch.sample` (424 字节)
- `pre-commit.sample` (1649 字节)
- `pre-merge-commit.sample` (416 字节)
- `pre-push.sample` (1374 字节)
- `pre-rebase.sample` (4898 字节)
- `pre-receive.sample` (544 字节)
- `prepare-commit-msg.sample` (1492 字节)
- `push-to-checkout.sample` (2783 字节)
- `sendemail-validate.sample` (2308 字节)
- `update.sample` (3650 字节)

### info

- **路径**: `D:\ide\tool\code-context-generator\.git\info`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `exclude` (240 字节)

### logs

- **路径**: `D:\ide\tool\code-context-generator\.git\logs`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `HEAD` (5824 字节)

### refs

- **路径**: `D:\ide\tool\code-context-generator\.git\logs\refs`
- **文件数**: 0
- **文件数**: 0

### objects

- **路径**: `D:\ide\tool\code-context-generator\.git\objects`
- **文件数**: 0
- **文件数**: 0

### 00

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\00`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `247a45c920c6c8d3f39820b12dd546bde388d8` (382 字节)
- `3e03c221bedbb1ae3b21632cbfe10ff1b9e44e` (4019 字节)
- `4fe6f747a874899b8f65e60749d66673d78669` (39 字节)

### 01

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\01`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `495e460897a57040438bee047c45a0231030d2` (213 字节)
- `83a2040fe7f2199d7430a3abfb55c3368aeed2` (3378 字节)
- `eabdca3520e6996d50ac9c245f0f66c9e23e88` (342 字节)

### 03

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\03`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `83d03a2dbd6c0373a3ae2b7b02aaae26a647ff` (153 字节)

### 04

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\04`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `1e7225fa24ffbb1fa83950723bb43599d2f335` (61 字节)
- `90b8833fbb45aadd25c2bb10ae3546d77bc29a` (3308 字节)
- `edefe17f6b936616a483d8708703a828b47418` (667 字节)

### 05

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\05`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `2df305d8491e1be02205cd6de2ebd0057e3603` (147 字节)
- `54794f2d8e8ef460a2e84666c8a4a4b29a3612` (2744 字节)
- `6e0df08a3e3de63e95c0f3299a8220b583be09` (3657 字节)
- `92b090316b89e6ace155129b9d27b01840885d` (4132 字节)

### 06

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\06`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `a2eb7bc050d002c91b0e410a6a5f7f2081a142` (206 字节)
- `fd4e5b6317dbe3d2f9c5ae1c397b38bc06b6b8` (116 字节)

### 07

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\07`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `6dccddcb74b9884a705dc9323a377f66003baa` (52 字节)

### 08

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\08`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `5b663ea37baf21cc2efbb9154c4fe01c0e50d7` (2516 字节)
- `7fd7477a34a0561e22e3c7d74f83416ebc6791` (1536 字节)
- `926985b0d7423dc541eb25e4a5f3940772cb09` (585 字节)
- `bb0f3b6f29fddb2259fd1075f871a04a7c7110` (161 字节)
- `e5616068ed1bdf5b10351e082421ba280fc075` (346 字节)

### 09

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\09`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `c99f59c5c24bf6922a47c1e13d8c4d7a45c0df` (87 字节)

### 0a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\0a`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `4ce6c4bb4ed85576d04036fcd65c7770616b33` (2070 字节)
- `568d1392ded7ec46b96633f5ac241477c0ac11` (925 字节)

### 0b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\0b`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `781347f03de9afb0b5e4302a328f42763919a5` (1763 字节)
- `7cb3e94d8fb7537e5544a2345a195f0f36934d` (19 字节)
- `857ebeeda475e08cfd7da2c9888e144a348da1` (2620 字节)
- `f462a51d8acc498c21506a0183a6a17241e7c7` (56 字节)

### 0c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\0c`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `30b401c50b0922ef7f02e618e8eb61aa4c4d97` (1263 字节)
- `81719759b3a0d8797f8feaba68bf2f1bce59b2` (585 字节)
- `8d832462c3e57fb35b928b7fb960ac36254fb1` (158 字节)

### 0d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\0d`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `cade10134cefc8ad59e5dc2fa17a33ee5a8bad` (5635 字节)

### 0e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\0e`
- **文件数**: 7
- **文件数**: 7

#### 文件列表

- `0562610d38e5df5399f5177dce21676642c685` (996 字节)
- `1125fc3079199d7d5361ad07430fb52d5c1153` (342 字节)
- `1382762de1eb3c1f62b8574298bf5280c5c0bb` (158 字节)
- `2877f895125add521746e39e8da7a3a90b65b9` (3484 字节)
- `6136e6079dc57dd6e436c1da9ccf325ad31a1b` (125 字节)
- `931264d815f152e4fe634634b2f33f795a73d9` (2954 字节)
- `9350a3a3a3692076586effbbbda1e49a75812b` (2115 字节)

### 0f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\0f`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `44177973ea9d89b60d757b8895e51d07efd82e` (6212 字节)
- `ab2037fbabb3e164df17484b719c634c6f792d` (3790 字节)
- `acdb39406b1939e5000f074cdd430aa7df13a3` (60 字节)
- `da5a574c7e9c3b78797620cfed6e62cae3e807` (160 字节)
- `f0b4af3a33f77fa4fec22f860ad7679ec08770` (1569 字节)

### 10

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\10`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `ab2013b356f76300c04ba8d6b08dea73226015` (705 字节)
- `b9bf992aa8db56718e0db18acefb4780fd6b0e` (2988 字节)
- `c48854ef8be9fdea791dc86b7141b7cc31c762` (1685 字节)

### 11

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\11`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `86864aef18bd5b732918810c51fac79e739867` (73 字节)

### 12

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\12`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `9e5f42b1b27ea37467587887f75e6c7e648bdf` (329 字节)
- `b440d8a695cac7e2a495bd5e858b1e5928c220` (2236 字节)

### 13

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\13`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `e89e63d790b4105e2d2edc2cc298d615b6218c` (5366 字节)

### 14

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\14`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `2841daefc0634f479e2d883524d420478334ea` (2129 字节)
- `6944f0d2974ce0f8726343a85da4b1dfe554b6` (58 字节)
- `8b6e91b2d4f1d5c91f50499e425cf5447a491c` (279 字节)

### 16

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\16`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `f0b94c524500866f7d2424e65084898a70aa4b` (342 字节)

### 17

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\17`
- **文件数**: 7
- **文件数**: 7

#### 文件列表

- `165f7490a9e2e7319b77d367d60c22e00a218f` (379 字节)
- `21a9c977cddee966ddd859e239a0f3539282d2` (72 字节)
- `3764aff64038eccc388b0f8c0f9f7b41e4bd9f` (152 字节)
- `3dae05bb83a29ea1f7265a99ddf3ef3ad89440` (536 字节)
- `6494b083b0c813c07dba8f7d0845a90c8b6e0d` (534 字节)
- `c39323dda6fec32719351466dfff7cdebf8d13` (1185 字节)
- `c5cddf79c69a67553715494da5ae7801164375` (286 字节)

### 18

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\18`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `2415eb54da6f60c58b3da6acb30129b523006f` (300 字节)
- `466b647ed1eeb4c641c2cf148aee3bf34bdb7f` (795 字节)
- `4b0ce4ac6e6a2f531b5b87bc9b8b94a3fac001` (663043 字节)
- `5a45a0970c6114eb0be14aa94192cf55af539a` (3645 字节)
- `aa983f3bd807b1137324397fed3a742d623c68` (185 字节)
- `ed499ca09dbd4eaac8604c5023fc5240c249b3` (670 字节)

### 1a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\1a`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `019c36b723c1a5a25c0272002dd4dc01a46130` (864 字节)
- `3c2eac568e0cb8d3cd472106ab9243b21c65a0` (4136 字节)
- `4aa0e148ea3fdd2ffe02b95ed860cb72e48caa` (608 字节)
- `6de89c2d0e77b6ca07b15c91e2518f9b108224` (318 字节)

### 1b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\1b`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `2ec55bb86809a35e8502a5677de445bb420840` (2992887 字节)
- `4c9da0ae33f7e5bd374d2ae7274be605323ed8` (242 字节)
- `bb8859aaa360809e0c1b878be921ea0347bf01` (72 字节)
- `e6967f8b14befcbdeb09884eb14d70aa34f566` (96 字节)

### 1c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\1c`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `6e057140047cf605f66c5ed22fcbf367cc0772` (3076 字节)
- `996a4ae9feec8f5cb0faac596aaf3583a5bf4c` (286 字节)

### 1d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\1d`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `141e97b61ae26954ed7c1aadf6db8b2bc52087` (158 字节)
- `169f5b37056f864ebe17ae31e8f8d28647156f` (1005 字节)
- `a1598d362f019b66b1991a20f6ea8306054b9f` (666 字节)

### 1e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\1e`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `1d1a55e05fdf0ec069dfe25cc7bb0042c30ff0` (689 字节)
- `2a6c4a96ea48dab632e55c9a3d308aa729fe0d` (50 字节)

### 1f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\1f`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `39afef4b4d6834c0103854b5eba7c572fb6289` (53 字节)
- `4720fddc0bff63c547ccd14e84143584cb353e` (2936 字节)
- `794c6fb9bd32b4ea8301e72be5e22d0f6e738b` (4523 字节)
- `e233903631d47f6d601debfb8a59168de0a172` (83 字节)

### 20

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\20`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `00258ac283bff9abedb42247f472c29b1a3185` (1443 字节)
- `085ddf834586a086466b351f46ef1181e9cf98` (3299 字节)
- `1c3be4aab6ad1739f16a6355c019aa8374185a` (5461 字节)
- `c7f92b9e7e028ee8576fbc4a950feb85e3ac59` (320 字节)

### 21

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\21`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `21c3049bdc6ea9c2c73b648b3d9a427597451b` (586140 字节)
- `4760f87a7847005aa4c4c04476e4b94a749ed1` (413351 字节)

### 22

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\22`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `5d2864a6d12632887de284075336619eb8f90d` (160 字节)
- `9471cee9a0a8774c06ce162c08284ad9801927` (224 字节)
- `dd706c068dfe1e2de652719a9f44aac85d3821` (5167 字节)

### 23

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\23`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `15cb30675df748bf0591e6f4f0f4cf7525d93f` (986 字节)

### 24

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\24`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `785b781cbc2d10a75170248787dbc17d4a7f2c` (84 字节)
- `b32a7ac86f7bb9832022bf2ee4e83bca50087a` (2984 字节)
- `ca74cb8dc4d967c5d69716a78f9af180208545` (34 字节)

### 26

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\26`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `01606a48e3ae906372a20add5cfc9d7bdeb9a3` (3237 字节)
- `7bccd089809bf0307345830d8f3ba75e7cc86f` (3663 字节)
- `9c8f91ea633ecbd42d617f1365c9b747e475b9` (2307 字节)
- `a4c21968329b60872a9be344e390220e3877e3` (3540 字节)
- `e683607b40ff430ffeb45756e1d2c01500c6dc` (2643 字节)

### 28

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\28`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `74e9aa607c30aa1693728cbad45a882cac344e` (626 字节)
- `a674acb4a8bdd63b2c0f7678df8f5cc89f4641` (406 字节)

### 29

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\29`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `34de2cb2506d38d64d729337d5cfbcc78914e6` (3475 字节)
- `439e54628dfedcb838ac0cbde07e3d065065b4` (5361 字节)
- `c5efe9a8a898a15efa11cf17780a1593f838c8` (3704 字节)

### 2a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\2a`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `357639960f892fb436a585f9fc389e6075a194` (3639 字节)

### 2c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\2c`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `1f7ece50b29be678e31969ffb88b25acb771ab` (86 字节)
- `9c73ea53ae2ea81a9055b489a457f9b3a2f064` (1186 字节)
- `ea81f78237608bc505b66b3597e759008c439f` (85 字节)
- `fb870d45d5242a5bca591fff9dd0c0b18b02bf` (5332 字节)

### 2d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\2d`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `2b8306666185968f63a383274bed2813e1efc7` (279390 字节)
- `2cb8f7c2889317be713ade88e90d5adf05f64d` (1684 字节)
- `b25f2b9909b8a869212f73d81d2273eca2438b` (3751 字节)
- `cbec96897ad4239818db5eada50b3cb03936b4` (132 字节)

### 2e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\2e`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `05a151dc06570a44079607d18c592c1f797025` (80 字节)
- `09f9ba46feaf32cad5019e02e74ad859012384` (3578 字节)
- `9f2c4fee5ce6a874ee00e50d386b8baba2f438` (96 字节)
- `d0efa995e4df855206341c670c1b3ef34a415b` (823 字节)

### 2f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\2f`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `20209249010f58002cca02e999ca750d9b606a` (5387 字节)
- `329646183ecb3817f55e9c41e939d332cb1d6e` (241 字节)
- `5de5c5647715948b444fee17c73ea88d35a780` (224 字节)
- `a72a304b3a2276210b2a5bcdb0c6d84194b4a3` (4303 字节)

### 30

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\30`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `4ad45e8cc9e0f53f34254c816e3d7c68426421` (139 字节)
- `c02a3c3c51c7c520c06c6cf6248fad796bb760` (3544 字节)
- `ce523c9c8dc0a9afd549aab2f0d27a25ab4554` (97 字节)

### 31

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\31`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `7284e274a4d142f7d5b9c663f93dcd3060e776` (4809 字节)
- `80c7cd803fc21a74f94fd5a7073e6fb0893a71` (460 字节)

### 32

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\32`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `786d280d95b0f3911ea3bc513c06032983a15f` (97 字节)

### 33

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\33`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `29da35bf4b2f53f17fb67b3d6983896e34e482` (85 字节)
- `3d042ee78ebb76df0147f3893451f03f90850a` (857 字节)

### 34

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\34`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `691eba193150ce071569872c1ca4a7fcbc5e2e` (2992881 字节)
- `adfc5814f684589fc137ca6b75364201dbb1f0` (4275 字节)
- `b15ae9c428c4ab717531e9e37ef756c02c5115` (326 字节)
- `d9533f162f8bcd2c7adb4c04c8242beacb5110` (120 字节)
- `e0cd235450f48a52c4cd0e4882c1440f3a73f6` (4395 字节)

### 35

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\35`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `666e923071dc9ccf5a628a794bc7b8dfbba346` (164 字节)
- `b9b1972e2e2fcf1c7c8260c592fa2b84306214` (471 字节)
- `fa46e5ce659db5952511887bf0c5f02667dd0c` (147 字节)

### 36

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\36`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `1137cdcc42e0be23dcd38b21e66acdb53cdac7` (5159 字节)
- `133db2eec3b929f48b3ca8972a9743d77ba1fb` (287 字节)
- `154f668f84e0708eaffc6d9a6afdfef2d0d2eb` (3489 字节)
- `8f920ee1f6d359e5b8b541947bf3b95f058053` (31 字节)
- `af60d4df6c5a141cbba91e892793ab8805edc2` (72 字节)
- `e3a241ce8ccea909bb24fa88779c65543ae908` (272 字节)

### 37

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\37`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `9c2da7db76f686c72c81b338b4f01638085dfe` (471 字节)
- `c6799561ca1f150b4aaa2962d80d2b3810867d` (771 字节)
- `ed3f801055fa9e61bc03c80f09377a2eed7be4` (139 字节)

### 38

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\38`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `4bf26d14540090a1e3443af5a913f1d4716ce7` (4172 字节)
- `b4ac0ee0064f53033e9a67792e74e3cc41fd83` (2285 字节)
- `d95d6cf522c9c285c66b5bfb2c4de2e6beca3c` (4029 字节)
- `e739694be035dc31fcbea00e9151dab938dbe6` (41 字节)

### 3a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\3a`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `a240af11132d56ac36374f78444ee26eccfccf` (158 字节)
- `e3a30a4f22869824391c1e58e243fd46634115` (240 字节)

### 3b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\3b`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `5d53964d048e4252c392cd91f32e47939036f7` (305 字节)
- `650515794ff99da18013e65f18b189cab3a7b2` (3512 字节)
- `facec4cdc6aa3d685926fb690b808119875ea9` (4801 字节)

### 3c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\3c`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `06c5174bc2c93bdaaa4dcdff8d11562609e83c` (2955 字节)
- `0a5604d53d956aff6e96e41898a3d58f7b7fb4` (563 字节)

### 3d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\3d`
- **文件数**: 7
- **文件数**: 7

#### 文件列表

- `2231c40d2fa5ef9dda73f963ad2bcbcc54a070` (162 字节)
- `6723d2b3d750e83d354202fa68bae041dbf03f` (644 字节)
- `83c36f43041c59a7f66e1846ce6bcd2dc8634e` (284 字节)
- `89592c747f73aa4afe1f8cba590fdaacfae91f` (2878 字节)
- `d05327a116e1720487b05831a6403f9202b36a` (4518 字节)
- `d62afd8e96960dbf664d906644241903d57c1b` (4475 字节)
- `e3c87ae99c51991e9486085d92a2f24225519c` (817 字节)

### 3e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\3e`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `0d7422a35d52a0e74f54b3148be7c2c26089a0` (3300 字节)
- `2a5171bcce4ae9c93903cb19fceae954cd3c56` (85 字节)
- `7fe4bd4875ddd055d32a31fc055d7e4442a98a` (97 字节)
- `a416f5aad9cb331568986a2601feb947089c39` (979 字节)

### 3f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\3f`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `6b74d64142423d85a0e1b865a7bacd56fa868b` (3600 字节)

### 41

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\41`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `4de67b0cc973115ea17d8cafc5f6bbb2dd3c0f` (3408 字节)
- `d8d6830fc286c6f208b9222b86bdad250aadf1` (176 字节)

### 42

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\42`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `67d7b28a5a3739cdd638ba3b87ce6c0c267b29` (158 字节)
- `8131e83e42123f041d6c5d4f8f8bd9216bd775` (294 字节)
- `866dfb081f9cb6e4e4d378b78ed1f918392703` (158 字节)

### 43

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\43`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `08a0dbca34bccb2b817aa12af9029cf9b3a110` (2683 字节)
- `3b18cec8ef711204315d98da686a553bbd2f2e` (434 字节)
- `44555526266decbeef73a6aa5fc41dacf136f9` (158 字节)
- `99420d446d0014d355632199a7ab170aad3342` (3161 字节)
- `a1aa401152ec99cca3ecd5868c3993d04e8435` (4017 字节)
- `b9165adfe497227876e17054642370d714c16c` (2132 字节)

### 44

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\44`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `5e88859307a03f2bc2c2a65d4d80be86c1b19f` (381 字节)
- `b1274d7a47cc376f6b126abff8d41b170fac04` (245 字节)
- `ff0e81c10a5e0de239035bc98ef24e63a1ea9b` (171 字节)

### 45

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\45`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `0e668afd78770bb0f9370915abd6b945c9d250` (762 字节)
- `e23710f6ea44d7bf449c4c4fc0d1c78c10c636` (140 字节)

### 46

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\46`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `059d4e5b89cc402b5762dfff4ea01a48759c3c` (241 字节)
- `2ec9a5e3efb2258c6e40baa7b3a03d4dfb81fa` (286 字节)
- `4ded06f51e977da2f75631872d336fb23978ef` (450 字节)
- `5f093d07c77430b6c83371f42af7b392c531bf` (415 字节)
- `8e743f271cc7110670dd04bb898600f8f58273` (3863 字节)
- `a61619127c5359a7eb4425d2643394eb6367ad` (86 字节)

### 47

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\47`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `15c61644780497e0bb503d54aeb06fb47cf72d` (88 字节)
- `61a591114a108dca7eebc1dae4f7f922d1d8ad` (483 字节)
- `e9669202f8290a2b9af9f4fc0a41231425b544` (4186 字节)

### 48

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\48`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `1cab20fadbdd97da025256168ea39d703a4e16` (875 字节)
- `696da4c80e7dff4804387878c8ce6d37afdbe8` (139 字节)
- `7d6660c8b2e86409d3aeaa39a091092fde93c4` (3946 字节)

### 49

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\49`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `11eceb8e941e2dac62c166aebbd003fd6e8341` (210 字节)
- `5f3200cba84e4cfee9f6d3ad7322939b6e21f4` (343 字节)
- `696c922dd39a92260231457dbb641ffd7ffe4d` (482 字节)
- `d7e015af0cd1ee1184d82d0e86b1f64e1c4407` (148 字节)

### 4a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\4a`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `3cdd26c122e0061339a20e5f5120357fab9ca0` (4477 字节)
- `c475e9817281841304030d9f08766130961d85` (3309 字节)

### 4b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\4b`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `2144cb7ee9f4c4b55425db2668f794a6a2221c` (81 字节)
- `26a5f06ffc8da9c89d47c001f309e742a10af5` (73 字节)
- `2774e44e3896f54e5e3233ab19ae92a36db534` (2588181 字节)
- `8b28d6023615f518640bd169e0dacdcea23c3a` (1942 字节)
- `a11fd20ab0ef0c162d75274167a903a5d7e110` (213 字节)
- `df803a2db51eec54b1506ceea3ca87bf1387a7` (1518 字节)

### 4c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\4c`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `04c91d98eea71f6a4e80ee29760c32e164a0db` (69 字节)
- `08eaa6b6678ebc61e696fe29bf138a1eaa9fb5` (82 字节)
- `0c678c58882df93bb733bf9a69d1b0192ff9f5` (458 字节)
- `cc385c4c1a8c0a6ebeaaee5368488677104a8f` (5002 字节)

### 4d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\4d`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `4c486f871dd55759abaf94866e9f23a419ec8d` (158 字节)

### 4e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\4e`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `2d87baab8f6c1828de29769e34c8e8bd7f2aef` (10384 字节)

### 4f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\4f`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `aa8093d614eed929d0a02559fcead64692a3af` (841 字节)
- `b96a3ca9e59d31921a6e7c78b74187dceed76f` (37 字节)
- `e4fec34293d77933e1c1b305930396b2f4f300` (1579 字节)

### 50

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\50`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `04ca6383f544069c7d2608ffb49efb8b549c10` (4225 字节)
- `c0606b9bc909849c5cf5a8102d9a88971c0ce8` (2612 字节)
- `d257556051e32d524c4a705adf6a94b4c0706d` (5071 字节)
- `d2741b6ce688b010f5ae563fb223f0dce07bbc` (4302 字节)
- `f2d30c4e5d7d19aee29ed932ca3dd540fad40a` (1262 字节)

### 51

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\51`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `aa1ca588bb0712498f5a77043b4d0e69873916` (230 字节)
- `c2d86a70d8522bada01c09cd98140aab3a5465` (1060 字节)

### 52

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\52`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `2d25c1ef5485903db1e11370d20ead6f3745e2` (284 字节)
- `c68718143557b07072075650f325ded87c7353` (398 字节)
- `da7491848a18a0a61b0bd03a938206b47d78a3` (5276 字节)

### 53

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\53`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `03a7ba155b4a554357cab1e2e27494393c6558` (3475 字节)
- `f25dd3cb577f2f7d27005fa3c7e8f990ee1936` (2980 字节)

### 54

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\54`
- **文件数**: 12
- **文件数**: 12

#### 文件列表

- `03bde3ddc17c7460615309030bf72170c8c418` (362 字节)
- `25266e07b9a15e2c47fde22936d2af44dd8cae` (3053 字节)
- `2c0c0670ee436ad4d250126bfba281a5501ad1` (4249 字节)
- `3b11eee220537a17fe4bf2603e0e03761d5b67` (611 字节)
- `5acb7037b7173e2fa56ab88260ef7afb3b764b` (445 字节)
- `633f7765c458910bfc49803627ef8184d3b49e` (157 字节)
- `6574952a297bc06c98abd06d881c409b04a461` (4080 字节)
- `72be9bed0ae017444d83933dabce1d03b2e7d3` (53 字节)
- `7c0c9fd55d459366f3bb7618eb0697dc3b7c29` (82 字节)
- `940a7fea1e9878638337a3d5e19612624736c3` (84 字节)
- `9657c5adf692a0bca962e526dae5dde5b4cf38` (5033 字节)
- `dad5cde9c18db2139c130e72e1f37f17412d81` (1345 字节)

### 55

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\55`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `02b4fdef0c7a9131b53945e631183b05d870f6` (1336 字节)
- `4c618d83d91d875cb0fd73e4804fb9791f9c6b` (159 字节)
- `c6b509df0db0bb20fdc8781a1c0455208ac8b0` (4563 字节)

### 56

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\56`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `f8f29b9173df28c43c12b2a2424bd5857219d1` (3653 字节)

### 57

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\57`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `68c9e5d9b6ee82c3623201b4792f360210c03e` (2771 字节)

### 58

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\58`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `056ca7c698f16eeebe5f2d098f7bb2e92b45b4` (57 字节)
- `2491ea72206f27568b354f9517575726b976aa` (4258 字节)
- `6f471b6083b1165fa695306dc5a36356fea2d7` (239 字节)
- `88fec2d832ec9ba61edb0174a78c62f9d0e04a` (241 字节)
- `a9813e9c2c8f6b226367bbd422b121fd4365ae` (2969 字节)

### 59

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\59`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `e85c6ee88c9d1d8f4e86f7a7b73481981972f5` (586 字节)
- `e93da4863eb50ed5101cb4a2dc2a41b4ab968f` (434 字节)

### 5a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\5a`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `4ecd29427280c629128fa3d978aaccd7361438` (2291 字节)
- `7e50306a84c8c05f61a622f05b6e3f4177090f` (2931 字节)

### 5b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\5b`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `037dc948b73f517a754e5a2801b65e29c0ec16` (913 字节)
- `31dd4aaa9160c1e6fd2c9be45d981c69b706e5` (327 字节)
- `788aa019b27bacc4911c57216728533419b711` (3550 字节)

### 5c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\5c`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `5f5c43c4e517ead2e6473335df76e4a449e28c` (3458 字节)
- `755e693156e81cb90872a4d5d69cfa5c60cc17` (187 字节)
- `c640f738f11a030b384a31a993e1e6659cafa6` (7306 字节)
- `e1ab375f39998d85767611f7b10234c35742d0` (712 字节)

### 5d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\5d`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `6c6729ad95a7ea44dd8145f000d52ed2c09b00` (4205 字节)
- `9bd757c6d9813d5d041ad8662999b2405475e4` (4580 字节)
- `b27e63068759b2df4afb1272fa5313791d38c2` (170 字节)
- `b940808423d258c4c174caf00e8c24b8b1980e` (990 字节)
- `e8281219cda5a5936ae9b788ed37f0ede6b957` (3520 字节)

### 5e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\5e`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `0575ac19784bf42ee07d6ac14ad092cc6d63b1` (371 字节)
- `275a1b6a3d6acc17e5a0f88e91ad5138b169bb` (154 字节)
- `4cb00d3ee0ddaea9799ca77c915f1da3cb1f23` (3505 字节)
- `734fd7ff3ad3646886fa58d9873e839a7771bc` (1745 字节)
- `d5c23ecc579b503346264c2fdff3a915e22fcd` (705 字节)
- `edeb59cca4b788696cd4e7ef88f304842bb93f` (57 字节)

### 5f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\5f`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `97b2a471dabe1d91f9408768fc414f924fb5e3` (4078 字节)
- `e4a43adc3e3cb0914a93e30acf8334089618c6` (473 字节)

### 60

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\60`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `eae8f51203ecf1652aa58fd24ab84f017405a4` (97 字节)

### 62

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\62`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `084c010b8b723b90d3e64aa3b09c79618b6a71` (3196 字节)
- `708f10bc0855f619225bc5f9d79dca190084cf` (4622 字节)
- `71b2a41f9a178f2dcfbd234b8ab5298027a4ab` (286 字节)
- `af64ead079b66e56efebc59f1fac6f65fb54e6` (73 字节)

### 64

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\64`
- **文件数**: 7
- **文件数**: 7

#### 文件列表

- `083a9cab1f72e0ea944e0a4a15fec36a29f48a` (1594 字节)
- `19014d3333baa0a0c56d82ea045c2373cff86e` (164 字节)
- `635fc72312a41e0420f8522bdd2847d340a78e` (1180 字节)
- `7e6fb1c37cddf874c50f1a0aeb60efd00d9007` (347 字节)
- `a6ce3313da11daee1544c94d970d58ecee5fec` (3700 字节)
- `c6982f898f119c4197dd507b85c35a50b86378` (322 字节)
- `fe8863770da2482713aa9ef715f8185625ad6c` (382 字节)

### 65

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\65`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `1801236b06db6af1814298278b02084d2d58cb` (150 字节)
- `7256f7db743561c768620d29b922e0cdcb5c3e` (441 字节)
- `cc186a0c0f40ff31adff9540d84b5946c8590b` (2993 字节)

### 66

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\66`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `45598fa51df949adfe6665c7c91a577b32f2bc` (2089 字节)
- `643917ab331d11027c97f0bd5616c6d502b8c5` (3446 字节)
- `b94a714b495f93b18814d71aabc869d0e28994` (407 字节)
- `d258ddd4ea2b3cfac705d26d19446b65ba4f9a` (964 字节)
- `e3041169a4bd6daea7d7f26b26aa7ee47b1b93` (159 字节)

### 68

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\68`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `27e1d8267dd793f0c00b2eea14fe656f40b52e` (2113 字节)
- `dee5b33ca1d800782785023541559860f29685` (831 字节)

### 69

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\69`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `33bcb0d963ec158e7ad507197499883d1fd804` (434 字节)
- `3e1e41796cad19b291eae288e2a0dcb4a7c493` (480 字节)
- `5762c93460ce448135b4e0adc721254a8df63c` (3944 字节)
- `c675462c57f533484318cdf9b94bba4926477d` (2021 字节)

### 6a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\6a`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `272eb84b6c92edee99a26c4ae756e7c477fafc` (309 字节)
- `4de9537d579b77b0b0e5a673e219e2c599cb45` (128 字节)

### 6b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\6b`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `94fd2e379129d32410721b31d670e747c6e958` (5411 字节)

### 6c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\6c`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `0ad7beb208d6fac03aa1a29751acbd8ea8291d` (165 字节)
- `f2ff1aa18baa98b7e75af6e863ffb758a83c13` (5633 字节)

### 6d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\6d`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `54d02ba91ee3fdf9831b9ed992bcbffed7dd28` (118 字节)

### 6e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\6e`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `5a6036b1162a92d08dab21e648f0a760119ce0` (871 字节)
- `bb311fb7f3e238c8bbd199a92459e16373b9f5` (1300 字节)
- `e51fd192eb60b3c7dfef4897ca9692929a7da2` (53 字节)

### 6f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\6f`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `3bd4b6432bdae36682948e6933e08f598edc83` (39 字节)
- `5a92366fa76d74a4d46a3563b66cbf1a4d306b` (3543 字节)
- `c6b6b01f1bfa1ca9c43b233f19cb3080c0fd54` (45 字节)

### 70

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\70`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `c66ff235b62183addc351a063e65fb6caa31a3` (83 字节)
- `d910899ddf93aee4adcc764f067a0469740bea` (4666 字节)

### 71

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\71`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `13b7a6a6e87f97464a62cc32ad6a5a2a74899d` (3663 字节)
- `67e7a2000c7f9a84ba91a6a959f310d7fa5565` (72 字节)
- `84e2f31b0aa609df201b0d7ba576b0885c69cf` (204 字节)
- `8813b336ca7be8f44e25ce5dea725c1ff6d3a8` (2739 字节)
- `8e4229fb849ef97f4e70fd868918b0479e92b1` (1963 字节)
- `dd18aaf6dc119ae267c162ab52be19ecd8aaa9` (1632 字节)

### 72

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\72`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `53971ec0a9c3ef60365749ce0c9d75a801a5e7` (1828 字节)

### 73

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\73`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `602fa80363cb64f489e20f3ec01ed11b1482ed` (830 字节)
- `ec6d2c1003b87883bd61f05f87d97e1069d73c` (5530 字节)

### 74

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\74`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `25fd9f80e3357f0971d19b8ca695aac0f42e5e` (80 字节)
- `4a0b733c4c416bfafb7b3bc24768a061165cdc` (1993 字节)
- `7871c0876c69f336a652eb3724f0bbb6bbe32a` (96 字节)

### 75

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\75`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `6e55b7b076c584242ea5530261b3fb89fd5911` (3404 字节)
- `d5b05723432a74734680ca2839df9eaa1cd2c6` (5028 字节)
- `e99b306aa0306e2d03aac19fbbe102eb20112e` (4318 字节)

### 76

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\76`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `239607eeb623c3668eec3facfb4c72dd4f5db2` (281 字节)
- `b7f8ac2b4691cd0178e0582ada3cd918ce0e79` (97 字节)
- `cc229338e6656a97a7c16fe2136eb468195805` (497 字节)

### 78

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\78`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `24bda3ba6e9b2bb718d3750d9880b377625566` (304115 字节)

### 79

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\79`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `53954a28a56a559f745e2046f8bdf84fd38a28` (2310 字节)
- `9602163111a67d8447df01007642c66c311da6` (875 字节)
- `d0ac6596b3b0bc0c96d6a90824c52206417e8f` (795 字节)
- `ec6d1b964e3b4f972879bcfa704cba0bf02930` (2066 字节)

### 7a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\7a`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `62a71e85b97c02f9d03ed65f0d672438c23efb` (2360 字节)
- `790bbc2fb053cc9060a1ed25a8ef5ca41e15eb` (5970 字节)
- `c9da4d65a6c30541372d6bace7ce82cef53e03` (3300 字节)

### 7b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\7b`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `b63d2614fe8bb1ecd67c3c32de5dab84189c00` (3274 字节)

### 7c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\7c`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `022d87b0b103b8cb634890c0bb3bab177e7b7c` (394 字节)
- `8f10f2a784c601eb804119fd2fadd9d8851da0` (243 字节)

### 7d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\7d`
- **文件数**: 8
- **文件数**: 8

#### 文件列表

- `174015b5b980e6f5e49b2bd778a247cf591798` (843 字节)
- `40ad26113edb1640d3507dd325e62c18872418` (3141 字节)
- `49f02273a75ba3bdeceff3df5c94531e4f91e3` (4486 字节)
- `4db58bccaff8be675dcdc1cad012f3b729c036` (239 字节)
- `7fcc729d08cace574b82f1ca4614faffdc6e18` (5281 字节)
- `a07f9ce7ff1ed5a564aef2dca427201642058f` (470 字节)
- `bbaf04f68d68e23867dd8975a40de890521233` (84 字节)
- `c21e99c59c87fdc0e5f00a7b5124d4a37d800f` (1305 字节)

### 7e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\7e`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `e4bff626e79ad437871e13bcc35996eed1c1ed` (685 字节)
- `fcebe85c44aeeb8e71aa4d3737018caffc61a8` (3439 字节)

### 7f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\7f`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `8ca502318dffdc047a78cf863b360f24cb5c8b` (5415 字节)

### 80

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\80`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `5c66e3507350b65bdf0e2027fa8059db97fc26` (3587 字节)
- `d71a3811ef46916769318f63bbaa6712ebde74` (3583 字节)

### 81

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\81`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `2220a819209c243d44cd53d88b5a54cbc0991d` (586 字节)
- `7f9d2a8a0b54ef9b3a6c9f7939e44048e3c91f` (1087 字节)

### 83

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\83`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `8bb22035fb01e92dcdcfa147895b27c914f4df` (310 字节)

### 84

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\84`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `8e9345010b280d3716014ccea88861ff6c9acc` (7652 字节)
- `c225a0d9c51db5a0e2e056f70b31aaaac486e5` (705 字节)
- `e9a9c42cb86b642f1384b7c07ae9e87fc1f9d4` (1129 字节)

### 85

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\85`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `33e8ffb56c9c9fa4169c246ef50bffcc44eeda` (73 字节)
- `a510c5ed8f175fb297106950acfc6a10f37b5b` (4412 字节)

### 86

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\86`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `c397deb968146a0e4daf15aecb0b508d479c02` (232 字节)

### 87

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\87`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `25f9660c87f2480fcd8ac77092a25906861c0a` (3038 字节)
- `99b19239931e0e4412e2a791afcf60ece8a10f` (213 字节)

### 88

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\88`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `84615f39b8b177f17e1748b1d2d7994f338c81` (153 字节)
- `965955c3b7e0c17fc6279b416e974e83beeb6d` (104 字节)

### 89

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\89`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `1bc48616688c0c25ddfcb7a8d6d16f41fa926e` (714 字节)
- `3a6795fcce1ed4cacf0ff57d4dbc4f69c3f333` (1037 字节)
- `769013c371fc8bf7966a55d99ec3c71e7bceb0` (3493 字节)
- `9b64677cc90c6e68f4c2763385b566a02df304` (5424 字节)
- `ffafa304a9121058f5d581e7c5f5ebb69698d9` (157 字节)

### 8a

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\8a`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `6b97b509bf89414a35351b9dbb7a2ff461a341` (4179 字节)
- `72f34f8308f0da3ff88846e38488ba6f9cb676` (55 字节)

### 8b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\8b`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `36c7687f8feb4cf0afb41000675ac07c15686f` (672 字节)
- `c0460b8a011637483a9d6771203eb8539067af` (3828 字节)
- `cf772220543815327f3893284ca5d6c8bc31d7` (161 字节)
- `f0628f184728b7e76b7f762978c300e51b191a` (5097 字节)
- `fb6e24f39c5acb57f4e1ada8c3b619c1686b09` (241 字节)

### 8c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\8c`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `7393a40c632f28673561f39b924140de96f8dc` (3495 字节)
- `d046f6923bb6cca91fec71176b7f5dc47434c8` (257 字节)
- `eea47091e07ea5b68667ab921f8ba324d5d6e7` (1176 字节)

### 8d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\8d`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `18701f1e9a0e93b25f34dcc7f9ad011ae479b1` (39 字节)
- `49d38cd405d6b2426df2fdd78f284ce873e6ab` (4500 字节)
- `69801872775a84dc4da2a174d412b67d6d615b` (5522 字节)
- `c49677508cd97ae18eae67d8727957dc13892a` (672 字节)

### 8e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\8e`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `38cd3d0947b0bba3f7f8fa738d052c52e755b1` (2370 字节)

### 8f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\8f`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `4da7e3dc7f793b02489d1113e1fa94f17c6364` (4204 字节)
- `500bac7658138b50746017c161c6ad84fde2de` (4304 字节)
- `6dea02e5140f4c14d374d3b880b89d877ac455` (158 字节)
- `80253b6ac4fb5235bcbef5c57c3a4760ccb771` (118 字节)
- `c55bcba88eb74c169adf6df4a2f76e48c7d5c0` (1454 字节)
- `ffa87caef67dca03596b59c0c8e0282b0fad0a` (3250 字节)

### 90

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\90`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `23acb88e248ca5a10dfe2c0dd9692627f5a34a` (1322 字节)

### 91

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\91`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `05fd2a60eb2c2d98cec6d26691f5f4d33c0251` (610 字节)
- `2a88fd0a32995329d880ee0cfa26eb9047cc4f` (714 字节)
- `6fc70a2c6d8dbd318779e4be41156846ab2f86` (2829 字节)
- `8b5987647e2bfea366e8fc28ab1f74fbacd5a0` (83 字节)

### 92

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\92`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `4537e20c44040e56bb9def13ef1ac25d45360c` (50 字节)
- `4eee3d5cb01cb7709d19bed0f161716bd2c955` (2238 字节)
- `fb7236f292386690520070c78fd4782083d93c` (2243 字节)

### 93

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\93`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `19608df459b52e84aaebf275d2659056a395d3` (51 字节)
- `833aa1ee5de6160c5bfb80eaba6854b7983059` (246 字节)
- `924d9d376a5b99834bcf9ded4e509d874d06d2` (5837 字节)

### 94

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\94`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `183b50047d8e616af471cb6b57c5de3857a822` (88 字节)
- `60a8978613369d59e55293fe97023e998d0890` (4110 字节)
- `c3325bed68561ad785ae0a558c0df9ed7c310d` (97 字节)
- `e53e785ac1726015b1b10f302b44e23ff08333` (601 字节)
- `f42dd221e1f9631a70de5628032b7a7a058c6b` (4391 字节)

### 95

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\95`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `19bfa971c33743d3473073b9d32150f69eedcc` (3676 字节)
- `54e906ffbf6a93cef4427652a8f7b34d1debe8` (72 字节)

### 96

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\96`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `276fb4264a5e704f7d9f6f2de6fe0c13d71176` (3265 字节)
- `3007c0c83224b224b5e50414d6dda08b54581f` (5696 字节)
- `72b311b3a3106a736ad528952593536b259a02` (3788 字节)
- `7456dcceb5daf1ef719fed74aa8631eec4bf88` (1183 字节)
- `b91c14338b78ec256058bf4d9cdbcd0d5b875c` (33 字节)

### 97

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\97`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `7bd215fd3df3ee45f8324eed63841590504833` (286 字节)
- `b4d694ca0a8e4521ca9d6c3c6a30276eaf75b1` (1094 字节)

### 98

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\98`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `8e2b4e5aed33785e7a16058a362e785c5da760` (3470 字节)
- `de2ddaca83516d572d96f392b1d891e2f5ba3d` (240 字节)

### 99

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\99`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `1c3595ab7db8e1232cf671674ab5a0cf7175c7` (60 字节)
- `20819f1659ecfb0839234172e3b999fd765149` (5950 字节)
- `43c0cd0df67d40e526041195c8b11f1feb0d5f` (2410 字节)
- `859f40b9d6a5b0610a6d7dcbf7d8f21a221302` (5485 字节)
- `e43ce540b8f261a4e845a1a34dee723c44b793` (58 字节)

### 9b

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\9b`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `a995b653e980c63122be947101371ffaf98083` (622903 字节)

### 9c

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\9c`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `0db6452d99a6804c410b0e5e42199d5d390ebf` (551 字节)
- `3e7f36a4dd8c324c72bc06b8647d825c50a045` (3718 字节)
- `f74cd69cd2910cdffc87642aa47ba2be68ab40` (152 字节)

### 9d

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\9d`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `d305ed78004e308f4a3f7001b3926edb7da8ce` (1538 字节)

### 9e

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\9e`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `08e5c809a9c21c2543e577381267e43d6b2a46` (214 字节)
- `3cce577dbbe6f96d1e1d0d223ce99b584b23eb` (733 字节)
- `4985302b1406e9095e4fec6896c112c3f23a13` (1601 字节)

### 9f

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\9f`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `63edbb2c3488bc1d37ae7314743e63ced3ea69` (849 字节)
- `b1137a0e011b6a7c1a00813782e993b56c53c2` (1889 字节)
- `c3919de2d376e694d9d1088e4352ac92cf934a` (166 字节)
- `fae93078346cc2c10c1840938aff8bf5325364` (239 字节)

### a0

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a0`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `8d2e4317c89cc95c17f3f0221ab5bc64d4a887` (158 字节)
- `a466bab0ddf4069c86e7ea4853d6133f4ae067` (57 字节)
- `cfd37bdb76e599ec68f7241367dbd551a24419` (112 字节)

### a1

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a1`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `1254b908347d27c7e9316b616ac5a189c786a3` (3673 字节)
- `613608164c2d747b4e6cfb4a26a4bfbd1dc16f` (72 字节)
- `ef45a52b92e293116fd668907ce04db3154844` (971 字节)

### a2

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a2`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `4ade30738e03cd367ce08e3f69242bab39f729` (274 字节)
- `4cb5cf9b91d5abd395d705f339affcacafc85b` (72 字节)
- `c18d591d022c180de2a3f174d9d5fcae55e07c` (2995 字节)

### a3

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a3`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `99cfc05895bedfd6d42d3a3ee59d0dc741cc62` (470 字节)

### a4

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a4`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `37ea803e997e9df231bdb525034db123771777` (282 字节)
- `9b828f5e54aaf4be259da983d9023265f94703` (1185 字节)

### a5

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a5`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `68574298512336e780d39dc070834fecb9cef4` (72 字节)
- `6b133d8725102aee86465ae7f7ec3441ce05ca` (240 字节)
- `a041bdb902f7d46fa18947120b1f45b1884b6d` (4209 字节)

### a8

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a8`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `a554575e151c433898b3d28f8b307642b28cd6` (652 字节)
- `bb9ffb0f73cdca2b3b9689f39355db1e33fdfa` (51 字节)
- `bd76cc6b18043c47c72c8d6feeba8c4a8428b9` (114 字节)

### a9

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\a9`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `01119b05e4ca3e9d71b3c27f085f4eaef1522b` (3795 字节)
- `32e5ab1c244592cdf3b4835d0446e94d816368` (81 字节)
- `4176dd107d19aa1356cd5ccb60981f49c8646d` (4926675 字节)
- `a7075fcc08d85a1947406ed0f0fe9777e39546` (609 字节)

### aa

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\aa`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `72808a105cbe7b4043d289c478f6184d2bb7c2` (5533 字节)

### ab

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ab`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `13faebaa897b616b19b86494d197b39601aec8` (1717 字节)
- `29a88ebdef6792994d228683777b1006ac7b13` (53 字节)
- `5db73106c7a90a833f643653ace0f0887f92ab` (2121 字节)
- `69c97ab2d25e4967f2de6232421762c4a2be02` (3665 字节)
- `866c959d580fed07d0f7797a9553256a6b8e00` (2318 字节)

### ac

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ac`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `52b39a8ded992e97c18cb70f9ecfb9797643e3` (72 字节)
- `5a0fec64806861821cf78c696b01f72b9d66ab` (140 字节)
- `a5682f5576bfa37f2a36826ca6aaf98bfffb2c` (1646 字节)
- `db31e57b7a217997e7fac62be59dd6bd77efdf` (3514 字节)

### ae

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ae`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `0718672933ce66af43e431ac403dba4c509a3b` (213 字节)
- `9cd1fef76a29e415d2855fede1ebef33f092e0` (469 字节)
- `a2df834ec00b1c2bea369633dd3419d3c106f6` (3618 字节)

### af

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\af`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `1c58e178602a521d0fcbcad832542903beba2a` (76 字节)

### b1

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b1`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `be4c60e6072ef55dcfe578a2c277418682f465` (240 字节)
- `f0c71da7a0d97752e747b22639ed2767e58269` (267 字节)
- `f251b148f6075a65ace1553b2ebde822dfe633` (96 字节)

### b4

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b4`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `8daa989bf2c203abefd44880f096bebcc2c70c` (896 字节)
- `8e90dae97f6129f211ddfad569126e8404c13a` (3173 字节)

### b5

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b5`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `050f57695735753acc85fb1f67355883c7723b` (3634 字节)
- `1bd51ced1730a904190676fcfdd0ea29dfe26c` (1132 字节)
- `94b52a5ae440259d5311e5c969728efea59948` (3022 字节)
- `f4e5bc218fba32bcb63d2e6e6a9a6fb76ea17c` (4139 字节)

### b6

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b6`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `0511b24681ea246c774af921908954d33ce353` (80 字节)
- `646cd2473d9b915ac9a7354ba9d430eb2831fe` (610 字节)
- `a9cbc9170ef639641ef5d0aa3f3dae12497c98` (3332 字节)

### b7

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b7`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `ad79d49ba43e94354c1b67fa13bd626cd59b82` (4046 字节)
- `dac6e463d0d0f4610e75e97af4c9a7e233446b` (81 字节)

### b8

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b8`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `289b92537ec41271e13b7dd78e17452e45ec25` (148 字节)
- `3f6f3d8fa530757a7da1904d936290c1d2447b` (284 字节)
- `a29e7c5b0a047b6b2bec704b8e344ea0434206` (3419 字节)
- `b9b21eeb7e9e6d3cd408cc33c05fe1e5cc9e2a` (1204 字节)
- `d46bd20a4137f15d86f057ffb4be41b86d109b` (5316 字节)
- `f1bd46ba0d195e41214e1966fc1de9bfa5066c` (5430 字节)

### b9

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\b9`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `0bc58da4a4c3e390c8c30c4c77b4533019f238` (97 字节)
- `1a0588c18745f5375ee849cc82c817cfea2377` (409 字节)
- `238eb69a057670a19dd6e4e19561d48f35926b` (5055 字节)
- `26c94edf5fcc6977660ccdd2a11700a1809ad0` (4794 字节)
- `2793b945fbd835c4a5b2707e92e3ed1aaa4ed3` (832 字节)
- `4fa3a264e993a4be3c4fe16a8a2d76ef33ccbc` (3217 字节)

### ba

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ba`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `1dcb890a421fdee71d7e85763dd2da8561a59a` (72 字节)
- `4993f62fa5cb7bdc744f6045947be1643d5a10` (3622 字节)
- `62191fb2416db65ea05beacdbbb1a6ca0e999d` (612 字节)
- `6491f31f5a5f28c5b604bedbebfcbd6df80edf` (139 字节)

### bb

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\bb`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `24be10896d5f21649e37e644b3035d1dce7db6` (96 字节)
- `73ec605dfb53e1c2ae2bd7fcc33f01d57b51a7` (2852 字节)
- `a35b944d3d863a4c6cf3c8ca7f01d347911610` (3464 字节)
- `ffecd4a2f7982d2e22e4ee7bc9fc9010240f07` (672 字节)

### bc

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\bc`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `9ff0e0346562104b08891929338ead1152db6a` (65 字节)

### bd

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\bd`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `8f159cd5ae7f1e94215aa746479a71661d5840` (240 字节)
- `c2b09181c35f0becae477ce33e5cff7ddd9a51` (3895 字节)

### be

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\be`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `4c50a1b682a6895bab0babdfa076c5f0d6b32b` (360 字节)
- `56b090a7c2bf16b059dd68ee4c07e2941d98f6` (566 字节)

### bf

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\bf`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `c0f6cb0d65f9603de0f5fdbd802fc42bf973ae` (4123 字节)

### c0

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c0`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `0b42131de9c05facd312e3c9caa95b905927f1` (1087 字节)

### c1

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c1`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `d4eaa541a9113f59783101918f34b755165116` (238 字节)

### c2

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c2`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `2279726503b1c5a7b611ce7408025c2b5b3efb` (1837 字节)
- `51947c4dc0eb3e118ba84be4366a0c51684580` (3789 字节)
- `e4c03537559def34b15c81ce14feea1c7003ff` (2954 字节)
- `f9d25d465e11f55c1d8f8976fcababf176b564` (2290 字节)

### c3

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c3`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `7add8dcb7da8634b69a40590c223e03cff0d3a` (656 字节)
- `b30abbedc8aacd71cca6fd35e7beb0fb6dea12` (3695 字节)
- `f07536d1e622f028c84137a9a9bc6259cc483c` (858 字节)

### c4

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c4`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `09f5353ee2fd43d8dad44b83f4e7cc891ee659` (99 字节)
- `1e8a68a83526aeff1950ba492009b87c311c12` (271 字节)
- `7666f1df45196553fe76d929723b2f8deb6630` (240 字节)
- `8ceedf7c439743f017b1014a110ab72b776867` (763 字节)

### c5

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c5`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `5dc72145cf60a4f0382c2963810511be466c97` (72 字节)
- `68db46785de534c2984df66c11094adda46a86` (342 字节)
- `c35d02f1da5fdd75d74a811be3cf2448e2e407` (3634 字节)

### c6

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c6`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `084dd5d326a8236af3a9f509ae498e2b772ade` (40 字节)
- `29ed8ea374ce4a1e7f96473179a69937489477` (4384 字节)
- `2e3804029dbd63413a06109c6aa5b9ec91f602` (52 字节)
- `5447ff0e9eb37a56683764d7ce980f24d41370` (2975 字节)
- `bf91cfcc4bd3227bf7d31cc9994995314d40f0` (158 字节)

### c7

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c7`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `04353b842031650fa50d24fb82bb541a7553f2` (643 字节)
- `0e2765565a4dd742d9054a67ab9be9e90d5ac8` (1671 字节)
- `240df5c42bbd0e17bd2c2f52457224a643ca1c` (84 字节)
- `2b17254e916e98c5b50fce40e2fdd1c35d637d` (3296 字节)

### c8

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c8`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `a67757198213e18345f82534134941fb4f9367` (2418 字节)

### c9

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\c9`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `38bd01c4643c36f0e534419fb3ec92b7c5ef7a` (583 字节)
- `5367bbe15955b4794a2bf36dcf02b898af2558` (5318 字节)
- `fde615565be52a52e33f84e2e5f0fd8a781a9d` (4802 字节)

### ca

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ca`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `1be9b59185c448a1f80ffefc5dc40248e75329` (72 字节)
- `ad2f2cc740c457f01cfe70f188e7eabc88ade0` (80 字节)

### cb

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\cb`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `55c997aec956ac467784b57ed89ba772786905` (52 字节)

### cc

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\cc`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `4d8ae8fc2fc58c2dd77bfbe2f302aa5e69c401` (213 字节)
- `844dff5a3fda4afe9781c3179aa1e6554a5189` (158 字节)
- `9f5b24611193371646018a5c0634fb798c5f83` (1630 字节)
- `b155d2adf1cbac42f8138273b8694de60ae565` (4042 字节)
- `e2a5c7157f3a1f86717559a033cc96d99fa94b` (3853 字节)

### cd

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\cd`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `407f2cb10ce3e6e1c4e1c73e515a177e22f176` (53 字节)

### ce

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ce`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `4a01ce6d7419705d16c153a234fc95844c00ea` (155 字节)

### cf

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\cf`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `a1ac77573c38888fd0963e962e2198205c92e4` (1824 字节)

### d0

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d0`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `66146c191ffe5bdd1b67650198263ce3367a97` (147 字节)
- `73d4fc25d549c5f18d064c67330e62446cb698` (45 字节)
- `cbbef8d2f4de806e6f808611a5eb9e59361762` (114 字节)

### d1

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d1`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `46335095b367ff9d7bd7bd66faf397f16addca` (3092 字节)
- `56ed09096e34746e126953cb1a78748d96d509` (1374 字节)
- `70b16810bd80000b65049e3874e76d4645b78a` (50 字节)
- `c1c5670d1fdf41bfa16a565b6b2a13b7b92224` (802 字节)

### d2

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d2`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `3714fcb009cfc8670bb352293b63954456da15` (3105 字节)
- `49c0f28b0abda42f03ce1e0831a698c1fab479` (826 字节)
- `5189141e5449ea40df132882dc712dabdfe6a6` (4190 字节)
- `7d10db533e15b0769604e48b6ba2d70320427b` (43 字节)
- `a214a789ae30df471940b41aa2364c6dfe86c3` (208 字节)
- `fcea9d3257d6ae542892cbfd191ee1789fcbf2` (805 字节)

### d3

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d3`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `53b3c0706215b1e7b4f2c478d45e97663806bc` (150 字节)
- `bc8f6e1ffc55acb3166096ee3b8f368a8e818f` (46 字节)

### d4

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d4`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `1e05ab8e1448470df7b150c52b585372e812f3` (160 字节)
- `57d06425b4184b8e8b83986a9307a250ee67cc` (52 字节)
- `f55cad7e701eaadad8480ea5f80ce01c07ab9d` (375 字节)

### d5

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d5`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `1180382f8af765e652d844ccec6fb927e0cb8f` (9377 字节)
- `8aaefb36d87035b483c2cc8924fb47fa553bf5` (3948 字节)

### d6

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d6`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `83de77b963a4a514e5119942e88ec5afae1624` (4281 字节)
- `fd6e6c18bee6d48e9a5f14a8f496b99ffd3bc6` (139 字节)

### d7

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d7`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `4224562709772e2ce9d9dee5097436344167ce` (1103 字节)
- `5506c92017ce53e8e0e75c09ec765a33a2b43f` (139 字节)
- `c5db852c42f3cf7fbec00621ee1fde057b6c8c` (350 字节)

### d8

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d8`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `75de1eb39d85b567c7f22289fab846ee511c8a` (4459 字节)
- `c09089837e7b4a4a07ac82cd21105e6fea2986` (2144 字节)

### d9

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\d9`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `0024106143114008cf3ebe6b33597f66c32c88` (1376 字节)
- `dcd3e459668471051cd214ec49ca4206dfc78b` (1774 字节)
- `e8b4e17a4fc1bfeea0baed1a876f653db1d365` (86 字节)

### da

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\da`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `5fab2b2ad63b28c2e6bb02e6d4a1e66bf1478f` (5009 字节)

### db

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\db`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `5ecb783d668f9a50efb732d6e8d91e25d7d952` (2228 字节)
- `6d6ca5e68af08490ee656bb41a41628ced8e14` (39 字节)
- `820e9971e3a7bfc6effb295207c40613ab1151` (5393 字节)
- `f1bc06e35cb9500a39d0cc1e129187d48dae30` (84 字节)

### dc

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\dc`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `23bc85cf665c239b79750cedf20bd54bee2be1` (3566 字节)
- `4dfec49ee2394b36f096a350d91b6a1894e1a6` (4328 字节)

### dd

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\dd`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `22d21de4dbcff05d44030150b90b6fda3dba6c` (2939 字节)
- `338244db41cb74866b2298f470067295f1ea31` (434 字节)
- `3e8da46fd28deedaafeac12e219786aa3c57c1` (96 字节)
- `f89b9914f2d588c8345e6e640ef7f03ecb68ed` (72 字节)

### de

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\de`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `c97f8d7cbd6f5fe09824abbe37b6fea4b65cb7` (4254 字节)
- `cd211e8728494a985f028c3468eaac06fea030` (664 字节)

### df

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\df`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `e1dc109cbcf2d7c5a9e939339504451ae447c2` (1509 字节)

### e0

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e0`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `04c39c4545c3507ce9a5b9c385f32deef12f8e` (53 字节)
- `5fbe23e25fe8cf5dcfb4737e45492bb9120591` (147 字节)
- `6865b9e2b670f89965e6743fea7a84afa84a1e` (3272 字节)
- `dac319ff3a38b47d35b4880b0a4827df9d0f4a` (423 字节)

### e1

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e1`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `a376bfaf7d12403132df64fff697cd0cc59871` (2969 字节)
- `a3fe0e3d51f30e0f31bc1c44276c58dec1e8fa` (36 字节)
- `ecd810eaf462998dd60d1daeb80c42b3799f12` (4249 字节)

### e2

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e2`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `1af778894f66e63ba940c463436acbd5adb7be` (5632 字节)
- `5001935f0d3849cae7135da2d09a8c58da34f7` (240 字节)

### e3

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e3`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `0ba0988e262136ce325f757dc7ca87641a88d0` (1626 字节)
- `1f13789b6da58848468da862cdc1d3f7f88086` (53 字节)

### e4

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e4`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `0bd20873bfa148542ad8434be1b3dc7c192e15` (3738 字节)
- `2914b5d7bf8b68adcfce969598e054d812d6c2` (941 字节)
- `7de509d90f018f28be9ee30ba6e5ac6b74f3d9` (3227 字节)
- `d0967c70e82033c43d3412597f876402eb3d88` (3885 字节)
- `d82e077f2dc6f3d97379ffb0f882fc1c897127` (333 字节)

### e5

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e5`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `39450603396b651be364fa7de2a3bc9415c7ba` (3410 字节)
- `7923acc1e4fceefd48f5c73b87bb8af9c32539` (663 字节)

### e6

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e6`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `9de29bb2d1d6434b8b29ae775ad8c2e48c5391` (15 字节)
- `d5e34b438cb1e8fc4013eb7a56f9f6b51cc549` (97 字节)

### e7

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e7`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `654365d20039e5a2f63702401282e2d474390e` (662 字节)
- `6581996807cf1c183be99bdf9f1f114e057378` (1326 字节)
- `6c74c704c61459519b73f878585c701383cbeb` (2449 字节)
- `deb0e6a0e8e1afefb033d5bbe71cfd5c3059c6` (699 字节)

### e8

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e8`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `373d5f6d69b80159260848a8ffefb1320b2690` (1413 字节)

### e9

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\e9`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `3df19965d9bed1f68b65941a41b3a57f57cf8f` (194 字节)
- `b25e193ab6483c1bfff09a11dfbc849da86aca` (1308 字节)

### ea

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ea`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `726939d54763a0a42fcaa0647b21c70287917c` (5364 字节)

### eb

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\eb`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `228a4c7ede7475138cbe1b2f92564b1ca6054b` (278 字节)
- `f64609c078e02ed273e8172952012ac7407958` (3356 字节)

### ec

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ec`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `07184edc0d7d21f94d097d05bc41a5545b92c0` (311 字节)
- `33be5105c211897462bd80f50ce44fa12028ad` (2959 字节)
- `b8b7fcbc45e94cffa58c291744aa2ab6a517cd` (6158 字节)
- `c2b9825081f7bd17ef331b41bb64a92b5c8630` (840 字节)
- `fa92d413ddc4972218a79bcad5c310931fcb45` (396 字节)

### ed

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ed`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `c7d0442e19f1a629c050f52454dbddc4f16185` (84 字节)
- `f5aeac1b2decba0024267626ad1c19e8bd68e5` (80 字节)

### ee

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ee`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `bd0150cbc58d1b1845ec2d9da2c63628d90cb8` (2470 字节)
- `c6f47778bd4e1bdef950fdb289da030710a056` (734 字节)
- `ee3a9390b88692f89b33ced28a1824f1498064` (2664 字节)

### ef

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ef`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `0b178f4c6f27257de9f5c862b60c00bee941b3` (3244 字节)
- `4d44f8b5883237bdd14118fdd2261451669c50` (64 字节)
- `526e5f14090a623163b33fa6898d23d66ecf14` (4358 字节)
- `e24b80b8c70740c39e6742e9d8e691602ccdcc` (4369 字节)

### f0

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f0`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `175ab735e5941dbfef636c9e2173c90ed035d0` (3385 字节)
- `39f1bb6aaece9aaf7291a589bcb22af3dcb6b2` (223 字节)
- `5500b656b16fdc23c126cd28c2bcd19af45129` (2644 字节)
- `60b623319042827e864156b829927ed251a04f` (4244 字节)
- `76f6b75267c0a0c1853f2f8b1212e0a7788514` (1496 字节)

### f1

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f1`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `098596d92c2917e475d3eb8d6c2dd509f5a99f` (6401 字节)
- `1c5a9e5fee4ea86d227250575441a07f9516bd` (3435 字节)
- `7649eae429981f2f78f0efbc84f3b518837b38` (1608 字节)
- `8493522d4300fb34c4bcea780bdabceef92d3b` (586 字节)
- `c12cc9068a3bf8ecee696b95c2aeae95753895` (1571 字节)

### f2

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f2`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `759d0d4a57abfa6570484b2391d1eb1b4d126f` (3045 字节)
- `a5f4fc83b44895a917fab387a1505271f60bce` (4925 字节)
- `d8ad9a1a2687754df945ff97bcfca8265d14be` (2385 字节)

### f3

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f3`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `1895c5c1e848977841ee0daf2ca5ab2287b458` (267 字节)
- `c0d5d944b1be5630d4634bba9338c7f8aeb279` (672 字节)
- `f96cc462c1d3e916f655b826c5bb1d784db90e` (241 字节)

### f5

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f5`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `8917efbbea4be2297a4b506f8c480bea3d712c` (3732 字节)
- `bc9dd06d35af97e76be091d0873a7f8253d4d7` (97 字节)

### f6

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f6`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `5ca9067138e1e770936ae558f2c19eb9152b90` (50 字节)
- `7bc5017a1fc9beae8a34b2f896cfcaa8dfeb49` (4192 字节)
- `a453852576adf27414b36430b56128000011c5` (85 字节)

### f7

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f7`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `15c05d21ca41476869645f609a397ec29ae46f` (148 字节)

### f8

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f8`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `9b9b563f788f93eac9e54356584c9d8e902669` (636 字节)
- `a4729b2b43896d72c6528d6c86159a1eb9b836` (4207 字节)
- `df81c78d27010578fa28edbdd49874ea908e67` (1565 字节)

### f9

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\f9`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `0dc71b60ab9e96c7d26008504420c9291c3c8b` (2836 字节)
- `71c8b1618805ddb38037f48c0dc559394ff0d4` (6613 字节)
- `a3cc2086d3544cf530bd9d87febb23ef16529d` (3278 字节)

### fa

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\fa`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `0d0d37d144408bed99401646278582c3fcb5b7` (1367 字节)
- `379b8c2c6bcd607797015eefdbd2a867e45439` (1972 字节)
- `37b440554314db1ca595d8554159181dcaa4e6` (4165 字节)
- `4634b1d6a4c54538cdee38805ff683a86ea856` (2423 字节)
- `57be8902136de8423ba46dfba29267a833d068` (55 字节)
- `c4e68355a0a14f4763f8453a975fc517647206` (246 字节)

### fb

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\fb`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `8602c320119a52f6f36c4870953fc9228c7d40` (155 字节)
- `96cacf19a73e59720919da99ea78fbf0287c17` (3608 字节)

### fc

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\fc`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `346185f39eade554f0779a207bad6cdd0dd6d2` (365 字节)
- `41673f6d98214eee4611b3463ee7f27ce95305` (322 字节)
- `43248ebc49fadbe39b949f7450e6013ec828c3` (1663 字节)
- `481dba4f55dab56260bc31a83f8ec0be2df2c2` (445 字节)
- `ec5e9fb42943176fedc6b327abf5e77ff65ca7` (3189 字节)

### fd

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\fd`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `57cd09bde1038528d3401dac4611ac063a120b` (5026 字节)
- `bfd28bea525eb425cce6dc77c745c1b5e4e5d4` (349 字节)

### fe

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\fe`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `04b6f44d6a67405484c3c4e96f9bbdc7640fe9` (1432 字节)
- `84fed632915417bbb67b53798602bc737448a5` (86 字节)
- `a6d2f6fa35cad0fa3c3c8c4f100f64fa5fc982` (829 字节)

### ff

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\ff`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `9f2d4dc19865d31c7c5e1b85a789547b1936ad` (3480 字节)
- `b585649cd1513bbb23ae2ec06170e887230da3` (88 字节)

### info

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\info`
- **文件数**: 0
- **文件数**: 0

### pack

- **路径**: `D:\ide\tool\code-context-generator\.git\objects\pack`
- **文件数**: 0
- **文件数**: 0

### refs

- **路径**: `D:\ide\tool\code-context-generator\.git\refs`
- **文件数**: 0
- **文件数**: 0

### heads

- **路径**: `D:\ide\tool\code-context-generator\.git\refs\heads`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `main` (41 字节)

### remotes

- **路径**: `D:\ide\tool\code-context-generator\.git\refs\remotes`
- **文件数**: 0
- **文件数**: 0

### tags

- **路径**: `D:\ide\tool\code-context-generator\.git\refs\tags`
- **文件数**: 0
- **文件数**: 0

### cli

- **路径**: `D:\ide\tool\code-context-generator\cli`
- **文件数**: 3
- **文件数**: 3

#### 文件列表

- `config.yaml` (2520 字节)
- `main.go` (11019 字节)
- `select-output.json` (1120 字节)

### docs

- **路径**: `D:\ide\tool\code-context-generator\docs`
- **文件数**: 10
- **文件数**: 10

#### 文件列表

- `CICD-ref.md` (3829 字节)
- `DOCUMENTATION_SUMMARY.md` (6030 字节)
- `README.md` (7884 字节)
- `binary-file-handling.md` (9025 字节)
- `configuration.md` (5248 字节)
- `deployment.md` (8738 字节)
- `development.md` (9152 字节)
- `quickstart.md` (1897 字节)
- `usage.md` (4210 字节)
- `说明.txt` (145 字节)

### plan

- **路径**: `D:\ide\tool\code-context-generator\docs\plan`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `README.md` (4801 字节)
- `dual-entry-points-analysis.md` (7567 字节)
- `improvement-implementation-plan.md` (6755 字节)
- `usage-guidelines.md` (6699 字节)

### prompt

- **路径**: `D:\ide\tool\code-context-generator\docs\prompt`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `temp` (1620 字节)
- `输出格式配置.txt` (472 字节)

### examples

- **路径**: `D:\ide\tool\code-context-generator\examples`
- **文件数**: 5
- **文件数**: 5

#### 文件列表

- `basic-config.toml` (3091 字节)
- `performance-optimized.toml` (2873 字节)
- `project-documentation.toml` (3957 字节)
- `usage-examples.bat` (5011 字节)
- `usage-examples.sh` (4208 字节)

### internal

- **路径**: `D:\ide\tool\code-context-generator\internal`
- **文件数**: 0
- **文件数**: 0

### config

- **路径**: `D:\ide\tool\code-context-generator\internal\config`
- **文件数**: 4
- **文件数**: 4

#### 文件列表

- `config.go` (20009 字节)
- `config.yaml` (2430 字节)
- `config_test.go` (11261 字节)
- `config_test.yaml` (2319 字节)

### env

- **路径**: `D:\ide\tool\code-context-generator\internal\env`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `env.go` (5653 字节)
- `env_test.go` (19221 字节)

### filesystem

- **路径**: `D:\ide\tool\code-context-generator\internal\filesystem`
- **文件数**: 8
- **文件数**: 8

#### 文件列表

- `fileinfo.go` (1763 字节)
- `filesystem.md` (539 字节)
- `filesystem_test.go` (18866 字节)
- `filters.go` (822 字节)
- `utils.go` (2919 字节)
- `walker.go` (8418 字节)
- `walker_debug_test.go` (2015 字节)
- `walker_test.go` (9812 字节)

### formatter

- **路径**: `D:\ide\tool\code-context-generator\internal\formatter`
- **文件数**: 2
- **文件数**: 2

#### 文件列表

- `formatter.go` (22731 字节)
- `formatter_test.go` (19414 字节)

### xml

- **路径**: `D:\ide\tool\code-context-generator\internal\formatter\xml`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `xml_formatter.go` (17848 字节)

### utils

- **路径**: `D:\ide\tool\code-context-generator\internal\utils`
- **文件数**: 12
- **文件数**: 12

#### 文件列表

- `color.go` (958 字节)
- `encoding.go` (5835 字节)
- `file.go` (3982 字节)
- `path.go` (1827 字节)
- `regex.go` (867 字节)
- `string.go` (1687 字节)
- `text.go` (975 字节)
- `text_test.go` (1725 字节)
- `time.go` (1128 字节)
- `utils.md` (571 字节)
- `utils_test.go` (20659 字节)
- `validation.go` (1514 字节)

### pkg

- **路径**: `D:\ide\tool\code-context-generator\pkg`
- **文件数**: 0
- **文件数**: 0

### constants

- **路径**: `D:\ide\tool\code-context-generator\pkg\constants`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `constants.go` (2239 字节)

### types

- **路径**: `D:\ide\tool\code-context-generator\pkg\types`
- **文件数**: 1
- **文件数**: 1

#### 文件列表

- `types.go` (10853 字节)

### test_files

- **路径**: `D:\ide\tool\code-context-generator\test_files`
- **文件数**: 6
- **文件数**: 6

#### 文件列表

- `config.json` (38 字节)
- `config.toml` (34 字节)
- `config.xml` (32 字节)
- `data.csv` (26 字节)
- `data.txt` (30 字节)
- `readme.md` (18 字节)

