package formatter

import (
	"fmt"
	"strings"
	"time"

	"code-context-generator/pkg/types"
)

// AISummaryGenerator AI摘要生成器
type AISummaryGenerator struct {
	config *types.Config
}

// AISummary AI摘要信息
type AISummary struct {
	GenerationHeader string
	Purpose          string
	FileFormat       string
	UsageGuidelines  []string
	Notes            []string
	ProjectInfo      ProjectInfo
}

// ProjectInfo 项目信息
type ProjectInfo struct {
	Name        string
	Description string
	FileCount   int
	TotalSize   int64
	Languages   []string
	GeneratedAt time.Time
}

// NewAISummaryGenerator 创建AI摘要生成器
func NewAISummaryGenerator(config *types.Config) *AISummaryGenerator {
	return &AISummaryGenerator{
		config: config,
	}
}

// GenerateSummary 生成AI摘要
func (g *AISummaryGenerator) GenerateSummary(fileCount int, totalSize int64, languages []string) AISummary {
	projectInfo := ProjectInfo{
		Name:        "Project",
		Description: "Code repository analysis",
		FileCount:   fileCount,
		TotalSize:   totalSize,
		Languages:   languages,
		GeneratedAt: time.Now(),
	}

	// 根据模板类型生成不同的摘要
	template := "default"
	if g.config != nil && g.config.Output.AISummary.Template != "" {
		template = g.config.Output.AISummary.Template
	}

	switch template {
	case "minimal":
		return g.generateMinimalSummary(projectInfo)
	case "detailed":
		return g.generateDetailedSummary(projectInfo)
	default:
		return g.generateDefaultSummary(projectInfo)
	}
}

// generateDefaultSummary 生成默认摘要
func (g *AISummaryGenerator) generateDefaultSummary(info ProjectInfo) AISummary {
	return AISummary{
		GenerationHeader: fmt.Sprintf("Generated by code-context-generator v1.0.0 at %s", info.GeneratedAt.Format(time.RFC3339)),
		Purpose:          "This file contains a packed representation of the entire repository for AI analysis and processing.",
		FileFormat:       "XML structure with file contents, metadata, and directory organization",
		UsageGuidelines: []string{
			"This file should be treated as read-only reference material",
			"Use for AI analysis, code review, or documentation generation",
			"Do not modify the contents directly",
			"Consider token limits when processing large repositories",
		},
		Notes: []string{
			fmt.Sprintf("Repository contains %d files across %d languages", info.FileCount, len(info.Languages)),
			fmt.Sprintf("Total size: %.2f MB", float64(info.TotalSize)/(1024*1024)),
			"Binary files are marked and content excluded",
			"Hidden files and directories are included based on configuration",
		},
		ProjectInfo: info,
	}
}

// generateMinimalSummary 生成最小化摘要
func (g *AISummaryGenerator) generateMinimalSummary(info ProjectInfo) AISummary {
	return AISummary{
		GenerationHeader: fmt.Sprintf("Generated at %s", info.GeneratedAt.Format(time.RFC3339)),
		Purpose:          "Packed repository for AI analysis",
		FileFormat:       "XML",
		UsageGuidelines: []string{
			"Read-only reference",
			"For AI processing only",
		},
		Notes: []string{
			fmt.Sprintf("%d files", info.FileCount),
		},
		ProjectInfo: info,
	}
}

// generateDetailedSummary 生成详细摘要
func (g *AISummaryGenerator) generateDetailedSummary(info ProjectInfo) AISummary {
	languageList := strings.Join(info.Languages, ", ")

	return AISummary{
		GenerationHeader: fmt.Sprintf("Code Context Generator Output - Version 1.0.0 - Generated: %s", info.GeneratedAt.Format(time.RFC3339)),
		Purpose:          "This comprehensive XML file contains the complete codebase representation designed for advanced AI analysis, code review, and automated processing tasks.",
		FileFormat:       "Structured XML with detailed metadata, file contents, directory hierarchy, and AI-optimized formatting",
		UsageGuidelines: []string{
			"This file is a read-only snapshot of the repository state",
			"Ideal for AI-powered code analysis, security scanning, and documentation generation",
			"Use with token-aware processing for large repositories",
			"Content is escaped for XML compatibility while preserving readability",
			"Directory structure provides context for file relationships",
		},
		Notes: []string{
			fmt.Sprintf("Repository Statistics: %d files, %.2f MB total size", info.FileCount, float64(info.TotalSize)/(1024*1024)),
			fmt.Sprintf("Programming Languages: %s", languageList),
			"Binary files are identified and excluded from content analysis",
			"File metadata includes size, modification time, and language detection",
			"Directory structure reflects the complete project hierarchy",
			"Generated with code-context-generator tool for optimal AI processing",
		},
		ProjectInfo: info,
	}
}

// FormatAsXML 将摘要格式化为XML
func (s AISummary) FormatAsXML() string {
	var xml strings.Builder

	xml.WriteString("<file_summary>\n")

	// 生成信息
	xml.WriteString("  <generation_info>\n")
	xml.WriteString("    <tool>code-context-generator</tool>\n")
	xml.WriteString("    <version>1.0.0</version>\n")
	xml.WriteString(fmt.Sprintf("    <timestamp>%s</timestamp>\n", s.ProjectInfo.GeneratedAt.Format(time.RFC3339)))
	xml.WriteString("  </generation_info>\n")

	// AI指令
	xml.WriteString("  <ai_instructions>\n")
	xml.WriteString(fmt.Sprintf("    <purpose><![CDATA[%s]]></purpose>\n", s.Purpose))
	xml.WriteString("    <usage_guidelines>\n")
	for _, guideline := range s.UsageGuidelines {
		xml.WriteString(fmt.Sprintf("      <guideline><![CDATA[%s]]></guideline>\n", guideline))
	}
	xml.WriteString("    </usage_guidelines>\n")
	xml.WriteString("  </ai_instructions>\n")

	// 项目信息
	xml.WriteString("  <project_info>\n")
	xml.WriteString(fmt.Sprintf("    <file_count>%d</file_count>\n", s.ProjectInfo.FileCount))
	xml.WriteString(fmt.Sprintf("    <total_size>%d</total_size>\n", s.ProjectInfo.TotalSize))
	xml.WriteString("    <languages>\n")
	for _, lang := range s.ProjectInfo.Languages {
		xml.WriteString(fmt.Sprintf("      <language>%s</language>\n", lang))
	}
	xml.WriteString("    </languages>\n")
	xml.WriteString("  </project_info>\n")

	xml.WriteString("</file_summary>\n")

	return xml.String()
}

// FormatAsMarkdown 将摘要格式化为Markdown
func (s AISummary) FormatAsMarkdown() string {
	var md strings.Builder

	md.WriteString("# AI Analysis Summary\n\n")
	md.WriteString(fmt.Sprintf("**Generated:** %s\n\n", s.ProjectInfo.GeneratedAt.Format(time.RFC3339)))

	md.WriteString("## Purpose\n\n")
	md.WriteString(s.Purpose + "\n\n")

	md.WriteString("## Usage Guidelines\n\n")
	for _, guideline := range s.UsageGuidelines {
		md.WriteString(fmt.Sprintf("- %s\n", guideline))
	}
	md.WriteString("\n")

	md.WriteString("## Project Information\n\n")
	md.WriteString(fmt.Sprintf("- **Files:** %d\n", s.ProjectInfo.FileCount))
	md.WriteString(fmt.Sprintf("- **Total Size:** %.2f MB\n", float64(s.ProjectInfo.TotalSize)/(1024*1024)))
	if len(s.ProjectInfo.Languages) > 0 {
		md.WriteString(fmt.Sprintf("- **Languages:** %s\n", strings.Join(s.ProjectInfo.Languages, ", ")))
	}
	md.WriteString("\n")

	if len(s.Notes) > 0 {
		md.WriteString("## Notes\n\n")
		for _, note := range s.Notes {
			md.WriteString(fmt.Sprintf("- %s\n", note))
		}
		md.WriteString("\n")
	}

	return md.String()
}
